<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[Go] Tuning GC with pprof | Ding's Coding Forge</title>
<meta name=keywords content="go,pprof,profile,gc tuning"><meta name=description content="This post explores how to use pprof for profiling and optimizing Go applications, focusing on heap allocation, GC tuning, and performance bottleneck identification. It covers profiling setup with Gin, analyzing Flame Graphs and heap dumps, and optimizing memory allocations by addressing inefficient context usage and logging overhead. Additionally, it discusses GC tuning strategies (GOMEMLIMIT, GOGC) and best practices like pointer usage, slice capacity preallocation, and benchmarking techniques to improve application efficiency and reduce Stop-The-World (STW) latency."><meta name=author content="dingyu"><link rel=canonical href=https://dingyu.dev/en/posts/go-pprof-gc/><meta name=google-site-verification content="8XY1hI6NVxQIrN7bQbnX-9TG9HHFw5HOQmlb6vcsFdQ"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.ba0de23ad40e17ca82720b577f8ae6ec11a26fb07407316cff70888e344ad129.css integrity="sha256-ug3iOtQOF8qCcgtXf4rm7BGib7B0BzFs/3CIjjRK0Sk=" rel="preload stylesheet" as=style><link rel=icon href=https://dingyu.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dingyu.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dingyu.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://dingyu.dev/apple-touch-icon.png><link rel=mask-icon href=https://dingyu.dev/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://dingyu.dev/posts/go-pprof-gc/><link rel=alternate hreflang=en href=https://dingyu.dev/en/posts/go-pprof-gc/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-XH8830R9KK"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XH8830R9KK")}</script><meta property="og:url" content="https://dingyu.dev/en/posts/go-pprof-gc/"><meta property="og:site_name" content="Ding's Coding Forge"><meta property="og:title" content="[Go] Tuning GC with pprof"><meta property="og:description" content="This post explores how to use pprof for profiling and optimizing Go applications, focusing on heap allocation, GC tuning, and performance bottleneck identification. It covers profiling setup with Gin, analyzing Flame Graphs and heap dumps, and optimizing memory allocations by addressing inefficient context usage and logging overhead. Additionally, it discusses GC tuning strategies (GOMEMLIMIT, GOGC) and best practices like pointer usage, slice capacity preallocation, and benchmarking techniques to improve application efficiency and reduce Stop-The-World (STW) latency."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-13T00:00:00+00:00"><meta property="article:modified_time" content="2024-09-13T00:00:00+00:00"><meta property="article:tag" content="Go"><meta property="article:tag" content="Pprof"><meta property="article:tag" content="Profile"><meta property="article:tag" content="Gc Tuning"><meta property="og:image" content="https://dingyu.dev/en/posts/go-pprof-gc/img/go-thumbnail.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dingyu.dev/en/posts/go-pprof-gc/img/go-thumbnail.png"><meta name=twitter:title content="[Go] Tuning GC with pprof"><meta name=twitter:description content="This post explores how to use pprof for profiling and optimizing Go applications, focusing on heap allocation, GC tuning, and performance bottleneck identification. It covers profiling setup with Gin, analyzing Flame Graphs and heap dumps, and optimizing memory allocations by addressing inefficient context usage and logging overhead. Additionally, it discusses GC tuning strategies (GOMEMLIMIT, GOGC) and best practices like pointer usage, slice capacity preallocation, and benchmarking techniques to improve application efficiency and reduce Stop-The-World (STW) latency."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://dingyu.dev/en/posts/"},{"@type":"ListItem","position":2,"name":"[Go] Tuning GC with pprof","item":"https://dingyu.dev/en/posts/go-pprof-gc/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[Go] Tuning GC with pprof","name":"[Go] Tuning GC with pprof","description":"This post explores how to use pprof for profiling and optimizing Go applications, focusing on heap allocation, GC tuning, and performance bottleneck identification. It covers profiling setup with Gin, analyzing Flame Graphs and heap dumps, and optimizing memory allocations by addressing inefficient context usage and logging overhead. Additionally, it discusses GC tuning strategies (GOMEMLIMIT, GOGC) and best practices like pointer usage, slice capacity preallocation, and benchmarking techniques to improve application efficiency and reduce Stop-The-World (STW) latency.","keywords":["go","pprof","profile","gc tuning"],"articleBody":"Applying pprof import \"github.com/gin-contrib/pprof\" // initialize server var ( router *gin.Engine ) { router = gin.New() // register pprof routes pprof.Register(router, APIPrefix+\"/debug/pprof\") } Script echo \"User API v1.2.3\" # start profiling curl https://{endpoint}/debug/pprof/trace?seconds=10 --output v1.2.3-trace.out \u0026 curl https://{endpoint}/debug/pprof/heap?seconds=10 --output v1.2.3-heap.prof \u0026 curl https://{endpoint}/debug/pprof/profile?seconds=10 --output v1.2.3-cpu.prof \u0026 # Run load test while profiling bombardier -t 1s -l -c 30 -d 10s \\ -H \"Content-Type: application/json\" \\ -m GET https://{endpoint}/v1/users/51387659 wait # view pprof output locally go tool trace -http 127.0.0.1:9094 v1.2.3-trace.out \u0026 go tool pprof -http 127.0.0.1:9095 v1.2.3-heap.prof \u0026 go tool pprof -http 127.0.0.1:9096 v1.2.3-cpu.prof \u0026 Note: Bash \u0026 runs commands asynchronously.\npprof Usage Steps Start the application with pprof routes registered. If the app isn’t under load, run a load test on a target API. Use curl to trigger profiling. If you’re behind a Load Balancer, ensure profiling completes within the LB timeout.\nHeap Profiling Metrics inuse_objects: number of currently used objects inuse_space: amount of memory currently in use alloc_objects: total number of objects ever allocated alloc_space: total memory ever allocated Notes on Inuse vs Alloc Same Inuse/Alloc (e.g. 1GB/1GB): object was allocated once and reused — no GC triggered, CPU efficient. Alloc much larger than Inuse (e.g. 1TB/1GB): indicates high churn and frequent GC — may cause Stop-The-World (STW) pauses. Tuning Opportunities Flame Graph Flame Graphs help distinguish between user-defined logic and framework/internal code like ServeHTTP.\nThe wider the bar, the more allocations are made.\nContrary to expectations, Redis accounted for only 7.9% of allocations. Setting context values consumed 13.9% of heap allocations. Each context Set allocates a new map if the key doesn’t exist. Since no capacity is preallocated, this results in additional memory usage.\nIf the overhead for grouping logs by request ID is too high, consider removing it.\nAllocation Graph Larger rectangles = higher memory usage. Prioritize tuning large allocations with high % usage. Zerolog Overhead Despite using a shared Logger instance, allocations still occurred due to the use of With().Str().Logger() on every request.\nvar logEntry zerolog.Logger = h.logger.With(). Str(\"trace_id\", ctx.GetString(RequestIDContextKey)).Logger() Although cleaner for readability, this approach allocates new memory on each invocation.\nSolution: Accept the readability tradeoff or switch logging frameworks.\nHowever, other loggers may allocate even more due to interface marshalling. Always benchmark alternatives.\nGC Tuning Goal: minimize STW (Stop-The-World) latency caused by excessive GC.\nUsing GOMEMLIMIT GOGC uses heap growth rate to trigger GC. Default GOGC = 100 → GC triggers when heap doubles. Tuning Based on Program Behavior Low GOGC → GC runs too often, especially early on when heap is small. High GOGC → Risk of OOM. E.g., with 40GB heap and GOGC=50, GC only runs after heap reaches 60GB. GOMEMLIMIT caps memory usage before GC triggers. Set it below peak usage to reduce GC frequency.\nGOMEMLIMIT is a soft limit — Go may allocate slightly more than configured.\nSuggested Workflow:\nStart with default GOGC. Measure memory usage. Set GOMEMLIMIT to ~80% of peak. Monitor GC behavior. Benchmarking Production Code Use go test -benchmem to evaluate memory allocations.\ngo test -bench=. -benchmem Example benchmark of StructuredLogger:\nBenchmarkStructuredZeroLoggerMessage-12 596910 1724 ns/op 1000 B/op 30 allocs/op BenchmarkStructuredZeroLoggerMessageWithFields-12 285715 3926 ns/op 1633 B/op 60 allocs/op BenchmarkStructuredZeroLoggerMessageWithFieldsWithContext-12 222223 5346 ns/op 3418 B/op 68 allocs/op BenchmarkStandardZeroLoggerMessage-12 11927823 90.17 ns/op 0 B/op 0 allocs/op BenchmarkStandardZeroLoggerMessageWithDeterminedFields-12 5649648 217.6 ns/op 0 B/op 0 allocs/op BenchmarkStandardZeroLoggerWithFields-12 300001 3894 ns/op 1553 B/op 59 allocs/op Even with ZeroLogger, repeated use of WithFields leads to significant allocations.\nUse Case Driven Pointer Usage While pointers are efficient due to passing references instead of values, Go may allocate them on the heap, unlike value types which may reside on the stack.\nWhen to Use Pointers Large structs: avoid copying Mutability: need to modify original value Consistency: stick to pointer receivers for uniformity Nullable fields: to distinguish between zero value and nil Ref: https://articles.wesionary.team/use-case-of-pointers-in-go-w-practical-example-heap-stack-pointer-receiver-60b8950473da\nPreallocate Slice Capacity Without preallocating, append() causes reallocation on each operation.\nGo can optimize stack allocation for small-sized slices:\nMaxStackVarSize: up to 10MB for explicitly declared vars MaxImplicitStackVarSize: up to 64KB for implicit vars MaxSmallArraySize: arrays \u003c= 256 bytes are stack-allocated Ref: https://go.dev/src/cmd/compile/internal/ir/cfg.go\n","wordCount":"671","inLanguage":"en","image":"https://dingyu.dev/en/posts/go-pprof-gc/img/go-thumbnail.png","datePublished":"2024-09-13T00:00:00Z","dateModified":"2024-09-13T00:00:00Z","author":{"@type":"Person","name":"dingyu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://dingyu.dev/en/posts/go-pprof-gc/"},"publisher":{"@type":"Organization","name":"Ding's Coding Forge","logo":{"@type":"ImageObject","url":"https://dingyu.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dingyu.dev/en/ accesskey=h title="Ding's Coding Forge (Alt + H)"><img src=https://dingyu.dev/apple-touch-icon.png alt aria-label=logo height=35>Ding's Coding Forge</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://dingyu.dev/ title=한국어 aria-label=한국어>Ko</a></li></ul></div></div><ul id=menu><li><a href=https://dingyu.dev/en/about/ title=About><span>About</span></a></li><li><a href=https://dingyu.dev/en/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://dingyu.dev/en/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://dingyu.dev/en/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://dingyu.dev/en/search/ title=🔍><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://dingyu.dev/en/>Home</a>&nbsp;»&nbsp;<a href=https://dingyu.dev/en/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">[Go] Tuning GC with pprof</h1><div class=post-description>This post explores how to use pprof for profiling and optimizing Go applications, focusing on heap allocation, GC tuning, and performance bottleneck identification. It covers profiling setup with Gin, analyzing Flame Graphs and heap dumps, and optimizing memory allocations by addressing inefficient context usage and logging overhead. Additionally, it discusses GC tuning strategies (GOMEMLIMIT, GOGC) and best practices like pointer usage, slice capacity preallocation, and benchmarking techniques to improve application efficiency and reduce Stop-The-World (STW) latency.</div><div class=post-meta><span title='2024-09-13 00:00:00 +0000 UTC'>September 13, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;671 words&nbsp;·&nbsp;dingyu&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://dingyu.dev/posts/go-pprof-gc/>Ko</a></li></ul>&nbsp;|&nbsp;<a href=https://github.com/dings-things/blog/tree/main/content/posts/go-pprof-gc/index.en.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://dingyu.dev/img/go-thumbnail.png alt></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#applying-pprof aria-label="Applying pprof">Applying pprof</a></li><li><a href=#script aria-label=Script>Script</a><ul><li><a href=#pprof-usage-steps aria-label="pprof Usage Steps">pprof Usage Steps</a></li></ul></li><li><a href=#heap-profiling-metrics aria-label="Heap Profiling Metrics">Heap Profiling Metrics</a><ul><li><a href=#notes-on-inuse-vs-alloc aria-label="Notes on Inuse vs Alloc">Notes on Inuse vs Alloc</a></li></ul></li><li><a href=#tuning-opportunities aria-label="Tuning Opportunities">Tuning Opportunities</a><ul><li><a href=#flame-graph aria-label="Flame Graph">Flame Graph</a></li><li><a href=#allocation-graph aria-label="Allocation Graph">Allocation Graph</a><ul><li><a href=#zerolog-overhead aria-label="Zerolog Overhead">Zerolog Overhead</a></li></ul></li></ul></li><li><a href=#gc-tuning aria-label="GC Tuning">GC Tuning</a><ul><li><a href=#using-gomemlimit aria-label="Using GOMEMLIMIT">Using GOMEMLIMIT</a></li><li><a href=#tuning-based-on-program-behavior aria-label="Tuning Based on Program Behavior">Tuning Based on Program Behavior</a></li><li><a href=#benchmarking-production-code aria-label="Benchmarking Production Code">Benchmarking Production Code</a></li></ul></li><li><a href=#use-case-driven-pointer-usage aria-label="Use Case Driven Pointer Usage">Use Case Driven Pointer Usage</a><ul><li><a href=#when-to-use-pointers aria-label="When to Use Pointers">When to Use Pointers</a></li></ul></li><li><a href=#preallocate-slice-capacity aria-label="Preallocate Slice Capacity">Preallocate Slice Capacity</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=applying-pprof>Applying pprof<a hidden class=anchor aria-hidden=true href=#applying-pprof>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;github.com/gin-contrib/pprof&#34;</span>
</span></span><span class=line><span class=cl><span class=c1>// initialize server</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=nx>router</span> <span class=o>*</span><span class=nx>gin</span><span class=p>.</span><span class=nx>Engine</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>router</span> <span class=p>=</span> <span class=nx>gin</span><span class=p>.</span><span class=nf>New</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=c1>// register pprof routes</span>
</span></span><span class=line><span class=cl>	<span class=nx>pprof</span><span class=p>.</span><span class=nf>Register</span><span class=p>(</span><span class=nx>router</span><span class=p>,</span> <span class=nx>APIPrefix</span><span class=o>+</span><span class=s>&#34;/debug/pprof&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=script>Script<a hidden class=anchor aria-hidden=true href=#script>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;User API v1.2.3&#34;</span>
</span></span><span class=line><span class=cl><span class=c1># start profiling</span>
</span></span><span class=line><span class=cl>curl https://<span class=o>{</span>endpoint<span class=o>}</span>/debug/pprof/trace?seconds<span class=o>=</span><span class=m>10</span> --output v1.2.3-trace.out <span class=p>&amp;</span>
</span></span><span class=line><span class=cl>curl https://<span class=o>{</span>endpoint<span class=o>}</span>/debug/pprof/heap?seconds<span class=o>=</span><span class=m>10</span> --output v1.2.3-heap.prof <span class=p>&amp;</span>
</span></span><span class=line><span class=cl>curl https://<span class=o>{</span>endpoint<span class=o>}</span>/debug/pprof/profile?seconds<span class=o>=</span><span class=m>10</span> --output v1.2.3-cpu.prof <span class=p>&amp;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Run load test while profiling</span>
</span></span><span class=line><span class=cl>bombardier -t 1s -l -c <span class=m>30</span> -d 10s <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  -H <span class=s2>&#34;Content-Type: application/json&#34;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  -m GET https://<span class=o>{</span>endpoint<span class=o>}</span>/v1/users/51387659
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>wait</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># view pprof output locally</span>
</span></span><span class=line><span class=cl>go tool trace -http 127.0.0.1:9094 v1.2.3-trace.out <span class=p>&amp;</span>
</span></span><span class=line><span class=cl>go tool pprof -http 127.0.0.1:9095 v1.2.3-heap.prof <span class=p>&amp;</span>
</span></span><span class=line><span class=cl>go tool pprof -http 127.0.0.1:9096 v1.2.3-cpu.prof <span class=p>&amp;</span>
</span></span></code></pre></div><p>Note: Bash <code>&</code> runs commands asynchronously.</p><h3 id=pprof-usage-steps>pprof Usage Steps<a hidden class=anchor aria-hidden=true href=#pprof-usage-steps>#</a></h3><ol><li>Start the application with pprof routes registered.</li><li>If the app isn’t under load, run a load test on a target API.</li><li>Use curl to trigger profiling.</li></ol><blockquote><p>If you’re behind a Load Balancer, ensure profiling completes within the LB timeout.</p></blockquote><h2 id=heap-profiling-metrics>Heap Profiling Metrics<a hidden class=anchor aria-hidden=true href=#heap-profiling-metrics>#</a></h2><ul><li><code>inuse_objects</code>: number of currently used objects</li><li><code>inuse_space</code>: amount of memory currently in use</li><li><code>alloc_objects</code>: total number of objects ever allocated</li><li><code>alloc_space</code>: total memory ever allocated</li></ul><h3 id=notes-on-inuse-vs-alloc>Notes on Inuse vs Alloc<a hidden class=anchor aria-hidden=true href=#notes-on-inuse-vs-alloc>#</a></h3><ul><li><strong>Same Inuse/Alloc</strong> (e.g. 1GB/1GB): object was allocated once and reused — no GC triggered, CPU efficient.</li><li><strong>Alloc much larger than Inuse</strong> (e.g. 1TB/1GB): indicates high churn and frequent GC — may cause <strong>Stop-The-World (STW)</strong> pauses.</li></ul><p><img loading=lazy src=/posts/go-pprof-gc/image.png></p><h2 id=tuning-opportunities>Tuning Opportunities<a hidden class=anchor aria-hidden=true href=#tuning-opportunities>#</a></h2><h3 id=flame-graph>Flame Graph<a hidden class=anchor aria-hidden=true href=#flame-graph>#</a></h3><p>Flame Graphs help distinguish between user-defined logic and framework/internal code like <code>ServeHTTP</code>.</p><ul><li><p>The wider the bar, the more allocations are made.</p></li><li><p>Contrary to expectations, Redis accounted for only 7.9% of allocations.
<img loading=lazy src=/posts/go-pprof-gc/image-1.png></p></li><li><p>Setting context values consumed 13.9% of heap allocations.
<img loading=lazy src=/posts/go-pprof-gc/image-2.png></p></li></ul><p><img loading=lazy src=/posts/go-pprof-gc/image-3.png></p><p>Each context <code>Set</code> allocates a new map if the key doesn&rsquo;t exist. Since no capacity is preallocated, this results in additional memory usage.</p><blockquote><p>If the overhead for grouping logs by request ID is too high, consider removing it.</p></blockquote><h3 id=allocation-graph>Allocation Graph<a hidden class=anchor aria-hidden=true href=#allocation-graph>#</a></h3><p><img loading=lazy src=/posts/go-pprof-gc/image-4.png></p><ul><li>Larger rectangles = higher memory usage.</li><li>Prioritize tuning large allocations with high % usage.</li></ul><h4 id=zerolog-overhead>Zerolog Overhead<a hidden class=anchor aria-hidden=true href=#zerolog-overhead>#</a></h4><p><img loading=lazy src=/posts/go-pprof-gc/image-5.png></p><p>Despite using a shared <code>Logger</code> instance, allocations still occurred due to the use of <code>With().Str().Logger()</code> on every request.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>logEntry</span> <span class=nx>zerolog</span><span class=p>.</span><span class=nx>Logger</span> <span class=p>=</span> <span class=nx>h</span><span class=p>.</span><span class=nx>logger</span><span class=p>.</span><span class=nf>With</span><span class=p>().</span>
</span></span><span class=line><span class=cl>    <span class=nf>Str</span><span class=p>(</span><span class=s>&#34;trace_id&#34;</span><span class=p>,</span> <span class=nx>ctx</span><span class=p>.</span><span class=nf>GetString</span><span class=p>(</span><span class=nx>RequestIDContextKey</span><span class=p>)).</span><span class=nf>Logger</span><span class=p>()</span>
</span></span></code></pre></div><blockquote><p>Although cleaner for readability, this approach allocates new memory on each invocation.</p></blockquote><p><strong>Solution</strong>: Accept the readability tradeoff or switch logging frameworks.</p><blockquote><p>However, other loggers may allocate even more due to interface marshalling.
Always benchmark alternatives.</p></blockquote><h2 id=gc-tuning>GC Tuning<a hidden class=anchor aria-hidden=true href=#gc-tuning>#</a></h2><p>Goal: minimize <strong>STW (Stop-The-World)</strong> latency caused by excessive GC.</p><h3 id=using-gomemlimit>Using GOMEMLIMIT<a hidden class=anchor aria-hidden=true href=#using-gomemlimit>#</a></h3><ul><li><code>GOGC</code> uses <strong>heap growth rate</strong> to trigger GC.</li><li>Default GOGC = 100 → GC triggers when heap doubles.</li></ul><h3 id=tuning-based-on-program-behavior>Tuning Based on Program Behavior<a hidden class=anchor aria-hidden=true href=#tuning-based-on-program-behavior>#</a></h3><ul><li><strong>Low GOGC</strong> → GC runs too often, especially early on when heap is small.</li><li><strong>High GOGC</strong> → Risk of OOM. E.g., with 40GB heap and GOGC=50, GC only runs after heap reaches 60GB.</li></ul><p><strong>GOMEMLIMIT</strong> caps memory usage before GC triggers. Set it <strong>below peak usage</strong> to reduce GC frequency.</p><blockquote><p>GOMEMLIMIT is a soft limit — Go may allocate slightly more than configured.</p></blockquote><p><img loading=lazy src=/posts/go-pprof-gc/image-6.png></p><p><strong>Suggested Workflow</strong>:</p><ol><li>Start with default GOGC.</li><li>Measure memory usage.</li><li>Set GOMEMLIMIT to ~80% of peak.</li><li>Monitor GC behavior.</li></ol><h3 id=benchmarking-production-code>Benchmarking Production Code<a hidden class=anchor aria-hidden=true href=#benchmarking-production-code>#</a></h3><p>Use <code>go test -benchmem</code> to evaluate memory allocations.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>go <span class=nb>test</span> -bench<span class=o>=</span>. -benchmem
</span></span></code></pre></div><p>Example benchmark of <code>StructuredLogger</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>BenchmarkStructuredZeroLoggerMessage-12                                   <span class=m>596910</span>              <span class=m>1724</span> ns/op            <span class=m>1000</span> B/op         <span class=m>30</span> allocs/op
</span></span><span class=line><span class=cl>BenchmarkStructuredZeroLoggerMessageWithFields-12                         <span class=m>285715</span>              <span class=m>3926</span> ns/op            <span class=m>1633</span> B/op         <span class=m>60</span> allocs/op
</span></span><span class=line><span class=cl>BenchmarkStructuredZeroLoggerMessageWithFieldsWithContext-12              <span class=m>222223</span>              <span class=m>5346</span> ns/op            <span class=m>3418</span> B/op         <span class=m>68</span> allocs/op
</span></span><span class=line><span class=cl>BenchmarkStandardZeroLoggerMessage-12                                   <span class=m>11927823</span>                90.17 ns/op            <span class=m>0</span> B/op          <span class=m>0</span> allocs/op
</span></span><span class=line><span class=cl>BenchmarkStandardZeroLoggerMessageWithDeterminedFields-12                <span class=m>5649648</span>               217.6 ns/op             <span class=m>0</span> B/op          <span class=m>0</span> allocs/op
</span></span><span class=line><span class=cl>BenchmarkStandardZeroLoggerWithFields-12                                  <span class=m>300001</span>              <span class=m>3894</span> ns/op            <span class=m>1553</span> B/op         <span class=m>59</span> allocs/op
</span></span></code></pre></div><p>Even with ZeroLogger, repeated use of <code>WithFields</code> leads to significant allocations.</p><h2 id=use-case-driven-pointer-usage>Use Case Driven Pointer Usage<a hidden class=anchor aria-hidden=true href=#use-case-driven-pointer-usage>#</a></h2><p>While pointers are efficient due to passing references instead of values, Go may allocate them on the heap, unlike value types which may reside on the stack.</p><h3 id=when-to-use-pointers>When to Use Pointers<a hidden class=anchor aria-hidden=true href=#when-to-use-pointers>#</a></h3><ul><li><strong>Large structs</strong>: avoid copying</li><li><strong>Mutability</strong>: need to modify original value</li><li><strong>Consistency</strong>: stick to pointer receivers for uniformity</li><li><strong>Nullable fields</strong>: to distinguish between zero value and nil</li></ul><p>Ref: <a href=https://articles.wesionary.team/use-case-of-pointers-in-go-w-practical-example-heap-stack-pointer-receiver-60b8950473da>https://articles.wesionary.team/use-case-of-pointers-in-go-w-practical-example-heap-stack-pointer-receiver-60b8950473da</a></p><h2 id=preallocate-slice-capacity>Preallocate Slice Capacity<a hidden class=anchor aria-hidden=true href=#preallocate-slice-capacity>#</a></h2><p>Without preallocating, <code>append()</code> causes reallocation on each operation.</p><p>Go can optimize stack allocation for small-sized slices:</p><ul><li><code>MaxStackVarSize</code>: up to 10MB for explicitly declared vars</li><li><code>MaxImplicitStackVarSize</code>: up to 64KB for implicit vars</li><li><code>MaxSmallArraySize</code>: arrays &lt;= 256 bytes are stack-allocated</li></ul><p>Ref: <a href=https://go.dev/src/cmd/compile/internal/ir/cfg.go>https://go.dev/src/cmd/compile/internal/ir/cfg.go</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://dingyu.dev/en/tags/go/>Go</a></li><li><a href=https://dingyu.dev/en/tags/pprof/>Pprof</a></li><li><a href=https://dingyu.dev/en/tags/profile/>Profile</a></li><li><a href=https://dingyu.dev/en/tags/gc-tuning/>Gc Tuning</a></li></ul><nav class=paginav><a class=prev href=https://dingyu.dev/en/posts/coffee-pal/><span class=title>« Prev</span><br><span>[DX] Building a Slack Bot for Internal Coffee Chats</span>
</a><a class=next href=https://dingyu.dev/en/posts/sentry/><span class=title>Next »</span><br><span>[Third-Party] Integrating Sentry in Go</span></a></nav></footer><div id=giscus_thread><script src=https://giscus.app/client.js data-repo=dings-things/blog data-repo-id=R_kgDON9IuAw data-category=Announcements data-category-id=DIC_kwDON9IuA84CnTai data-mapping=og:title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=ko data-loading=lazy crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://dingyu.dev/en/>Ding's Coding Forge</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>
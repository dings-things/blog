<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[DB] Redis Transaction | Ding's Coding Forge</title>
<meta name=keywords content="redis,transaction,txpipeline"><meta name=description content="Unlike RDBMS, Redis doesn’t have a traditional transaction mechanism. It primarily operates as a single-threaded cache, but transactions can still be made atomic using TX pipelines or Lua scripts. This post focuses on comparing the pros and cons of Lua scripts vs. TX pipelines."><meta name=author content="dingyu"><link rel=canonical href=https://dingyu.dev/en/posts/redis-transaction/><meta name=google-site-verification content="8XY1hI6NVxQIrN7bQbnX-9TG9HHFw5HOQmlb6vcsFdQ"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.678f9035c217c5346e0b3de5bdc9ebac02c53b0502219858f8653d8d181c97b3.css integrity="sha256-Z4+QNcIXxTRuCz3lvcnrrALFOwUCIZhY+GU9jRgcl7M=" rel="preload stylesheet" as=style><link rel=icon href=https://dingyu.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dingyu.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dingyu.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://dingyu.dev/apple-touch-icon.png><link rel=mask-icon href=https://dingyu.dev/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://dingyu.dev/posts/redis-transaction/><link rel=alternate hreflang=en href=https://dingyu.dev/en/posts/redis-transaction/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-XH8830R9KK"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XH8830R9KK")}</script><meta property="og:url" content="https://dingyu.dev/en/posts/redis-transaction/"><meta property="og:site_name" content="Ding's Coding Forge"><meta property="og:title" content="[DB] Redis Transaction"><meta property="og:description" content="Unlike RDBMS, Redis doesn’t have a traditional transaction mechanism. It primarily operates as a single-threaded cache, but transactions can still be made atomic using TX pipelines or Lua scripts. This post focuses on comparing the pros and cons of Lua scripts vs. TX pipelines."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-31T00:00:00+00:00"><meta property="article:modified_time" content="2024-01-31T00:00:00+00:00"><meta property="article:tag" content="Redis"><meta property="article:tag" content="Transaction"><meta property="article:tag" content="Txpipeline"><meta property="og:image" content="https://dingyu.dev/en/posts/redis-transaction/img/redis.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dingyu.dev/en/posts/redis-transaction/img/redis.png"><meta name=twitter:title content="[DB] Redis Transaction"><meta name=twitter:description content="Unlike RDBMS, Redis doesn’t have a traditional transaction mechanism. It primarily operates as a single-threaded cache, but transactions can still be made atomic using TX pipelines or Lua scripts. This post focuses on comparing the pros and cons of Lua scripts vs. TX pipelines."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://dingyu.dev/en/posts/"},{"@type":"ListItem","position":2,"name":"[DB] Redis Transaction","item":"https://dingyu.dev/en/posts/redis-transaction/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[DB] Redis Transaction","name":"[DB] Redis Transaction","description":"Unlike RDBMS, Redis doesn’t have a traditional transaction mechanism. It primarily operates as a single-threaded cache, but transactions can still be made atomic using TX pipelines or Lua scripts. This post focuses on comparing the pros and cons of Lua scripts vs. TX pipelines.","keywords":["redis","transaction","txpipeline"],"articleBody":"Purpose For typical RDB transactions, we rely on isolation levels, rollback, and commit mechanisms.\nBut what about Redis?\nRedis does not offer clear options to ensure data consistency and atomicity out-of-the-box.\nThis document records the approach to isolate a transaction and achieve All-or-Nothing atomicity in Redis.\nOptions Redis TxPipeline Lua Script Redis TxPipeline When handling multiple commands in Redis, Pipeline is a natural choice.\nPipeline allows sending multiple commands to the Redis server in a batch and receiving multiple responses at once.\nHowever, standard Pipeline does NOT guarantee transactional integrity.\nDuring execution, data might still be modified by other commands, resulting in inconsistencies.\nEdge Cases Network Latency: Command and response order may mismatch due to network delay. Multi-threaded Environment: Redis allows concurrent client requests, making command execution order non-deterministic. Redis Server Configuration: Replication settings (e.g., slaveof) can impact consistency. TxPipeline solves these issues.\nPros Transactional Guarantee: Commands are treated as one atomic transaction. Performance Boost: Reduces network overhead by batching commands. Atomicity: All commands succeed or fail together (but no rollback). Cons Memory Usage: Large transactions consume significant memory. Complexity: Careful management is needed, especially when mixing with regular pipelines. Test Using WATCH ensures monitored keys are checked for changes. If any change occurs, the transaction fails.\nExample Transaction:\nMULTI SET key1 value1 SET key2 value2 SET key3 value3 EXEC If an error occurs at SET key2:\nMemory Exhaustion Case: OOM command not allowed when used memory \u0026gt; \u0026#39;maxmemory\u0026#39; Wrong Type Error: WRONGTYPE Operation against a key holding the wrong kind of value The most common realistic failure is client disconnection.\nEven if you attempt rollback manually after disconnection, it would likely fail — thus TxPipeline guarantees consistency but not perfect atomicity.\nLua Script Execute multiple Redis commands atomically inside a Lua script.\nEdge Cases Network Failure During Script Upload: Script might never reach the server. Network Failure During Response Reception: Script executes but the client may not receive the result. Pros Lightweight and Fast: Lua scripts execute efficiently. Built-in Scripting: Extends Redis functionality (like raw SQL vs ORM). Readable Syntax: Clean, easy-to-understand language. Cons Smaller Ecosystem: Fewer libraries and community support. Limited Data Types: Integer/floating point distinctions are loose. Strict Syntax: Steeper learning curve for beginners. Threading Limitations: Lua is fundamentally single-threaded. Test Lua scripts also do NOT support rollback.\nWorst-case scenario remains: network disconnection during execution.\nExample: Insert key1 ~ key5, simulate error at key3.\npackage main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/go-redis/redis/v8\u0026#34; ) var ctx = context.Background() func main() { rdb := redis.NewClient(\u0026amp;redis.Options{ Addr: \u0026#34;localhost:6379\u0026#34;, }) luaScript := ` for i = 1, #KEYS do if KEYS[i] == \u0026#39;key3\u0026#39; then error(\u0026#39;Error on setting key3\u0026#39;) else redis.call(\u0026#39;SET\u0026#39;, KEYS[i], ARGV[i]) end end ` keys := []string{\u0026#34;key1\u0026#34;, \u0026#34;key2\u0026#34;, \u0026#34;key3\u0026#34;, \u0026#34;key4\u0026#34;, \u0026#34;key5\u0026#34;} values := []interface{}{\u0026#34;value1\u0026#34;, \u0026#34;value2\u0026#34;, \u0026#34;value3\u0026#34;, \u0026#34;value4\u0026#34;, \u0026#34;value5\u0026#34;} err := rdb.Eval(ctx, luaScript, keys, values...).Err() if err != nil { fmt.Printf(\u0026#34;Lua script execution error: %v\\n\u0026#34;, err) return } fmt.Println(\u0026#34;Lua script executed successfully\u0026#34;) } [Result]\nSummary Pros \u0026 Cons TxPipeline Lua Script Key Features - Standard Redis syntax- Ensures data integrity- Optimistic lock (WATCH) prevents conflict - Requires Lua scripting- Ensures data integrity- Executes script as a single unit Transaction Rollback Not supported Not supported Drawbacks - Slightly lower performance than Lua- Complexity increases with large transactions - Management overhead for Lua scripts- Learning curve Both options guarantee data integrity, but neither supports rollback after failure. Validation before insertion reduces chances of runtime errors. Worst-case scenario: Redis client connection drops during transaction. Cannot roll back manually if disconnected. Consider Redis Sentinel if high availability edge cases need to be addressed. Benchmark Testing 1,000 key insertions into Redis:\nTest Item Test Count Avg Execution Time (ms) Lua Script 1424 0.83 TxPipeline 460 2.56 Pipeline 506 2.34 Performance differences are not critical. TxPipeline or Lua Script is recommended to ensure data consistency. ","wordCount":"627","inLanguage":"en","image":"https://dingyu.dev/en/posts/redis-transaction/img/redis.png","datePublished":"2024-01-31T00:00:00Z","dateModified":"2024-01-31T00:00:00Z","author":{"@type":"Person","name":"dingyu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://dingyu.dev/en/posts/redis-transaction/"},"publisher":{"@type":"Organization","name":"Ding's Coding Forge","logo":{"@type":"ImageObject","url":"https://dingyu.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dingyu.dev/en/ accesskey=h title="Ding's Coding Forge (Alt + H)"><img src=https://dingyu.dev/apple-touch-icon.png alt aria-label=logo height=35>Ding's Coding Forge</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button><span class=nav-separator>|</span><div class=lang-select-dropdown><button class=lang-select-dropdown-trigger aria-label=Translations type=button><svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 512 512" width="24" height="18"><path d="M478.33 433.6l-90-218a22 22 0 00-40.67.0l-90 218a22 22 0 1040.67 16.79L316.66 406h102.67l18.33 44.39A22 22 0 00458 464a22 22 0 0020.32-30.4zM334.83 362 368 281.65 401.17 362z" fill="currentcolor"/><path d="M267.84 342.92a22 22 0 00-4.89-30.7c-.2-.15-15-11.13-36.49-34.73 39.65-53.68 62.11-114.75 71.27-143.49H330a22 22 0 000-44H214V70a22 22 0 00-44 0v20H54a22 22 0 000 44h197.25c-9.52 26.95-27.05 69.5-53.79 108.36-31.41-41.68-43.08-68.65-43.17-68.87a22 22 0 00-40.58 17c.58 1.38 14.55 34.23 52.86 83.93.92 1.19 1.83 2.35 2.74 3.51-39.24 44.35-77.74 71.86-93.85 80.74a22 22 0 1021.07 38.63c2.16-1.18 48.6-26.89 101.63-85.59 22.52 24.08 38 35.44 38.93 36.1a22 22 0 0030.75-4.9z" fill="currentcolor"/></svg></button><div class=lang-select-dropdown-content><a lang=ko href=https://dingyu.dev/ title=한국어 aria-label=한국어>한국어</a></div></div></div></div><ul id=menu><li><a href=https://dingyu.dev/en/about/ title=About><span>About</span></a></li><li><a href=https://dingyu.dev/en/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://dingyu.dev/en/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://dingyu.dev/en/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://dingyu.dev/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://dingyu.dev/en/>Home</a>&nbsp;»&nbsp;<a href=https://dingyu.dev/en/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">[DB] Redis Transaction</h1><div class=post-description>Unlike RDBMS, Redis doesn’t have a traditional transaction mechanism. It primarily operates as a single-threaded cache, but transactions can still be made atomic using TX pipelines or Lua scripts. This post focuses on comparing the pros and cons of Lua scripts vs. TX pipelines.</div><div class=post-meta><span title='2024-01-31 00:00:00 +0000 UTC'>January 31, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;627 words&nbsp;·&nbsp;dingyu&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://dingyu.dev/posts/redis-transaction/>Ko</a></li></ul>&nbsp;|&nbsp;<a href=https://github.com/dings-things/blog/tree/main/content/posts/redis-transaction/index.en.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://dingyu.dev/img/redis.png alt></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#purpose aria-label=Purpose>Purpose</a></li><li><a href=#options aria-label=Options>Options</a><ul><li><a href=#redis-txpipeline aria-label="Redis TxPipeline">Redis TxPipeline</a><ul><li><a href=#edge-cases aria-label="Edge Cases">Edge Cases</a></li><li><a href=#pros aria-label=Pros>Pros</a></li><li><a href=#cons aria-label=Cons>Cons</a></li><li><a href=#test aria-label=Test>Test</a></li></ul></li><li><a href=#lua-script aria-label="Lua Script">Lua Script</a><ul><li><a href=#edge-cases-1 aria-label="Edge Cases">Edge Cases</a></li><li><a href=#pros-1 aria-label=Pros>Pros</a></li><li><a href=#cons-1 aria-label=Cons>Cons</a></li><li><a href=#test-1 aria-label=Test>Test</a></li></ul></li></ul></li><li><a href=#summary aria-label=Summary>Summary</a><ul><li><a href=#pros--cons aria-label="Pros & Cons">Pros & Cons</a></li><li><a href=#benchmark aria-label=Benchmark>Benchmark</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=purpose>Purpose<a hidden class=anchor aria-hidden=true href=#purpose>#</a></h1><p>For typical RDB transactions, we rely on isolation levels, rollback, and commit mechanisms.</p><p>But what about <strong>Redis</strong>?</p><p>Redis does not offer clear options to ensure data consistency and atomicity out-of-the-box.</p><p>This document records the approach to <strong>isolate a transaction</strong> and achieve <strong>All-or-Nothing atomicity</strong> in Redis.</p><hr><h1 id=options>Options<a hidden class=anchor aria-hidden=true href=#options>#</a></h1><ol><li>Redis TxPipeline</li><li>Lua Script</li></ol><hr><h2 id=redis-txpipeline>Redis TxPipeline<a hidden class=anchor aria-hidden=true href=#redis-txpipeline>#</a></h2><p>When handling multiple commands in Redis, Pipeline is a natural choice.</p><p>Pipeline allows sending multiple commands to the Redis server in a batch and receiving multiple responses at once.</p><p>However, <strong>standard Pipeline does NOT guarantee transactional integrity</strong>.<br>During execution, data might still be modified by other commands, resulting in inconsistencies.</p><h3 id=edge-cases>Edge Cases<a hidden class=anchor aria-hidden=true href=#edge-cases>#</a></h3><ol><li><strong>Network Latency</strong>: Command and response order may mismatch due to network delay.</li><li><strong>Multi-threaded Environment</strong>: Redis allows concurrent client requests, making command execution order non-deterministic.</li><li><strong>Redis Server Configuration</strong>: Replication settings (e.g., <code>slaveof</code>) can impact consistency.</li></ol><p><strong>TxPipeline</strong> solves these issues.</p><h3 id=pros>Pros<a hidden class=anchor aria-hidden=true href=#pros>#</a></h3><ul><li><strong>Transactional Guarantee</strong>: Commands are treated as one atomic transaction.</li><li><strong>Performance Boost</strong>: Reduces network overhead by batching commands.</li><li><strong>Atomicity</strong>: All commands succeed or fail together (but no rollback).</li></ul><h3 id=cons>Cons<a hidden class=anchor aria-hidden=true href=#cons>#</a></h3><ul><li><strong>Memory Usage</strong>: Large transactions consume significant memory.</li><li><strong>Complexity</strong>: Careful management is needed, especially when mixing with regular pipelines.</li></ul><h3 id=test>Test<a hidden class=anchor aria-hidden=true href=#test>#</a></h3><p><img loading=lazy src=/posts/redis-transaction/2.png></p><blockquote><p>Using <code>WATCH</code> ensures monitored keys are checked for changes. If any change occurs, the transaction fails.</p></blockquote><p>Example Transaction:</p><pre tabindex=0><code class=language-bash>MULTI
SET key1 value1
SET key2 value2
SET key3 value3
EXEC</code></pre><p>If an error occurs at <code>SET key2</code>:</p><ul><li><strong>Memory Exhaustion Case</strong>:</li></ul><pre tabindex=0><code class=language-bash>OOM command not allowed when used memory &amp;gt; &amp;#39;maxmemory&amp;#39;</code></pre><ul><li><strong>Wrong Type Error</strong>:</li></ul><pre tabindex=0><code class=language-bash>WRONGTYPE Operation against a key holding the wrong kind of value</code></pre><p>The most common realistic failure is client disconnection.</p><p>Even if you attempt rollback manually after disconnection, it would likely fail —
thus <strong>TxPipeline guarantees consistency but not perfect atomicity</strong>.</p><hr><h2 id=lua-script>Lua Script<a hidden class=anchor aria-hidden=true href=#lua-script>#</a></h2><p>Execute multiple Redis commands atomically inside a Lua script.</p><h3 id=edge-cases-1>Edge Cases<a hidden class=anchor aria-hidden=true href=#edge-cases-1>#</a></h3><ol><li><strong>Network Failure During Script Upload</strong>: Script might never reach the server.</li><li><strong>Network Failure During Response Reception</strong>: Script executes but the client may not receive the result.</li></ol><h3 id=pros-1>Pros<a hidden class=anchor aria-hidden=true href=#pros-1>#</a></h3><ul><li><strong>Lightweight and Fast</strong>: Lua scripts execute efficiently.</li><li><strong>Built-in Scripting</strong>: Extends Redis functionality (like raw SQL vs ORM).</li><li><strong>Readable Syntax</strong>: Clean, easy-to-understand language.</li></ul><h3 id=cons-1>Cons<a hidden class=anchor aria-hidden=true href=#cons-1>#</a></h3><ul><li><strong>Smaller Ecosystem</strong>: Fewer libraries and community support.</li><li><strong>Limited Data Types</strong>: Integer/floating point distinctions are loose.</li><li><strong>Strict Syntax</strong>: Steeper learning curve for beginners.</li><li><strong>Threading Limitations</strong>: Lua is fundamentally single-threaded.</li></ul><h3 id=test-1>Test<a hidden class=anchor aria-hidden=true href=#test-1>#</a></h3><p>Lua scripts also <strong>do NOT support rollback</strong>.</p><p>Worst-case scenario remains: network disconnection during execution.</p><p><strong>Example</strong>: Insert key1 ~ key5, simulate error at key3.</p><pre tabindex=0><code class=language-go>package main

import (
	&amp;#34;context&amp;#34;
	&amp;#34;fmt&amp;#34;
	&amp;#34;github.com/go-redis/redis/v8&amp;#34;
)

var ctx = context.Background()

func main() {
	rdb := redis.NewClient(&amp;amp;redis.Options{
		Addr: &amp;#34;localhost:6379&amp;#34;,
	})

	luaScript := `
    for i = 1, #KEYS do
        if KEYS[i] == &amp;#39;key3&amp;#39; then
            error(&amp;#39;Error on setting key3&amp;#39;)
        else
            redis.call(&amp;#39;SET&amp;#39;, KEYS[i], ARGV[i])
        end
    end
    `

	keys := []string{&amp;#34;key1&amp;#34;, &amp;#34;key2&amp;#34;, &amp;#34;key3&amp;#34;, &amp;#34;key4&amp;#34;, &amp;#34;key5&amp;#34;}
	values := []interface{}{&amp;#34;value1&amp;#34;, &amp;#34;value2&amp;#34;, &amp;#34;value3&amp;#34;, &amp;#34;value4&amp;#34;, &amp;#34;value5&amp;#34;}

	err := rdb.Eval(ctx, luaScript, keys, values...).Err()
	if err != nil {
		fmt.Printf(&amp;#34;Lua script execution error: %v\n&amp;#34;, err)
		return
	}

	fmt.Println(&amp;#34;Lua script executed successfully&amp;#34;)
}</code></pre><p>[Result]</p><p><img loading=lazy src=/posts/redis-transaction/1.png></p><hr><h1 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h1><h2 id=pros--cons>Pros & Cons<a hidden class=anchor aria-hidden=true href=#pros--cons>#</a></h2><table><thead><tr><th></th><th>TxPipeline</th><th>Lua Script</th></tr></thead><tbody><tr><td><strong>Key Features</strong></td><td>- Standard Redis syntax- Ensures data integrity- Optimistic lock (<code>WATCH</code>) prevents conflict</td><td>- Requires Lua scripting- Ensures data integrity- Executes script as a single unit</td></tr><tr><td><strong>Transaction Rollback</strong></td><td>Not supported</td><td>Not supported</td></tr><tr><td><strong>Drawbacks</strong></td><td>- Slightly lower performance than Lua- Complexity increases with large transactions</td><td>- Management overhead for Lua scripts- Learning curve</td></tr></tbody></table><hr><ul><li>Both options guarantee <strong>data integrity</strong>, but neither supports rollback after failure.</li><li><strong>Validation before insertion</strong> reduces chances of runtime errors.</li><li><strong>Worst-case scenario</strong>:<ul><li>Redis client connection drops during transaction.</li><li>Cannot roll back manually if disconnected.</li></ul></li><li>Consider Redis Sentinel if high availability edge cases need to be addressed.</li></ul><h2 id=benchmark>Benchmark<a hidden class=anchor aria-hidden=true href=#benchmark>#</a></h2><p>Testing 1,000 key insertions into Redis:</p><table><thead><tr><th>Test Item</th><th>Test Count</th><th>Avg Execution Time (ms)</th></tr></thead><tbody><tr><td>Lua Script</td><td>1424</td><td>0.83</td></tr><tr><td>TxPipeline</td><td>460</td><td>2.56</td></tr><tr><td>Pipeline</td><td>506</td><td>2.34</td></tr></tbody></table><ul><li>Performance differences are not critical.</li><li><strong>TxPipeline or Lua Script is recommended</strong> to ensure data consistency.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://dingyu.dev/en/tags/redis/>Redis</a></li><li><a href=https://dingyu.dev/en/tags/transaction/>Transaction</a></li><li><a href=https://dingyu.dev/en/tags/txpipeline/>Txpipeline</a></li></ul><nav class=paginav><a class=prev href=https://dingyu.dev/en/posts/aws-well-architected/><span class=title>« Prev</span><br><span>[Infra] AWS Well Architected</span>
</a><a class=next href=https://dingyu.dev/en/posts/fastapi-convention/><span class=title>Next »</span><br><span>[Python] FastAPI Convention</span></a></nav></footer><div id=giscus_thread><script src=https://giscus.app/client.js data-repo=dings-things/blog data-repo-id=R_kgDON9IuAw data-category=Announcements data-category-id=DIC_kwDON9IuA84CnTai data-mapping=og:title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=ko data-loading=lazy crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://dingyu.dev/en/>Ding's Coding Forge</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>
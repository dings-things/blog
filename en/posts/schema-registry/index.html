<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[EDA] Schema Registry | Ding's Coding Forge</title>
<meta name=keywords content="kafka,avro,protobuf,json,schema registry"><meta name=description content="People often underestimate the importance of documenting schemas before starting to code, especially when working with stream processing. In this post, I‚Äôll explain why using a schema registry is essential and why designing schemas upfront is crucial before diving into coding."><meta name=author content="dingyu"><link rel=canonical href=https://dingyu.dev/en/posts/schema-registry/><meta name=google-site-verification content="8XY1hI6NVxQIrN7bQbnX-9TG9HHFw5HOQmlb6vcsFdQ"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.678f9035c217c5346e0b3de5bdc9ebac02c53b0502219858f8653d8d181c97b3.css integrity="sha256-Z4+QNcIXxTRuCz3lvcnrrALFOwUCIZhY+GU9jRgcl7M=" rel="preload stylesheet" as=style><link rel=icon href=https://dingyu.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dingyu.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dingyu.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://dingyu.dev/apple-touch-icon.png><link rel=mask-icon href=https://dingyu.dev/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://dingyu.dev/posts/schema-registry/><link rel=alternate hreflang=en href=https://dingyu.dev/en/posts/schema-registry/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-XH8830R9KK"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XH8830R9KK")}</script><meta property="og:url" content="https://dingyu.dev/en/posts/schema-registry/"><meta property="og:site_name" content="Ding's Coding Forge"><meta property="og:title" content="[EDA] Schema Registry"><meta property="og:description" content="People often underestimate the importance of documenting schemas before starting to code, especially when working with stream processing. In this post, I‚Äôll explain why using a schema registry is essential and why designing schemas upfront is crucial before diving into coding."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-24T00:00:00+00:00"><meta property="article:modified_time" content="2025-02-24T00:00:00+00:00"><meta property="article:tag" content="Kafka"><meta property="article:tag" content="Avro"><meta property="article:tag" content="Protobuf"><meta property="article:tag" content="Json"><meta property="article:tag" content="Schema Registry"><meta property="og:image" content="https://dingyu.dev/en/posts/schema-registry/img/kafka.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dingyu.dev/en/posts/schema-registry/img/kafka.png"><meta name=twitter:title content="[EDA] Schema Registry"><meta name=twitter:description content="People often underestimate the importance of documenting schemas before starting to code, especially when working with stream processing. In this post, I‚Äôll explain why using a schema registry is essential and why designing schemas upfront is crucial before diving into coding."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://dingyu.dev/en/posts/"},{"@type":"ListItem","position":2,"name":"[EDA] Schema Registry","item":"https://dingyu.dev/en/posts/schema-registry/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[EDA] Schema Registry","name":"[EDA] Schema Registry","description":"People often underestimate the importance of documenting schemas before starting to code, especially when working with stream processing. In this post, I‚Äôll explain why using a schema registry is essential and why designing schemas upfront is crucial before diving into coding.","keywords":["kafka","avro","protobuf","json","schema registry"],"articleBody":"Introduction In Event-Driven Architecture (EDA) that aims for loose coupling and high scalability, paradoxically, event schemas create a strong contract between Producers and Consumers. Why do we use schemas and Schema Registry in the first place? Purpose of Event Schema Defines the structure of data, standardizes message formats, and ensures data consistency between Producers and Consumers. Maintains compatibility between Producers and Consumers. Enables data validation. Consider the familiar REST API as an analogy!\nWhen services communicate, they agree on an interface ‚Äî typically documented using OpenAPI or similar specifications ‚Äî describing required input and expected output.\nThe same applies to event streams:\nWhen a Producer publishes a pre-defined event, the Consumer processes it based on the agreed schema.\nExample 1 ‚Äî Suppose a schema was agreed as follows:\n{ \u0026#34;user_id\u0026#34;: number, \u0026#34;user_action\u0026#34;: \u0026#34;string\u0026#34; } However, the Producer mistakenly emits user_action as a code rather than a string:\n(This triggers the Consumer‚Äôs rage ü§¢)\nJust like you wouldn‚Äôt insert records into a database without designing an ERD, schema design is mandatory in EDA.\nEvent Schema Formats Choosing a schema format? Here‚Äôs a comparison:\nFormat Advantages Disadvantages JSON (JavaScript Object Notation) Human-readable text format. Widely supported across languages. Large message size. No enforced schema, risking data integrity. Protobuf (Protocol Buffers) Compact binary format by Google. Strong typing with enforced schemas. Faster parsing, smaller messages compared to JSON. Not human-readable. Requires predefined schemas. Smaller ecosystem than JSON. Avro Schema-based, compact binary format. Supports Schema Evolution without breaking existing programs. Less popular than JSON/Protobuf. Tooling/library support may be limited. Since event streams involve network transmission, data size matters.\nIf you‚Äôre used to writing API specs, JSON might feel natural ‚Äî but should you really default to it?\nChecklist for Choosing JSON (‚ÄúDie-Hard JSON Fan‚Äù) If you answer ‚Äúyes‚Äù to all below, JSON could still be a good fit:\nIs the data size small? Can you tolerate serialization/deserialization overhead? Is strong type validation unnecessary? No plans to use Schema Registry? No expected major growth in data volume? Need for human-readable debugging? Advantages of Avro / Protobuf Strong Type Validation Serialization fails if fields do not match specified types (e.g., ENUM, float). High Serialization/Deserialization Performance Binary formats like Avro and Protobuf require no parsing, unlike text-based JSON. Schema Evolution Support New fields can be ignored by older consumers without issues. Benchmark: Even for small payloads, JSON lags behind Avro/Protobuf by more than 2x in performance.\nAnd the performance gap widens as payload size grows.\nImpact of Data Size on Performance Since JSON is stored as text instead of binary, it consumes more space:\nLarger Kafka volumes Degraded produce/consume performance Larger data costs more during ISR (in-sync replication) Larger payloads cause slower fetches during consumption Schema Registry Summarizing the core benefits of event schemas:\nConsistency Performance Compatibility A Schema Registry centrally manages and validates Kafka message schemas, ensuring compatibility between producers and consumers.\nSchema Evolution and Compatibility Example 2: Think of moving from v1 API to v2 API.\nKeep backward compatibility initially. Gradually migrate clients. Eventually deprecate the old API. In event streams, updating schemas means notifying Consumers about changes. But which should update first, Producer or Consumer?\nFortunately, Schema Registry solves this:\nProducer publishes events using the new v2 schema. Consumer detects schema changes and fetches the new version dynamically. Thus enabling smooth schema evolution without service disruptions.\nEfficient Event Management Is using a Schema Registry mandatory?\nNo. Choosing the right tool depends on your needs.\nSchema Awareness in Kafka Streams For Avro/Protobuf (binary formats), schemas are essential because raw binary data isn‚Äôt self-describing:\nEvent Size Considerations While Avro/Protobuf compress data well, embedding full schema info in each event would negate their size advantage:\nUsing schema IDs instead (with Schema Registry) minimizes event size while preserving compatibility.\nNote:\nIf both Producer and Consumer share identical .proto files, they can theoretically skip embedding schemas. But this approach has downsides: Tight coupling between producer/consumer. No dynamic schema updates. Requires redeploying both producer and consumer on schema changes. AWS Glue vs. Confluent Schema Registry Feature AWS Glue Schema Registry Confluent Schema Registry Schema Updates Adds as new version Adds as new version URL Stability ‚úÖ (ARN-based) ‚úÖ (REST API-based) Auto-use of Latest Version ‚ùå (Needs config) ‚úÖ (Automatic) Kafka Compatibility ‚úÖ (Works with AWS MSK) ‚úÖ (Works with Confluent Kafka) Why Use Schema Registry? Maintains Data Consistency Ensures producer messages match consumer expectations. Prevents business logic errors. Supports Schema Evolution Add/change fields without breaking existing consumers. Centralized Schema Management No need for manual schema file syncing. Minimizes Kafka Message Size Sends lightweight schema IDs instead of full schemas. Provides Schema Validation Catches invalid payloads early. Enables Real-time Schema Updates Consumers fetch updated schemas dynamically. Configurable Compatibility Modes Prevents breaking changes. Versioned Schema History and Easy Rollbacks Retrieve or roll back to any historical schema version. References Confluent Oliveyoung Tech Blog Exploring Data Serialization in Apache Kafka ","wordCount":"807","inLanguage":"en","image":"https://dingyu.dev/en/posts/schema-registry/img/kafka.png","datePublished":"2025-02-24T00:00:00Z","dateModified":"2025-02-24T00:00:00Z","author":{"@type":"Person","name":"dingyu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://dingyu.dev/en/posts/schema-registry/"},"publisher":{"@type":"Organization","name":"Ding's Coding Forge","logo":{"@type":"ImageObject","url":"https://dingyu.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dingyu.dev/en/ accesskey=h title="Ding's Coding Forge (Alt + H)"><img src=https://dingyu.dev/apple-touch-icon.png alt aria-label=logo height=35>Ding's Coding Forge</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button><span class=nav-separator>|</span><div class=lang-select-dropdown><button class=lang-select-dropdown-trigger aria-label=Translations type=button><svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 512 512" width="24" height="18"><path d="M478.33 433.6l-90-218a22 22 0 00-40.67.0l-90 218a22 22 0 1040.67 16.79L316.66 406h102.67l18.33 44.39A22 22 0 00458 464a22 22 0 0020.32-30.4zM334.83 362 368 281.65 401.17 362z" fill="currentcolor"/><path d="M267.84 342.92a22 22 0 00-4.89-30.7c-.2-.15-15-11.13-36.49-34.73 39.65-53.68 62.11-114.75 71.27-143.49H330a22 22 0 000-44H214V70a22 22 0 00-44 0v20H54a22 22 0 000 44h197.25c-9.52 26.95-27.05 69.5-53.79 108.36-31.41-41.68-43.08-68.65-43.17-68.87a22 22 0 00-40.58 17c.58 1.38 14.55 34.23 52.86 83.93.92 1.19 1.83 2.35 2.74 3.51-39.24 44.35-77.74 71.86-93.85 80.74a22 22 0 1021.07 38.63c2.16-1.18 48.6-26.89 101.63-85.59 22.52 24.08 38 35.44 38.93 36.1a22 22 0 0030.75-4.9z" fill="currentcolor"/></svg></button><div class=lang-select-dropdown-content><a lang=ko href=https://dingyu.dev/ title=ÌïúÍµ≠Ïñ¥ aria-label=ÌïúÍµ≠Ïñ¥>ÌïúÍµ≠Ïñ¥</a></div></div></div></div><ul id=menu><li><a href=https://dingyu.dev/en/about/ title=About><span>About</span></a></li><li><a href=https://dingyu.dev/en/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://dingyu.dev/en/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://dingyu.dev/en/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://dingyu.dev/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://dingyu.dev/en/>Home</a>&nbsp;¬ª&nbsp;<a href=https://dingyu.dev/en/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">[EDA] Schema Registry</h1><div class=post-description>People often underestimate the importance of documenting schemas before starting to code, especially when working with stream processing. In this post, I‚Äôll explain why using a schema registry is essential and why designing schemas upfront is crucial before diving into coding.</div><div class=post-meta><span title='2025-02-24 00:00:00 +0000 UTC'>February 24, 2025</span>&nbsp;¬∑&nbsp;4 min&nbsp;¬∑&nbsp;807 words&nbsp;¬∑&nbsp;dingyu&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://dingyu.dev/posts/schema-registry/>Ko</a></li></ul>&nbsp;|&nbsp;<a href=https://github.com/dings-things/blog/tree/main/content/posts/schema-registry/index.en.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://dingyu.dev/img/kafka.png alt></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#introduction aria-label=Introduction>Introduction</a></li><li><a href=#purpose-of-event-schema aria-label="Purpose of Event Schema">Purpose of Event Schema</a></li><li><a href=#event-schema-formats aria-label="Event Schema Formats">Event Schema Formats</a></li><li><a href=#checklist-for-choosing-json-die-hard-json-fan aria-label="Checklist for Choosing JSON (&ldquo;Die-Hard JSON Fan&rdquo;)">Checklist for Choosing JSON (&ldquo;Die-Hard JSON Fan&rdquo;)</a></li><li><a href=#advantages-of-avro--protobuf aria-label="Advantages of Avro / Protobuf">Advantages of Avro / Protobuf</a></li><li><a href=#impact-of-data-size-on-performance aria-label="Impact of Data Size on Performance">Impact of Data Size on Performance</a></li><li><a href=#schema-registry aria-label="Schema Registry">Schema Registry</a><ul><li><a href=#schema-evolution-and-compatibility aria-label="Schema Evolution and Compatibility">Schema Evolution and Compatibility</a></li><li><a href=#efficient-event-management aria-label="Efficient Event Management">Efficient Event Management</a><ul><li><a href=#schema-awareness-in-kafka-streams aria-label="Schema Awareness in Kafka Streams">Schema Awareness in Kafka Streams</a></li><li><a href=#event-size-considerations aria-label="Event Size Considerations">Event Size Considerations</a></li></ul></li><li><a href=#aws-glue-vs-confluent-schema-registry aria-label="AWS Glue vs. Confluent Schema Registry">AWS Glue vs. Confluent Schema Registry</a></li></ul></li><li><a href=#why-use-schema-registry aria-label="Why Use Schema Registry?">Why Use Schema Registry?</a></li><li><a href=#references aria-label=References>References</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h1><ul><li>In Event-Driven Architecture (EDA) that aims for loose coupling and high scalability, paradoxically, <strong>event schemas</strong> create a strong contract between <code>Producers</code> and <code>Consumers</code>.</li><li>Why do we use schemas and Schema Registry in the first place?</li></ul><h1 id=purpose-of-event-schema>Purpose of Event Schema<a hidden class=anchor aria-hidden=true href=#purpose-of-event-schema>#</a></h1><ul><li>Defines the structure of data, standardizes message formats, and ensures <strong>data consistency</strong> between <code>Producers</code> and <code>Consumers</code>.</li><li>Maintains <strong>compatibility</strong> between <code>Producers</code> and <code>Consumers</code>.</li><li>Enables data validation.</li></ul><p>Consider the familiar REST API as an analogy!</p><p><img loading=lazy src=/posts/schema-registry/image.png></p><p>When services communicate, they agree on an interface ‚Äî typically documented using OpenAPI or similar specifications ‚Äî describing required input and expected output.</p><p>The same applies to event streams:</p><p>When a <code>Producer</code> publishes a pre-defined event, the <code>Consumer</code> processes it based on the agreed schema.</p><p><strong>Example 1</strong> ‚Äî Suppose a schema was agreed as follows:</p><pre tabindex=0><code class=language-json>{
    &amp;#34;user_id&amp;#34;: number,
    &amp;#34;user_action&amp;#34;: &amp;#34;string&amp;#34;
}</code></pre><p>However, the <code>Producer</code> mistakenly emits <code>user_action</code> as a code rather than a string:</p><p><img loading=lazy src=/posts/schema-registry/kafka-event-mismatch.png></p><p>(This triggers the Consumer&rsquo;s rage ü§¢)</p><p>Just like you wouldn&rsquo;t insert records into a database without designing an ERD, schema design is <strong>mandatory</strong> in EDA.</p><h1 id=event-schema-formats>Event Schema Formats<a hidden class=anchor aria-hidden=true href=#event-schema-formats>#</a></h1><p>Choosing a schema format? Here&rsquo;s a comparison:</p><table><thead><tr><th>Format</th><th>Advantages</th><th>Disadvantages</th></tr></thead><tbody><tr><td><strong>JSON</strong> (JavaScript Object Notation)</td><td>Human-readable text format. Widely supported across languages.</td><td>Large message size. No enforced schema, risking data integrity.</td></tr><tr><td><strong>Protobuf</strong> (Protocol Buffers)</td><td>Compact binary format by Google. Strong typing with enforced schemas. Faster parsing, smaller messages compared to JSON.</td><td>Not human-readable. Requires predefined schemas. Smaller ecosystem than JSON.</td></tr><tr><td><strong>Avro</strong></td><td>Schema-based, compact binary format. Supports Schema Evolution without breaking existing programs.</td><td>Less popular than JSON/Protobuf. Tooling/library support may be limited.</td></tr></tbody></table><p>Since event streams involve network transmission, <strong>data size matters</strong>.</p><p>If you&rsquo;re used to writing API specs, JSON might feel natural ‚Äî but should you really default to it?</p><h1 id=checklist-for-choosing-json-die-hard-json-fan>Checklist for Choosing JSON (&ldquo;Die-Hard JSON Fan&rdquo;)<a hidden class=anchor aria-hidden=true href=#checklist-for-choosing-json-die-hard-json-fan>#</a></h1><p>If you answer &ldquo;yes&rdquo; to all below, JSON could still be a good fit:</p><ul><li><input checked disabled type=checkbox> Is the data size small?</li><li><input checked disabled type=checkbox> Can you tolerate serialization/deserialization overhead?</li><li><input checked disabled type=checkbox> Is strong type validation unnecessary?</li><li><input checked disabled type=checkbox> No plans to use Schema Registry?</li><li><input checked disabled type=checkbox> No expected major growth in data volume?</li><li><input checked disabled type=checkbox> Need for human-readable debugging?</li></ul><h1 id=advantages-of-avro--protobuf>Advantages of Avro / Protobuf<a hidden class=anchor aria-hidden=true href=#advantages-of-avro--protobuf>#</a></h1><ul><li><strong>Strong Type Validation</strong><ul><li>Serialization fails if fields do not match specified types (e.g., ENUM, float).</li></ul></li><li><strong>High Serialization/Deserialization Performance</strong><ul><li>Binary formats like Avro and Protobuf require no parsing, unlike text-based JSON.</li></ul></li><li><strong>Schema Evolution Support</strong><ul><li>New fields can be ignored by older consumers without issues.</li></ul></li></ul><p><img loading=lazy src=/posts/schema-registry/image-1.png></p><p><strong>Benchmark:</strong> Even for small payloads, JSON lags behind Avro/Protobuf by more than 2x in performance.</p><p><strong>And the performance gap widens as payload size grows.</strong></p><h1 id=impact-of-data-size-on-performance>Impact of Data Size on Performance<a hidden class=anchor aria-hidden=true href=#impact-of-data-size-on-performance>#</a></h1><p>Since JSON is stored as <strong>text</strong> instead of <strong>binary</strong>, it consumes more space:</p><ul><li>Larger Kafka volumes</li><li>Degraded produce/consume performance<ul><li>Larger data costs more during ISR (in-sync replication)</li><li>Larger payloads cause slower fetches during consumption</li></ul></li></ul><h1 id=schema-registry>Schema Registry<a hidden class=anchor aria-hidden=true href=#schema-registry>#</a></h1><p>Summarizing the core benefits of event schemas:</p><ul><li>Consistency</li><li>Performance</li><li>Compatibility</li></ul><p>A <strong>Schema Registry</strong> centrally manages and validates Kafka message schemas, ensuring compatibility between producers and consumers.</p><h2 id=schema-evolution-and-compatibility>Schema Evolution and Compatibility<a hidden class=anchor aria-hidden=true href=#schema-evolution-and-compatibility>#</a></h2><p><strong>Example 2:</strong> Think of moving from v1 API to v2 API.</p><ul><li>Keep backward compatibility initially.</li><li>Gradually migrate clients.</li><li>Eventually deprecate the old API.</li></ul><p>In event streams, updating schemas means notifying <code>Consumers</code> about changes. But which should update first, <code>Producer</code> or <code>Consumer</code>?</p><p>Fortunately, Schema Registry solves this:</p><p><img loading=lazy src=/posts/schema-registry/image-2.png></p><ul><li><code>Producer</code> publishes events using the new v2 schema.</li><li><code>Consumer</code> detects schema changes and fetches the new version dynamically.</li></ul><p>Thus enabling <strong>smooth schema evolution without service disruptions</strong>.</p><h2 id=efficient-event-management>Efficient Event Management<a hidden class=anchor aria-hidden=true href=#efficient-event-management>#</a></h2><p>Is using a Schema Registry mandatory?</p><p>No. <strong>Choosing the right tool depends on your needs.</strong></p><h3 id=schema-awareness-in-kafka-streams>Schema Awareness in Kafka Streams<a hidden class=anchor aria-hidden=true href=#schema-awareness-in-kafka-streams>#</a></h3><p>For Avro/Protobuf (binary formats), schemas are essential because raw binary data isn&rsquo;t self-describing:</p><p><img loading=lazy src=/posts/schema-registry/image-3.png></p><h3 id=event-size-considerations>Event Size Considerations<a hidden class=anchor aria-hidden=true href=#event-size-considerations>#</a></h3><p>While Avro/Protobuf compress data well, embedding full schema info in each event would negate their size advantage:</p><p><img loading=lazy src=/posts/schema-registry/image-4.png></p><p>Using <strong>schema IDs</strong> instead (with Schema Registry) minimizes event size while preserving compatibility.</p><p><strong>Note:</strong></p><ul><li>If both <code>Producer</code> and <code>Consumer</code> share identical <code>.proto</code> files, they can theoretically skip embedding schemas.</li><li>But this approach has downsides:<ul><li>Tight coupling between producer/consumer.</li><li>No dynamic schema updates.</li><li>Requires redeploying both producer and consumer on schema changes.</li></ul></li></ul><h2 id=aws-glue-vs-confluent-schema-registry>AWS Glue vs. Confluent Schema Registry<a hidden class=anchor aria-hidden=true href=#aws-glue-vs-confluent-schema-registry>#</a></h2><table><thead><tr><th>Feature</th><th>AWS Glue Schema Registry</th><th>Confluent Schema Registry</th></tr></thead><tbody><tr><td>Schema Updates</td><td>Adds as new version</td><td>Adds as new version</td></tr><tr><td>URL Stability</td><td>‚úÖ (ARN-based)</td><td>‚úÖ (REST API-based)</td></tr><tr><td>Auto-use of Latest Version</td><td>‚ùå (Needs config)</td><td>‚úÖ (Automatic)</td></tr><tr><td>Kafka Compatibility</td><td>‚úÖ (Works with AWS MSK)</td><td>‚úÖ (Works with Confluent Kafka)</td></tr></tbody></table><h1 id=why-use-schema-registry>Why Use Schema Registry?<a hidden class=anchor aria-hidden=true href=#why-use-schema-registry>#</a></h1><ol><li><strong>Maintains Data Consistency</strong><ul><li>Ensures producer messages match consumer expectations.</li><li>Prevents business logic errors.</li></ul></li><li><strong>Supports Schema Evolution</strong><ul><li>Add/change fields without breaking existing consumers.</li></ul></li><li><strong>Centralized Schema Management</strong><ul><li>No need for manual schema file syncing.</li></ul></li><li><strong>Minimizes Kafka Message Size</strong><ul><li>Sends lightweight schema IDs instead of full schemas.</li></ul></li><li><strong>Provides Schema Validation</strong><ul><li>Catches invalid payloads early.</li></ul></li><li><strong>Enables Real-time Schema Updates</strong><ul><li>Consumers fetch updated schemas dynamically.</li></ul></li><li><strong>Configurable Compatibility Modes</strong><ul><li>Prevents breaking changes.</li></ul></li><li><strong>Versioned Schema History and Easy Rollbacks</strong><ul><li>Retrieve or roll back to any historical schema version.</li></ul></li></ol><h1 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h1><ul><li><a href=https://www.confluent.io/blog/schemas-contracts-compatibility/>Confluent</a></li><li><a href=https://oliveyoung.tech/2023-10-04/oliveyoung-b2b-msk-connect-introduction/>Oliveyoung Tech Blog</a></li><li><a href=https://www.linkedin.com/pulse/exploring-data-serialization-apache-kafka-json-protobuf-joe-z-tb2fc/>Exploring Data Serialization in Apache Kafka</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://dingyu.dev/en/tags/kafka/>Kafka</a></li><li><a href=https://dingyu.dev/en/tags/avro/>Avro</a></li><li><a href=https://dingyu.dev/en/tags/protobuf/>Protobuf</a></li><li><a href=https://dingyu.dev/en/tags/json/>Json</a></li><li><a href=https://dingyu.dev/en/tags/schema-registry/>Schema Registry</a></li></ul><nav class=paginav><a class=prev href=https://dingyu.dev/en/posts/dance-with-burrow/><span class=title>¬´ Prev</span><br><span>[EDA] Kafka (MSK) Monitoring with Burrow Prometheus And Thanos</span>
</a><a class=next href=https://dingyu.dev/en/posts/grpc/><span class=title>Next ¬ª</span><br><span>[Protocol] Exploring RPC... and GRPC in Depth</span></a></nav></footer><div id=giscus_thread><script src=https://giscus.app/client.js data-repo=dings-things/blog data-repo-id=R_kgDON9IuAw data-category=Announcements data-category-id=DIC_kwDON9IuA84CnTai data-mapping=og:title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=ko data-loading=lazy crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://dingyu.dev/en/>Ding's Coding Forge</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>
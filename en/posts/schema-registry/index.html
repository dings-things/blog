<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[EDA] Schema Registry | Ding's Coding Forge</title>
<meta name=keywords content="kafka,avro,protobuf,json,schema registry"><meta name=description content="People often underestimate the importance of documenting schemas before starting to code, especially when working with stream processing. In this post, I’ll explain why using a schema registry is essential and why designing schemas upfront is crucial before diving into coding."><meta name=author content="dingyu"><link rel=canonical href=https://dingyu.dev/en/posts/schema-registry/><meta name=google-site-verification content="8XY1hI6NVxQIrN7bQbnX-9TG9HHFw5HOQmlb6vcsFdQ"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.ba0de23ad40e17ca82720b577f8ae6ec11a26fb07407316cff70888e344ad129.css integrity="sha256-ug3iOtQOF8qCcgtXf4rm7BGib7B0BzFs/3CIjjRK0Sk=" rel="preload stylesheet" as=style><link rel=icon href=https://dingyu.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dingyu.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dingyu.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://dingyu.dev/apple-touch-icon.png><link rel=mask-icon href=https://dingyu.dev/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://dingyu.dev/posts/schema-registry/><link rel=alternate hreflang=en href=https://dingyu.dev/en/posts/schema-registry/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-XH8830R9KK"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XH8830R9KK")}</script><meta property="og:url" content="https://dingyu.dev/en/posts/schema-registry/"><meta property="og:site_name" content="Ding's Coding Forge"><meta property="og:title" content="[EDA] Schema Registry"><meta property="og:description" content="People often underestimate the importance of documenting schemas before starting to code, especially when working with stream processing. In this post, I’ll explain why using a schema registry is essential and why designing schemas upfront is crucial before diving into coding."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-24T00:00:00+00:00"><meta property="article:modified_time" content="2025-02-24T00:00:00+00:00"><meta property="article:tag" content="Kafka"><meta property="article:tag" content="Avro"><meta property="article:tag" content="Protobuf"><meta property="article:tag" content="Json"><meta property="article:tag" content="Schema Registry"><meta property="og:image" content="https://dingyu.dev/en/posts/schema-registry/img/kafka.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dingyu.dev/en/posts/schema-registry/img/kafka.png"><meta name=twitter:title content="[EDA] Schema Registry"><meta name=twitter:description content="People often underestimate the importance of documenting schemas before starting to code, especially when working with stream processing. In this post, I’ll explain why using a schema registry is essential and why designing schemas upfront is crucial before diving into coding."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://dingyu.dev/en/posts/"},{"@type":"ListItem","position":2,"name":"[EDA] Schema Registry","item":"https://dingyu.dev/en/posts/schema-registry/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[EDA] Schema Registry","name":"[EDA] Schema Registry","description":"People often underestimate the importance of documenting schemas before starting to code, especially when working with stream processing. In this post, I’ll explain why using a schema registry is essential and why designing schemas upfront is crucial before diving into coding.","keywords":["kafka","avro","protobuf","json","schema registry"],"articleBody":"Why Schema First? While EDA promotes loose coupling, event schemas inherently form a tight contract between producers and consumers. Let’s explore why this contract matters and how a Schema Registry helps maintain compatibility.\nPurpose of Event Schemas Define structure and format of event data. Enforce data consistency between producers and consumers. Enable validation, compatibility, and documentation. If you’re familiar with REST APIs, this is similar to defining OpenAPI contracts between services:\nEvent streams function the same way—producers emit events conforming to predefined schemas; consumers process them based on those expectations.\nBad Example { \"user_id\": 123, \"user_action\": 1 } // action code instead of expected string Even with agreed-upon schemas, schema drift can occur—leading to broken consumers. Much like skipping ERD when designing databases, skipping event schemas is risky in EDA.\nCommon Schema Formats Format Pros Cons JSON Human-readable, widely supported Large size, lacks strong validation Protobuf Compact, fast, schema-enforced Hard to debug, needs precompiled schema Avro Compact binary, supports schema evolution Less widely adopted, tooling gaps in some ecosystems Text formats like JSON are appealing for debugging. But size and speed matter in stream processing.\nJSON Suitability Checklist Use JSON only if:\n✅ Messages are small. ✅ You can tolerate slow (de)serialization. ✅ Strong type validation isn’t required. ✅ You don’t need a schema registry. ✅ Volume of messages will remain low. ✅ Debugging via raw payload is helpful. Advantages of Avro / Protobuf Strong typing and schema enforcement Fast (de)serialization Built-in backward/forward compatibility Even small messages show over 2x performance gains in binary formats. The difference increases with message size.\nImpact on Kafka Text-based formats like JSON consume more storage and network bandwidth. High volume = performance degradation at produce/consume phases. What Is a Schema Registry? A Schema Registry stores and version-controls data schemas.\nBenefits:\nEnforces compatibility Enables schema evolution (backward/forward) Minimizes payload size by referencing schemas via ID Centralized schema governance Schema Evolution in Action Producer publishes an event with schema v2. Consumer detects version mismatch and fetches v2 from registry. Consumer proceeds with updated schema. No coordination required. Zero downtime schema upgrades!\nSchema Registry vs. Schemaless Format With Schema Registry Without Schema Registry JSON ❌ Schemaless, can’t validate or evolve ✅ Easy to debug, but lacks structure Protobuf ✅ Strong schema + evolution support ❌ Needs .proto file everywhere Avro ✅ Compact, evolvable binary format ❌ Schema must be embedded in each message Using a Schema Registry with schema ID avoids inflating messages with repeated schema data. This helps keep message sizes small.\nCentral Schema vs. Shared Code Registry = Central governance, live updates. Submodule .proto = Tight coupling, manual versioning. AWS Glue vs. Confluent Schema Registry Feature AWS Glue Registry Confluent Schema Registry Schema versioning ✅ Supported ✅ Supported URL persistence ✅ ARN-based ✅ REST endpoint-based Auto upgrade for consumer ❌ Needs explicit fetch ✅ Auto fetch Kafka support ✅ MSK ✅ Confluent Kafka Why Use a Schema Registry? Guarantee Compatibility: Prevent mismatched producer-consumer schemas. Support Evolution: Add/remove fields without breaking clients. Centralized Governance: No more shared .proto headaches. Smaller Messages: Send schema ID, not full schema. Schema Validation: Prevent invalid data from entering the stream. Dynamic Updates: Auto-fetch new schemas at runtime. Compatibility Policies: Enforce forward/backward rules. Schema Auditing: View changes via REST API or UI. References Confluent Blog: Schemas and Compatibility Oliveyoung B2B MSK Case Kafka Serialization Overview ","wordCount":"554","inLanguage":"en","image":"https://dingyu.dev/en/posts/schema-registry/img/kafka.png","datePublished":"2025-02-24T00:00:00Z","dateModified":"2025-02-24T00:00:00Z","author":{"@type":"Person","name":"dingyu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://dingyu.dev/en/posts/schema-registry/"},"publisher":{"@type":"Organization","name":"Ding's Coding Forge","logo":{"@type":"ImageObject","url":"https://dingyu.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dingyu.dev/en/ accesskey=h title="Ding's Coding Forge (Alt + H)"><img src=https://dingyu.dev/apple-touch-icon.png alt aria-label=logo height=35>Ding's Coding Forge</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://dingyu.dev/ title=한국어 aria-label=한국어>Ko</a></li></ul></div></div><ul id=menu><li><a href=https://dingyu.dev/en/about/ title=About><span>About</span></a></li><li><a href=https://dingyu.dev/en/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://dingyu.dev/en/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://dingyu.dev/en/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://dingyu.dev/en/search/ title=🔍><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://dingyu.dev/en/>Home</a>&nbsp;»&nbsp;<a href=https://dingyu.dev/en/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">[EDA] Schema Registry</h1><div class=post-description>People often underestimate the importance of documenting schemas before starting to code, especially when working with stream processing. In this post, I’ll explain why using a schema registry is essential and why designing schemas upfront is crucial before diving into coding.</div><div class=post-meta><span title='2025-02-24 00:00:00 +0000 UTC'>February 24, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;554 words&nbsp;·&nbsp;dingyu&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://dingyu.dev/posts/schema-registry/>Ko</a></li></ul>&nbsp;|&nbsp;<a href=https://github.com/dings-things/blog/tree/main/content/posts/schema-registry/index.en.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://dingyu.dev/img/kafka.png alt></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#why-schema-first aria-label="Why Schema First?">Why Schema First?</a></li><li><a href=#purpose-of-event-schemas aria-label="Purpose of Event Schemas">Purpose of Event Schemas</a><ul><li><a href=#bad-example aria-label="Bad Example">Bad Example</a></li></ul></li><li><a href=#common-schema-formats aria-label="Common Schema Formats">Common Schema Formats</a><ul><li><a href=#json-suitability-checklist aria-label="JSON Suitability Checklist">JSON Suitability Checklist</a></li><li><a href=#advantages-of-avro--protobuf aria-label="Advantages of Avro / Protobuf">Advantages of Avro / Protobuf</a></li><li><a href=#impact-on-kafka aria-label="Impact on Kafka">Impact on Kafka</a></li></ul></li><li><a href=#what-is-a-schema-registry aria-label="What Is a Schema Registry?">What Is a Schema Registry?</a><ul><li><a href=#schema-evolution-in-action aria-label="Schema Evolution in Action">Schema Evolution in Action</a></li></ul></li><li><a href=#schema-registry-vs-schemaless aria-label="Schema Registry vs. Schemaless">Schema Registry vs. Schemaless</a><ul><li><a href=#central-schema-vs-shared-code aria-label="Central Schema vs. Shared Code">Central Schema vs. Shared Code</a></li></ul></li><li><a href=#aws-glue-vs-confluent-schema-registry aria-label="AWS Glue vs. Confluent Schema Registry">AWS Glue vs. Confluent Schema Registry</a></li><li><a href=#why-use-a-schema-registry aria-label="Why Use a Schema Registry?">Why Use a Schema Registry?</a></li><li><a href=#references aria-label=References>References</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=why-schema-first>Why Schema First?<a hidden class=anchor aria-hidden=true href=#why-schema-first>#</a></h2><p>While EDA promotes loose coupling, event schemas inherently form a <strong>tight contract</strong> between <code>producers</code> and <code>consumers</code>. Let’s explore why this contract matters and how a <strong>Schema Registry</strong> helps maintain compatibility.</p><h2 id=purpose-of-event-schemas>Purpose of Event Schemas<a hidden class=anchor aria-hidden=true href=#purpose-of-event-schemas>#</a></h2><ul><li>Define structure and format of event data.</li><li>Enforce data consistency between producers and consumers.</li><li>Enable validation, compatibility, and documentation.</li></ul><p>If you&rsquo;re familiar with REST APIs, this is similar to defining OpenAPI contracts between services:</p><p><img loading=lazy src=img/image.png></p><p>Event streams function the same way—producers emit events conforming to predefined schemas; consumers process them based on those expectations.</p><h3 id=bad-example>Bad Example<a hidden class=anchor aria-hidden=true href=#bad-example>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;user_id&#34;</span><span class=p>:</span> <span class=mi>123</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;user_action&#34;</span><span class=p>:</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=c1>// action code instead of expected string
</span></span></span></code></pre></div><p><img loading=lazy src=img/kafka-event-mismatch.png></p><p>Even with agreed-upon schemas, schema drift can occur—leading to broken consumers. Much like skipping ERD when designing databases, <strong>skipping event schemas is risky</strong> in EDA.</p><h2 id=common-schema-formats>Common Schema Formats<a hidden class=anchor aria-hidden=true href=#common-schema-formats>#</a></h2><table><thead><tr><th>Format</th><th>Pros</th><th>Cons</th></tr></thead><tbody><tr><td><strong>JSON</strong></td><td>Human-readable, widely supported</td><td>Large size, lacks strong validation</td></tr><tr><td><strong>Protobuf</strong></td><td>Compact, fast, schema-enforced</td><td>Hard to debug, needs precompiled schema</td></tr><tr><td><strong>Avro</strong></td><td>Compact binary, supports schema evolution</td><td>Less widely adopted, tooling gaps in some ecosystems</td></tr></tbody></table><p>Text formats like JSON are appealing for debugging. But size and speed matter in stream processing.</p><h3 id=json-suitability-checklist>JSON Suitability Checklist<a hidden class=anchor aria-hidden=true href=#json-suitability-checklist>#</a></h3><p>Use JSON <strong>only if</strong>:</p><ul><li>✅ Messages are small.</li><li>✅ You can tolerate slow (de)serialization.</li><li>✅ Strong type validation isn’t required.</li><li>✅ You don’t need a schema registry.</li><li>✅ Volume of messages will remain low.</li><li>✅ Debugging via raw payload is helpful.</li></ul><h3 id=advantages-of-avro--protobuf>Advantages of Avro / Protobuf<a hidden class=anchor aria-hidden=true href=#advantages-of-avro--protobuf>#</a></h3><ul><li>Strong typing and schema enforcement</li><li>Fast (de)serialization</li><li>Built-in <strong>backward/forward compatibility</strong></li></ul><p><img loading=lazy src=img/image-1.png></p><p>Even small messages show over 2x performance gains in binary formats. The difference increases with message size.</p><h3 id=impact-on-kafka>Impact on Kafka<a hidden class=anchor aria-hidden=true href=#impact-on-kafka>#</a></h3><ul><li>Text-based formats like JSON consume more <strong>storage</strong> and <strong>network bandwidth</strong>.</li><li>High volume = performance degradation at produce/consume phases.</li></ul><h2 id=what-is-a-schema-registry>What Is a Schema Registry?<a hidden class=anchor aria-hidden=true href=#what-is-a-schema-registry>#</a></h2><p>A Schema Registry stores and version-controls data schemas.</p><p>Benefits:</p><ul><li>Enforces compatibility</li><li>Enables schema evolution (backward/forward)</li><li>Minimizes payload size by referencing schemas via ID</li><li>Centralized schema governance</li></ul><h3 id=schema-evolution-in-action>Schema Evolution in Action<a hidden class=anchor aria-hidden=true href=#schema-evolution-in-action>#</a></h3><p><img loading=lazy src=img/image-2.png>
<img loading=lazy src=img/image-5.png></p><ol><li>Producer publishes an event with schema v2.</li><li>Consumer detects version mismatch and fetches v2 from registry.</li><li>Consumer proceeds with updated schema.</li></ol><p>No coordination required. Zero downtime schema upgrades!</p><h2 id=schema-registry-vs-schemaless>Schema Registry vs. Schemaless<a hidden class=anchor aria-hidden=true href=#schema-registry-vs-schemaless>#</a></h2><table><thead><tr><th>Format</th><th>With Schema Registry</th><th>Without Schema Registry</th></tr></thead><tbody><tr><td>JSON</td><td>❌ Schemaless, can&rsquo;t validate or evolve</td><td>✅ Easy to debug, but lacks structure</td></tr><tr><td>Protobuf</td><td>✅ Strong schema + evolution support</td><td>❌ Needs .proto file everywhere</td></tr><tr><td>Avro</td><td>✅ Compact, evolvable binary format</td><td>❌ Schema must be embedded in each message</td></tr></tbody></table><p><img loading=lazy src=img/image-3.png>
<img loading=lazy src=img/image-4.png></p><p>Using a Schema Registry with schema <strong>ID</strong> avoids inflating messages with repeated schema data. This helps keep message sizes small.</p><h3 id=central-schema-vs-shared-code>Central Schema vs. Shared Code<a hidden class=anchor aria-hidden=true href=#central-schema-vs-shared-code>#</a></h3><ul><li>Registry = Central governance, live updates.</li><li>Submodule <code>.proto</code> = Tight coupling, manual versioning.</li></ul><h2 id=aws-glue-vs-confluent-schema-registry>AWS Glue vs. Confluent Schema Registry<a hidden class=anchor aria-hidden=true href=#aws-glue-vs-confluent-schema-registry>#</a></h2><table><thead><tr><th>Feature</th><th>AWS Glue Registry</th><th>Confluent Schema Registry</th></tr></thead><tbody><tr><td>Schema versioning</td><td>✅ Supported</td><td>✅ Supported</td></tr><tr><td>URL persistence</td><td>✅ ARN-based</td><td>✅ REST endpoint-based</td></tr><tr><td>Auto upgrade for consumer</td><td>❌ Needs explicit fetch</td><td>✅ Auto fetch</td></tr><tr><td>Kafka support</td><td>✅ MSK</td><td>✅ Confluent Kafka</td></tr></tbody></table><h2 id=why-use-a-schema-registry>Why Use a Schema Registry?<a hidden class=anchor aria-hidden=true href=#why-use-a-schema-registry>#</a></h2><ol><li><strong>Guarantee Compatibility</strong>: Prevent mismatched producer-consumer schemas.</li><li><strong>Support Evolution</strong>: Add/remove fields without breaking clients.</li><li><strong>Centralized Governance</strong>: No more shared <code>.proto</code> headaches.</li><li><strong>Smaller Messages</strong>: Send schema ID, not full schema.</li><li><strong>Schema Validation</strong>: Prevent invalid data from entering the stream.</li><li><strong>Dynamic Updates</strong>: Auto-fetch new schemas at runtime.</li><li><strong>Compatibility Policies</strong>: Enforce forward/backward rules.</li><li><strong>Schema Auditing</strong>: View changes via REST API or UI.</li></ol><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=https://www.confluent.io/blog/schemas-contracts-compatibility/>Confluent Blog: Schemas and Compatibility</a></li><li><a href=https://oliveyoung.tech/2023-10-04/oliveyoung-b2b-msk-connect-introduction/>Oliveyoung B2B MSK Case</a></li><li><a href=https://www.linkedin.com/pulse/exploring-data-serialization-apache-kafka-json-protobuf-joe-z-tb2fc/>Kafka Serialization Overview</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://dingyu.dev/en/tags/kafka/>Kafka</a></li><li><a href=https://dingyu.dev/en/tags/avro/>Avro</a></li><li><a href=https://dingyu.dev/en/tags/protobuf/>Protobuf</a></li><li><a href=https://dingyu.dev/en/tags/json/>Json</a></li><li><a href=https://dingyu.dev/en/tags/schema-registry/>Schema Registry</a></li></ul><nav class=paginav><a class=prev href=https://dingyu.dev/en/posts/dance-with-burrow/><span class=title>« Prev</span><br><span>[EDA] Kafka (MSK) Monitoring with Burrow Prometheus And Thanos</span>
</a><a class=next href=https://dingyu.dev/en/posts/grpc/><span class=title>Next »</span><br><span>[Protocol] Exploring RPC... and GRPC in Depth</span></a></nav></footer><div id=giscus_thread><script src=https://giscus.app/client.js data-repo=dings-things/blog data-repo-id=R_kgDON9IuAw data-category=Announcements data-category-id=DIC_kwDON9IuA84CnTai data-mapping=og:title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=ko data-loading=lazy crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://dingyu.dev/en/>Ding's Coding Forge</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>
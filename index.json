[{"content":"배경 서비스 별로 다른 프로젝트 구조 프로젝트 마다 코드 파악이 힘듦 e.g.\nSomeAPI ├── .vscode ├── api ├── build ├── config ├── data ├── db ├── externalservice ├── httpsrv ├── httptest ├── mocks ├── log ├── cli ├── repository ├── util ├── .gitignore ├── .gitlab-ci.yml ├── changelog ├── data.go ├── diag_debug.go ├── diag.go ├── go.mod ├── go.sum ├── main.go ├── Makefile ├── release.conf ├── README.md 공통 컨벤션이 없어 공통 모듈/CI를 사용하기 힘듦 모든 프로젝트에서 사용될 수 있도록 고려할 사항이 많아짐 → 개발 생산성 ↓ 온보딩 과정이 힘듦 신규 합류된 팀원이 Go언어에도 익숙치 않은 상태에서 너무 제각각인 스타일으로 인해 혼란이 옴 팀이 Go 언어 생태계로 전환을 완료했고, 이제는 노하우가 생겼다 생각함 장기적인 운영에서 컨벤션 사용으로 유지보수성 ↑ 신규 프로젝트에서 새로운 프로젝트 구조에 대한 고민을 하는 일, 기존 프로젝트에서 리팩토링의 방향성을 잡기 힘듦 개발 생산성 ↓ 프로젝트 구조 제안 적용이 Must인 부분은 * prefix를 가집니다 (그 외, Optional)\n엔터프라이즈 레벨의 프로젝트가 아닌 MSA를 기준으로 작성됩니다 추후 리팩토링을 하더라도 도메인 단위의 MSA로 물리적인 격리가 진행되기 때문\u0026hellip;\n프로젝트 구조 샘플 도메인을 \u0026ldquo;매치 샘플링\u0026quot;이라 하였을 때\n. ├── *docs // 프로젝트 별 문서들 │ ├── *swagger.yaml // API 스웨거 문서 │ ├── sequence.md // 비즈니스 시퀀스 다이어그램 │ └── architecture.md // 시스템 아키텍처 다이어그램 ├── *cmd │ └── *main.go // 프로젝트 진입점, DI 주입 ├── pkg // 비즈니스 로직에 종속적이지 않은 패키지 (외부에서 import 하여도 상관없는 모듈) │ ├── file_parser.go │ └── time_convertor.go └── *internal // 외부에 공개되면 안되는 비즈니스 로직 영역 (도메인 영역) ├── *handler │ ├── *v1 │ │ └── sampling_handler.go // 도메인 핸들러 v1 │ ├── v2 │ │ └── sampling_handler.go // 도메인 핸들러 v2 │ ├── server.go // handler가 많을 경우, handler를 등록할 server를 둡니다 │ ├── health_handler.go // v1, v2 공통 핸들러 │ ├── swagger_handler.go // 프로젝트 테스트 용 openapi 핸들러 (CORS 허용) │ └── auth_middleware.go // 미들웨어들 ├── data │ ├── mysqldb.go // DB client 커넥터 │ ├── redis.go // DB client 커넥터 │ ├── feature_event_producer.go // Kafka event producer - xxx_producer │ ├── match_repository.go // ORM 수행 repository (DB client 주입) - xxx_repository │ └── nass_api.go // 외부 API Data Layer - xxx_api ├── *service │ ├── kda_sampler.go // Data layer 혹은 다른 service를 주입 받아 구현 │ ├── match_sampling_usecase.go // service 가 많을 경우, 오케스트레이션 해주는 유즈케이스 구현 │ └── kda_sampler_test.go // 비즈니스 로직의 유닛테스트 ├── logger.go // 애플리케이션 전역에서 사용될 기능 ├── constants.go // 외부에서 참조 되어야 하는 상수 값 정의 └── *config.go // application 설정 파일 ├── *gitlab-ci.yml ├── *go.mod ├── *go.sum └── *README.md // 프로젝트에 대한 배경, 유즈케이스, 설치 방법 기술 구분 필수 여부 설명 예시 docs ✔ 프로젝트 아키텍처, 시퀀스 다이어그램, 스웨거 문서를 관리 - swagger.yaml- sequence.md cmd ✔ 프로젝트 진입점, 실행 가능한 파일 및 스크립트 관리 - main.go- start.sh pkg 애플리케이션에 종속적이지 않은 유틸리티 기능 관리 - time_convertor.go- file_parser.go internal ✔ 외부에 공개되면 안되는 비즈니스 로직(도메인) 영역애플리케이션 전역에서 사용될 기능 담당 - config.go- logger.go- constants.go internal/handler ✔ API라면 API Handler일 것이고 Consumer라면 Consumer Handler 담당- 버저닝은 *필수, HTTP/gRPC/MQ/Kafka 와의 통신을 담당- 미들웨어는 Optional- handler가 여러개일 경우, server 에서 handler를 등록할 수 있도록 합니다 - blacklist_handler.go- alive_handler.go- log_middleware.go- server.go internal/data 3 Tier Architecture 중, Data Layer 영역영속성을 가진 데이터 CRUD 담당(외부 API 또한 해당됨, Kafka 또한 stream에 저장하는 행위로 간주) - event_producer.go- blacklist_repository.go- member_api.go internal/service ✔ 비즈니스 로직을 수행하는 비즈니스 영역- 각각의 서비스는 단일 책임 원칙에 따라 하나의 책임만 수행- 서비스가 다수일 경우, 이를 오케스트레이션 해주는 xxx_usecase로 구현- 서비스 코드의 단위 테스트는 필수 (일부 의존성에 따른 테스트 불가 시 패스) - fraud_detect_usecase.go- fraud_retriever.go- rule_analyzer.go ./ (root) ✔ 프로젝트 실행 및 운영을 위한 파일 영역- 리드미는 필수로 작성 (유즈케이스와 설치 방법은 항상 기술) - gitlab-ci.yml- README.md 상수 컨벤션 기본적으로 카멜케이스와 파스칼케이스를 원칙으로 사용합니다\n→ 하나의 도메인 파일에서 도메인과 관련된 상수가 다른 패키지에 속해 있는 경우, 수정에도 어렵고 추적에도 귀찮음이 동반 됨을 느꼈습니다\n→ 하나의 책임을 지는 파일 내에서 private 상수로서 관리 된다면 유지보수에도 용이할 것이고 코드 파악에도 용이할 것이라 생각합니다\n복수 패키지에서 다수 의존될 여지가 있는 경우 (Pascal) internal layer의 constants.go 파일에 상수 값들을 정의 합니다\npackage internal const ( LanguageCodeKorean = \u0026#34;ko\u0026#34; LanguageCodeEnglish = \u0026#34;en\u0026#34; LanguageCodeChinese = \u0026#34;zh_CN\u0026#34; LanguageCodeJapanese = \u0026#34;ja\u0026#34; ) 하나의 패키지 내 혹은 하나의 파일에서 사용할 경우 (Camel) 동일 패키지 내에서는 private 변수에 참조할 수 있습니다\npackage handler const ( // resultSuccess : 성공 응답 resultSuccess = \u0026#34;true\u0026#34; // resultFailure : 실패 응답 resultFailure = \u0026#34;false\u0026#34; ) 불가피하게 다른 패키지로부터 참조되어야 하는 경우 상수는 private으로, struct의 Public 함수로 참조 될 수 있게 합니다\npackage handler const ( // samplerEndpoint : 매치 샘플링 엔드포인드 samplerEndpoint = \u0026#34;/v1/:match_id\u0026#34; ) // Endpoint : 핸들러의 엔드포인트를 반환 func (h *SamplerHandler) Endpoint() string { return samplerEndpoint } 데이터 모델 컨벤션 데이터 모델은 가급적 별도 파일이 아닌, 수행되는 파일에서 정의하여 사용합니다\n→ model을 별도로 지정해 둘 경우, 특정 도메인에 대한 수정이 있을 때 참조된 여러 파일을 수정해야 하는 불편함이 존재합니다\n→ 같은 계층 간의 데이터 이동에 대해서는 파라미터로 주고 받고 다른 레이어 간 통신은 *레이어 간 데이터 모델 컨벤션에 따라 데이터 모델을 주고 받습니다\n→ parameter가 두 개 이상일 경우, 데이터 모델로 만들어 관리합니다\n레이어 간 데이터 모델 컨벤션 handler → service\nrequest → serviceDTO\nfunc (h *Handler) CreateMatch(c *gin.Context) { var req matchRequest if err := c.ShouldBindJSON(\u0026amp;req); err != nil { c.JSON(http.StatusBadRequest, gin.H{\u0026#34;error\u0026#34;: err.Error()}) return } // Service 호출 err := h.service.Create(req.ToServiceDTO()) // so on } service → data\nserviceDTO → entity\nfunc (b *MatchCreater) Create(match MatchDTO) (int, error) { ... // repository 계층에 MatchEntity 삽입 요청 id, err := b.repository.Insert(match.ToEntity()) if err != nil { return 0, err } return id, nil } data → service\nentity → serviceDTO\nfunc (r *MatchRepository) Insert(entity MatchEntity) (int, error) { // 데이터 레이어에서 UserEntity 가져오기 result, err := s.db.Create(\u0026amp;entity) ... return result.ID, nil } 데이터 모델에서의 조건 검사 모델을 주고 받는 경우, 가독성을 위해 조건 검사는 함수로 실시 합니다\n단위 테스트에 용이 하며, 한눈에 비즈니스 로직을 파악하기 쉬워 집니다\n[AS-IS]\nfunc (b *MatchCreater) Create(match MatchDTO) (int, error) { if strings.HasPrefix(match.Version, \u0026#34;rc\u0026#34;) \u0026amp;\u0026amp; match.detail == \u0026#34;test\u0026#34; { return } // 비즈니스 로직 } [TO-BE]\nfunc (b *MatchCreater) Create(match MatchDTO) (int, error) { if match.IsTest() { return } // 비즈니스 로직 } 테스트 컨벤션 비즈니스 로직의 테스트는 선택사항이 아닌 필수입니다. 이미 정의된 에러에 대한 테스트케이스는 최대한 상세하고 간결하게 작성합니다.\nDeterministic 비동기 단위 테스트 비동기로 처리하고 결과 값을 확인하지 않거나 time sleep 이후의 로깅을 멈추세요\nDI + Eventually를 통한 flaky test를 방지합니다\n로거 주입 // NewQueue 비즈니스 로직을 수행할 Queue 생성자 func NewQueue( config Config, httpClient *http.Client, logger *zerolog.Logger, ) (queue Queue, err error) { // queue는 Start()를 통해 thread executor가 실행될때에 생성됩니다. queue = Queue{ config: config, client: httpClient, logger: logger, quitChan: make(chan struct{}), } return } 응답 값 테스트 큐 로직 실패 테스트 t.Run(\u0026#34;큐 처리 실패시, 실패 로깅 테스트\u0026#34;, func(t *testing.T) { // given var buffer bytes.Buffer ... 로거 의존성 주입 // when ... 비동기 작업 수행 event1, err := queue.Push([]byte(validJSON1)) assert.NoError(t, err) event2, err := queue.Push([]byte(validJSON2)) assert.NoError(t, err) // then assert.Eventually(t, func() bool { output := buffer.String() return strings.Contains(output, event1.TraceID().String()) \u0026amp;\u0026amp; strings.Contains(output, event2.TraceID().String()) \u0026amp;\u0026amp; strings.Contains(output, `\u0026#34;success\u0026#34;:false`) }, 1*time.Second, 10*time.Millisecond) }) 큐 로직 성공 테스트 t.Run(\u0026#34;큐 처리 성공시, 성공 로깅 테스트\u0026#34;, func(t *testing.T) { // given var buffer bytes.Buffer ... 로거 의존성 주입 // when ... 비동기 작업 수행 event1, err := queue.Push([]byte(validJSON1)) assert.NoError(t, err) event2, err := queue.Push([]byte(validJSON2)) assert.NoError(t, err) // then assert.Eventually(t, func() bool { output := buffer.String() return strings.Contains(output, event1.TraceID().String()) \u0026amp;\u0026amp; strings.Contains(output, event2.TraceID().String()) \u0026amp;\u0026amp; strings.Contains(output, `\u0026#34;success\u0026#34;:true`) }, 1*time.Second, 10*time.Millisecond) }) ","permalink":"https://dings-things.github.io/blog/posts/go-convention/","summary":"효율적인 Go Project Structure Guide","title":"[Go] Go Convention"},{"content":"class Me: def __init__(self): self.name = \u0026#34;Jung Woo Lee\u0026#34; self.born_year = 1996 self.MBTI = \u0026#34;ENTP\u0026#34; self.location = \u0026#34;Seoul, Korea\u0026#34; self.school = \u0026#34;Tsinghua University\u0026#34; self.interests = [\u0026#34;BE\u0026#34;, \u0026#34;DevOps\u0026#34;, \u0026#34;MLOps\u0026#34;, \u0026#34;Go\u0026#34;, \u0026#34;Kafka\u0026#34;, \u0026#34;TDD\u0026#34;, \u0026#34;Automation\u0026#34;] ","permalink":"https://dings-things.github.io/blog/about/","summary":"\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eMe\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"fm\"\u003e__init__\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ename\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Jung Woo Lee\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eborn_year\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1996\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eMBTI\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;ENTP\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003elocation\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Seoul, Korea\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eschool\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Tsinghua University\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"bp\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003einterests\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;BE\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;DevOps\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;MLOps\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Go\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Kafka\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;TDD\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Automation\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"About"},{"content":"FastAPI Convention에 관하여 FastAPI란? FastAPI의 장점 의존성 주입 자동 문서화 비동기 동작 Pydantic Model 클라우드 서비스가 들어오면서 자연스럽게 MSA 라는 아키텍처 구조가 각광 받았고, 그로 인해 서버의 생태계에 변동이 일어나고 있다. 이제는 Serverless (무상태성)을 띈 Restful API 를 통하여 가벼운 통신 방식을 사용하는 아키텍처가 대세를 이루게 되었는데 이렇게 작게 나뉘어진 서비스에 특화된 것이 FastAPI 이다.\n의존성 (A는 반드시 B가 실행되어야 되는 흐름? A \u0026amp; B 는 의존관계 ) 주입에 핵심적인 Depends 함수로 인하여 인증/ DB 연결 등에서 결합도를 낮추어 유연성을 확보할 수 있게 된다 자동 문서화 문서화는 개발자에게 있어 하기 싫은 방학 숙제와 같다. 다른 프레임워크들과 달리 dependency 를 추가 하지 않아도 리독과 openAPI 자동으로 생성된다. 개발자에게 생산성 증대의 이점을 가져온다. 비동기 동작 Node 처럼 비동기가 기본이 아닌 파이썬은 동기로 동작하지만 GIL(Global Interpreter Lock)으로 인해 쓰레드의 사용도 권장되지 않았기 때문에 동시성 처리를 위한 모듈이 없는 경우가 많다. 하지만 중요한것은 FastAPI 는 이를 지원한다는 점 Pydantic FastAPI 는 Pydantic 을 매우 사랑한다. 간단하게 직렬화, 타입검사 경로 변수 읽기 등등 장점이 수두룩 한데 이는 나중에 더 자세히 다루겠다. 특징 가장 큰 것이 사실상의 표준(de facto standard) 가 없다는 것이다. 여타 프레임워크들과 다르게 역사도 길지 않고 FastAPI의 모토가 자유롭고 경량의 프레임워크를 지향하기에 어쩔수 없게도 코딩 스탠다드가 존재하지 않는다. 좋게 말하면 자유도 높인 프레임워크이지만 어떻게 보면 근본이 없다 보일 수 있을 것이다.\n목적 기존 클래스화 되지 않고 정해진 구조없이 짜여진 코드로 인하여 협업하는 데에 있어 각자의 코딩 색이 너무 진하여 같은 팀이지만 구조화 되지 않은 프로젝트라고 느껴졌다.\n이에 우리만의 Convention을 지정하여 직관적이고 유지보수에 용이한 구조를 만드는 것을 목표로 한다.\nClass Based Convention 현재 문제점 Utility에 의존한 잡다한 Feature methods 너무 많은 책임을 짊어진 클래스 (낮은 응집도) 직관적이지 않은 구조 하나의 비즈니스 레이어가 분산되어 있어 코드 가독성이 떨어짐 Dataclass, Pydantic Model 등 모델에 사용되는 Convention이 지정되어 있지 않음 요구 사항 프로젝트 구조는 일관적, 직관적 클래스는 단 한개의 책임을 가진다 비즈니스 레이어 별로 패키지를 구성한다 요구 사항에 따른 Convention 1. 프로젝트 구조는 일관적, 직관적 [FastAPI에서 제시하는 project structure]\n. ├── app # \u0026#34;app\u0026#34; is a Python package │ ├── __init__.py # this file makes \u0026#34;app\u0026#34; a │ ├── main.py # \u0026#34;main\u0026#34; module, e.g. import app.main │ ├── dependencies.py # \u0026#34;dependencies\u0026#34; module │ └── routers # \u0026#34;routers\u0026#34; is a \u0026#34;Python subpackage\u0026#34; │ │ ├── __init__.py # makes \u0026#34;routers\u0026#34; a \u0026#34;Python subpackage\u0026#34; │ │ ├── items.py # \u0026#34;items\u0026#34; submodule │ │ └── users.py # \u0026#34;users\u0026#34; submodule │ └── internal # \u0026#34;internal\u0026#34; is a \u0026#34;Python subpackage\u0026#34; │ ├── __init__.py # makes \u0026#34;internal\u0026#34; a \u0026#34;Python subpackage\u0026#34; │ └── admin.py # \u0026#34;admin\u0026#34; submodule [제안 하고자 하는 project structure]\nfastapi-project ├── app │ ├── worker (비즈니스 레이어) │ │ ├── enums.py # enums │ │ ├── models.py # pydantic models │ │ ├── dependencies.py │ │ ├── constants.py │ │ ├── exceptions.py │ │ └── utils.py │ ├── configs │ │ ├── config.py # global config (including .env) │ │ └── log_config.py │ ├── models.py # global models │ ├── utils.py # global utils │ ├── exceptions.py # global exceptions │ ├── database.py # db connection related stuff │ └── main.py ├── aws │ ├── client.py # client model for external service │ ├── models.p │ ├── constants.py │ ├── exceptions.py │ └── utils.py ├── tests/ │ ├── domain │ └── aws ├── templates/ │ └── index.html ├── requirements │ ├── dev.txt │ ├── stg.txt │ └── prod.txt ├── .env └── .gitignore 모든 도메인 디렉토리의 root는 app이다\nmain.py에서는 그대로 FastAPI app을 초기화하고 프로젝트의 root 역할을 한다 (보편적으로 src/ 느낌) controller : 각 모듈의 엔드포인트를 가진다 enums : Enum 모델들 models : pydantic 모델들 entities : 엔티티 모델들 service : 모듈 별 비즈니스 로직 담당 dependencies : 유효성 검사 constant : 모듈 내에서 사용되는 상수값 config : 모듈 내의 설정사항 exceptions: 커스텀 예외들! 같은 관심을 갖는 메서드가 두개 이상일 경우 따로 패키지로 분류한다\n외부 패키지의 경우 app에 종속적이지 않기 때문에 app 외부에서 관리한다.\n2. 클래스는 단 한개의 책임을 가진다 저자는 응집도를 잘못 이해하고 있었다. 여러개의 연관된 관심을 가진 메서드들을 묶어 하나의 클래스로 만들고 이게 높은 응집도지 ㅋㅋ 하는 어리석음을 반복하고 있었다.\n객체지향 설계원칙인 SOLID중 이는 SRP (Single Responsibility) 단일 책임 원칙에 해당된다.\n흔히 말하는 GOD 클래스들은 다음과 같다. XXXService, XXXClient, XXXHandler, XXXWorker\n필자 또한 그러하였고 서비스안에 조금이라도 관심이 같다고 판단하면 무수히 많은 피쳐들을 남발하여 추가하였다. 이는 코드 가독성과 유지보수의 이점을 버리는 지름길이라 생각한다.\n가령 아래와 같은 피쳐를 만들어야 한다.\nex. 회원 로그를 txt 파일로 작성하는 피쳐를 만드시오\n[Service]\nclass UserService: def write_log_file(self, user_id:str) -\u0026gt; None [단일책임]\nclass UserLogWriter: def __init__(self, user:User) self.user = user def write(self) -\u0026gt; None 하나의 예시에 불과하지만 서비스들로 구성한 피쳐들이 쌓이면 가독성적이나 특히 유닛테스트에서 큰 골치를 겪을 것이다.\n또한 분산된 메서드들을 조합하는 방식에서 최대한 Pythonic하고 OOP를 따르기 위해 FastAPI의 라우터 또한 손을 보게 되었다.\n굳이 싶긴 하겠지만 시간이 된다면 클래스화하여 컨테이너로 관리하고 싶었고 상속을 통해 보일러플레이트 코드를 최소화하고자 모두 클래스로!! 바꾸게 되었다\nex. [BaseController] [HelloController] 3. 비즈니스 레이어 별로 패키지를 구성한다 간단히 말하자면 User를 도메인으로 가지면서 이에 대한 간단한 CRUD를 가진 애플리케이션을 구성한다고 하였을 경우. 아래와 같이 구성할 수 있다.\nfastapi-project ├── app │ ├── user_manager (비즈니스 레이어) │ │ ├── user_getter.py │ │ ├── user_updater.py │ │ ├── user_creator.py │ │ ├── enums.py # enums │ │ ├── models.py # pydantic models │ │ ├── entities.py # pydantic models │ │ ├── user_database.py │ │ ├── dependencies.py │ │ ├── constants.py │ │ ├── exceptions.py │ │ └── utils.py 가령 DB로 부터 User 엔티티를 얻고자 한다면 UserGetter.get() 과 같이 직관적이게 해당 메서드가 무엇을 리턴하는지 유추할 수 있다.\nFacade Pattern을 적용하여 이들을 조합하는 하나의 Manager 레벨이 증가한다고 하더라도 이는 동일하게 적용 될 수 있다.\nmodels의 클래스 이름이 같을 수 있지 않소? 네, 물론입니다. 특히나 엔티티와 DTO의 네이밍은 겹칠 수 밖에 없죠 그렇기에 naming space를 사용하여 구분 합니다 ex.\nimport app.user_manager.entities as entity import app.user_manager.models as dto user_dto = dto.User user_entity = entity.User 구현보다 중요한 것이 설계이다. 구현 레벨의 설계도 중요하며 이러한 명확한 Convention이 있어야 통일된 Class Diagram과 Sequence Diagram, Module Diagram을 적립 할 수 있을 것이다\n해당 컨벤션이 정답이라고 결코 말할 수 없다. 그냥 이러한 컨벤션을 사용할 수도 있겠구나~ 라고 생각하면 좋을 것 같다\n","permalink":"https://dings-things.github.io/blog/posts/fastapi-convention/","summary":"클래스 기반의 FastAPI Structure Guide","title":"[Python] FastAPI Convention"}]
<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[DB] Redis Transaction | Ding's Coding Forge</title>
<meta name=keywords content="redis,transaction,txpipeline"><meta name=description content="Unlike RDBMS, Redis doesn’t have a traditional transaction mechanism. It primarily operates as a single-threaded cache, but transactions can still be made atomic using TX pipelines or Lua scripts. This post focuses on comparing the pros and cons of Lua scripts vs. TX pipelines."><meta name=author content="dingyu"><link rel=canonical href=https://dingyu.dev/ko/posts/redis-transaction/><meta name=google-site-verification content="8XY1hI6NVxQIrN7bQbnX-9TG9HHFw5HOQmlb6vcsFdQ"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.678f9035c217c5346e0b3de5bdc9ebac02c53b0502219858f8653d8d181c97b3.css integrity="sha256-Z4+QNcIXxTRuCz3lvcnrrALFOwUCIZhY+GU9jRgcl7M=" rel="preload stylesheet" as=style><link rel=icon href=https://dingyu.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dingyu.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dingyu.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://dingyu.dev/apple-touch-icon.png><link rel=mask-icon href=https://dingyu.dev/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://dingyu.dev/ko/posts/redis-transaction/><link rel=alternate hreflang=en href=https://dingyu.dev/posts/redis-transaction/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-XH8830R9KK"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XH8830R9KK")}</script><meta property="og:url" content="https://dingyu.dev/ko/posts/redis-transaction/"><meta property="og:site_name" content="Ding's Coding Forge"><meta property="og:title" content="[DB] Redis Transaction"><meta property="og:description" content="Unlike RDBMS, Redis doesn’t have a traditional transaction mechanism. It primarily operates as a single-threaded cache, but transactions can still be made atomic using TX pipelines or Lua scripts. This post focuses on comparing the pros and cons of Lua scripts vs. TX pipelines."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-31T00:00:00+00:00"><meta property="article:modified_time" content="2024-01-31T00:00:00+00:00"><meta property="article:tag" content="Redis"><meta property="article:tag" content="Transaction"><meta property="article:tag" content="Txpipeline"><meta property="og:image" content="https://dingyu.dev/ko/posts/redis-transaction/img/redis.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dingyu.dev/ko/posts/redis-transaction/img/redis.png"><meta name=twitter:title content="[DB] Redis Transaction"><meta name=twitter:description content="Unlike RDBMS, Redis doesn’t have a traditional transaction mechanism. It primarily operates as a single-threaded cache, but transactions can still be made atomic using TX pipelines or Lua scripts. This post focuses on comparing the pros and cons of Lua scripts vs. TX pipelines."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://dingyu.dev/ko/posts/"},{"@type":"ListItem","position":2,"name":"[DB] Redis Transaction","item":"https://dingyu.dev/ko/posts/redis-transaction/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[DB] Redis Transaction","name":"[DB] Redis Transaction","description":"Unlike RDBMS, Redis doesn’t have a traditional transaction mechanism. It primarily operates as a single-threaded cache, but transactions can still be made atomic using TX pipelines or Lua scripts. This post focuses on comparing the pros and cons of Lua scripts vs. TX pipelines.","keywords":["redis","transaction","txpipeline"],"articleBody":"목적 일반적인 Transaction이 필요한 RDB의 경우, 자체적으로 격리 수준을 설정하거나 Rollback과 Commit을 통해 트랜잭션을 구현한다.\n하지만 Redis는 어떠한가? Redis에서 데이터의 일관성과 원자성을 보장받기 위해 주어진 옵션은 그렇게 명확하지 않다.\n하나의 Transaction을 격리 시켜야 하며, All or Nothing 원자성을 Redis에서 지켜야 할 때에 도움이 되고자 기록합니다.\n선택지 Redis TxPipeline Lua Script Redis TxPipeline Redis에서 여러 Command를 일괄적으로 처리하기 위해 떠올리게 되는 것은 Pipeline일 것이다\nPipeline은 연결된 Redis Client로 여러 개의 커맨드를 한번에 보내고 여러개의 응답을 한번에 받는 것을 가능하도록 한다\n다만 일반적인 파이프라인이 트랜잭션이 보장된다고 할 수 없다. 즉, 파이프라인 실행 도중 해당 데이터에 대하여 다른 커맨드로 인해 변경될 수 있으며 데이터의 일관성에 문제가 발생할 수 있다\nEdge Case 네트워크 지연: Redis Pipeline을 사용하면 여러 개의 커맨드를 한 번에 보내고, 한 번에 여러 개의 응답을 받는 것이 가능합니다. 그러나 네트워크 지연으로 인해 커맨드가 서버에 도착하는 순서와 응답이 도착하는 순서가 일치하지 않을 수 있습니다. 따라서 응답이 먼저 도착하는 경우에도, 실제로는 나중에 실행한 커맨드의 결과일 수 있습니다. 다중 스레드 환경: Redis 서버는 다중 스레드로 동작하며, 여러 클라이언트가 동시에 요청을 보낼 수 있습니다. 따라서 여러 클라이언트가 동시에 Pipeline을 사용할 경우, 커맨드의 실행 순서가 보장되지 않을 수 있습니다. Redis 서버 설정: Redis 서버의 설정에 따라 일관성이 달라질 수 있습니다. 예를 들어, Redis 서버가 “slaveof” 설정을 사용하여 데이터를 레플리케이션하는 경우, 일관성이 보장되지 않을 수 있습니다. 이를 해결하는 것이 TxPipeline이다\nPros 트랜잭션 보장: TxPipeline을 사용하면 일괄 처리된 커맨드는 하나의 트랜잭션으로 간주되어, 실행 중 다른 커맨드가 중간에 끼어들지 않습니다. 이로써 데이터의 일관성을 보장합니다. 성능 향상: 여러 개의 커맨드를 한 번에 보내므로 네트워크 오버헤드를 줄일 수 있어 성능이 향상될 수 있습니다. 원자성 보장: TxPipeline 내에서 실행되는 모든 커맨드는 성공하거나 실패되며, 롤백은 지원하지 않습니다. Cons 메모리 사용: 모든 커맨드와 결과가 메모리에 저장되므로, 큰 트랜잭션을 처리할 때 메모리 사용량이 증가할 수 있습니다. 복잡성: TxPipeline은 다른 파이프라인과 혼합해서 사용할 때 주의가 필요하며, 트랜잭션의 범위를 신중하게 관리해야 합니다. 테스트 WATCH를 통해 특정 키의 변경을 감시하고, 이를 통해 트랜잭션의 일관성을 보장할 수 있습니다. 만약 WATCH 중에 감시된 키가 다른 클라이언트에 의해 변경되면, 해당 트랜잭션은 실패\nex. TxPipeline 도중 에러 발생 시나리오\nMULTI SET key1 value1 SET key2 value2 SET key3 value3 EXEC 시나리오 : SET key2 value2 커맨드가 실패\nCASE 1 : 메모리 부족 \"OOM command not allowed when used memory \u003e 'maxmemory'\" CASE 2 : 잘못된 데이터 형식 \"WRONGTYPE Operation against a key holding the wrong kind of value\" 일반적으로 일어날 수 있는 경우가 드무며, 가장 예상 가능한 시나리오는 Redis Client Connection이 끊어진 케이스가 될것이다. 만약 Client Connection이 끊어진 경우, 실패한 키에 대하여 롤백을 수동으로 진행한다 하여도 롤백 자체가 수행되지 않기 때문에 완벽한 해답은 되지 않는다\n즉, TxPipeline은 일관성은 보장 되지만 완벽한 원자성은 보장되지 않는다\nLua Script Lua 스크립트 내에서 여러 Redis 커맨드를 실행하고, 이를 원자적으로 실행할 수 있다\nEdge Case 스크립트 전송 중 네트워크 지연이나 중단: 클라이언트가 Lua 스크립트를 Redis 서버로 전송하는 과정에서 네트워크 지연이나 중단이 발생하면, 스크립트는 서버에 제대로 도달하지 못하고 실행되지 않을 수 있습니다. 실행 결과 수신 중 네트워크 문제: 스크립트가 성공적으로 실행된 후, 그 결과를 클라이언트가 수신하는 과정에서 네트워크 지연이나 중단이 발생할 수 있습니다. 이 경우, 스크립트는 Redis 서버에서 정상적으로 실행되었지만, 클라이언트는 실행 결과를 받지 못할 수 있습니다. Pros: 경량 및 빠른 실행: Lua는 경량 스크립팅 언어로, 실행 시스템 자원을 적게 소모하며 빠르게 실행됩니다. 이러한 특징은 임베디드 시스템이나 게임 엔진 등 리소스가 제한된 환경에서 유용합니다. 내장 스크립트 언어: Lua는 많은 애플리케이션과 게임 엔진에서 내장 스크립트 언어로 사용됩니다. 이는 애플리케이션의 확장성을 높이고 사용자 정의 스크립트를 통해 기능을 확장하기에 용이합니다. 흔히 이전에 Statement로 관리 되던 DB 명령 방식 ORM이 등장한 배경을 생각해보았을 때, 커맨드(query)를 코드로 관리할 수 없기 때문에 Lua를 사용함에 회의적인 개인적 생각 가독성과 간결성: Lua는 간결하고 가독성이 높은 문법을 가지고 있어 쉽게 이해하고 작성할 수 있습니다. lua Script를 위해 문법을 수정해야 하기 때문에 러닝 커브가 동반될 수 있음 Cons: 작은 생태계: 다른 언어에 비해 Lua의 생태계는 상대적으로 작습니다. 따라서 다양한 라이브러리 및 모듈을 찾기 어려울 수 있습니다. 제한된 자료형: Lua는 몇 가지 기본 자료형만을 지원하며, 정수와 부동 소수점 수의 구분이 없어서 정확한 숫자 처리가 어려울 수 있습니다. 엄격한 문법: Lua는 문법 검사가 엄격하며, 초보자에게는 초기 학습 곡선이 높을 수 있습니다. 쓰레드 처리 어려움: Lua는 기본적으로 싱글 스레드 환경에서 동작하며, 멀티 스레드 처리가 어려울 수 있습니다. 테스트 결국 Lua 또한 트랜잭션에 대한 롤백은 지원하지 않습니다.\n기본적으로 삽입 요청 시, Validation을 체크하는 것을 고려할 때에 일어날 수 있는 최악의 시나리오는 네트워크의 단절이며 해당 방법은 어떠한 방법으로도 복구 될 수 없습니다.\nRedis Pipeline에 저장된 커맨드가 원자적으로 한번에 실행 될 수 없기 때문입니다\n테스트 시나리오\nkey1 ~ key5 까지 세팅하는 도중 에러 발생 시, 롤백 테스트\n실행 코드 (go)\npackage main import ( \"context\" \"fmt\" \"github.com/go-redis/redis/v8\" ) var ctx = context.Background() func main() { rdb := redis.NewClient(\u0026redis.Options{ Addr: \"localhost:6379\", // Redis 서버 주소 }) luaScript := ` for i = 1, #KEYS do if KEYS[i] == 'key3' then error('key3 설정 시 에러 발생') else redis.call('SET', KEYS[i], ARGV[i]) end end ` keys := []string{\"key1\", \"key2\", \"key3\", \"key4\", \"key5\"} values := []interface{}{\"value1\", \"value2\", \"value3\", \"value4\", \"value5\"} err := rdb.Eval(ctx, luaScript, keys, values...).Err() if err != nil { fmt.Printf(\"Lua 스크립트 실행 중 오류 발생: %v\\n\", err) return } fmt.Println(\"Lua 스크립트 실행 완료\") } [결과] 종합 Pros \u0026 Cons TxPipeline Lua Script 특징 - Redis Pipeline과 동일한 코드로 수행 가능 - 데이터 무결성 보장 - 낙관적 락 (Watch 중인 키에 변경이 일어나면 트랜잭션 실패) - Lua 언어를 통해 스크립트를 작성해야 함 - 데이터 무결성 보장 - 스크립트 전체가 하나의 단위로 실행 트랜잭션 롤백 여부 불가능 불가능 단점 - Lua에 비해 성능이 안 좋음 (Pipeline과는 비슷) - 스크립트를 관리하는 것 또한 리소스가 소모됨 - 러닝 커브 두 가지 선택지 모두, 트랜잭션 실패 시 롤백을 제공하지 않지만 데이터의 무결성은 보장됨. Value 삽입 전에 유효성 검증을 하기 때문에 데이터 삽입으로 인한 에러 발생 가능성은 적음. 최악의 경우: Redis Connection이 끊어진 경우, Redis 트랜잭션 실패 시 삭제하여 롤백을 구현해야 함. 그러나 커넥션이 끊어진 상태라면 삭제 요청 또한 실패할 가능성이 높음. Redis Sentinel을 사용할 경우, 가용성에 대한 엣지 케이스를 고려해야 하는가? 벤치마크 Redis에 1,000개 Key 세팅 기준\n항목 테스트 횟수 평균 실행 시간 (ms) Lua 스크립트 1424 0.83 TxPipeline 460 2.56 Pipeline 506 2.34 성능차이가 크리티컬 하지 않으며, 무결성은 보장되는 것이 좋기 때문에 TxPipeline 또는 Lua 스크립트를 사용하는 것 권장 ","wordCount":"988","inLanguage":"ko","image":"https://dingyu.dev/ko/posts/redis-transaction/img/redis.png","datePublished":"2024-01-31T00:00:00Z","dateModified":"2024-01-31T00:00:00Z","author":{"@type":"Person","name":"dingyu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://dingyu.dev/ko/posts/redis-transaction/"},"publisher":{"@type":"Organization","name":"Ding's Coding Forge","logo":{"@type":"ImageObject","url":"https://dingyu.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dingyu.dev/ko/ accesskey=h title="Ding's Coding Forge (Alt + H)"><img src=https://dingyu.dev/apple-touch-icon.png alt aria-label=logo height=35>Ding's Coding Forge</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button><span class=nav-separator>|</span><div class=lang-select-dropdown><button class=lang-select-dropdown-trigger aria-label=번역 type=button><svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 512 512" width="24" height="18"><path d="M478.33 433.6l-90-218a22 22 0 00-40.67.0l-90 218a22 22 0 1040.67 16.79L316.66 406h102.67l18.33 44.39A22 22 0 00458 464a22 22 0 0020.32-30.4zM334.83 362 368 281.65 401.17 362z" fill="currentcolor"/><path d="M267.84 342.92a22 22 0 00-4.89-30.7c-.2-.15-15-11.13-36.49-34.73 39.65-53.68 62.11-114.75 71.27-143.49H330a22 22 0 000-44H214V70a22 22 0 00-44 0v20H54a22 22 0 000 44h197.25c-9.52 26.95-27.05 69.5-53.79 108.36-31.41-41.68-43.08-68.65-43.17-68.87a22 22 0 00-40.58 17c.58 1.38 14.55 34.23 52.86 83.93.92 1.19 1.83 2.35 2.74 3.51-39.24 44.35-77.74 71.86-93.85 80.74a22 22 0 1021.07 38.63c2.16-1.18 48.6-26.89 101.63-85.59 22.52 24.08 38 35.44 38.93 36.1a22 22 0 0030.75-4.9z" fill="currentcolor"/></svg></button><div class=lang-select-dropdown-content><a lang=en href=https://dingyu.dev/ title=English aria-label=English>English</a></div></div></div></div><ul id=menu><li><a href=https://dingyu.dev/ko/about/ title=소개><span>소개</span></a></li><li><a href=https://dingyu.dev/ko/categories/ title=카테고리><span>카테고리</span></a></li><li><a href=https://dingyu.dev/ko/tags/ title=태그><span>태그</span></a></li><li><a href=https://dingyu.dev/ko/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://dingyu.dev/ko/search/ title="검색 (Alt + /)" accesskey=/><span>검색</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://dingyu.dev/ko/>홈</a>&nbsp;»&nbsp;<a href=https://dingyu.dev/ko/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">[DB] Redis Transaction</h1><div class=post-description>Unlike RDBMS, Redis doesn’t have a traditional transaction mechanism. It primarily operates as a single-threaded cache, but transactions can still be made atomic using TX pipelines or Lua scripts. This post focuses on comparing the pros and cons of Lua scripts vs. TX pipelines.</div><div class=post-meta><span title='2024-01-31 00:00:00 +0000 UTC'>1월 31, 2024</span>&nbsp;·&nbsp;5 분&nbsp;·&nbsp;988 단어&nbsp;·&nbsp;dingyu&nbsp;|&nbsp;번역:<ul class=i18n_list><li><a href=https://dingyu.dev/posts/redis-transaction/>En</a></li></ul>&nbsp;|&nbsp;<a href=https://github.com/dings-things/blog/tree/main/content/posts/redis-transaction/index.ko.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://dingyu.dev/img/redis.png alt></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><ul><li><a href=#%eb%aa%a9%ec%a0%81 aria-label=목적>목적</a></li><li><a href=#%ec%84%a0%ed%83%9d%ec%a7%80 aria-label=선택지>선택지</a><ul><li><a href=#redis-txpipeline aria-label="Redis TxPipeline">Redis TxPipeline</a><ul><li><a href=#edge-case aria-label="Edge Case">Edge Case</a></li><li><a href=#pros aria-label=Pros>Pros</a></li><li><a href=#cons aria-label=Cons>Cons</a></li><li><a href=#%ed%85%8c%ec%8a%a4%ed%8a%b8 aria-label=테스트>테스트</a></li></ul></li><li><a href=#lua-script aria-label="Lua Script">Lua Script</a><ul><li><a href=#edge-case-1 aria-label="Edge Case">Edge Case</a></li><li><a href=#pros-1 aria-label=Pros:>Pros:</a></li><li><a href=#cons-1 aria-label=Cons:>Cons:</a></li><li><a href=#%ed%85%8c%ec%8a%a4%ed%8a%b8-1 aria-label=테스트>테스트</a></li></ul></li></ul></li><li><a href=#%ec%a2%85%ed%95%a9 aria-label=종합>종합</a><ul><li><a href=#pros--cons aria-label="Pros & Cons">Pros & Cons</a></li><li><a href=#%eb%b2%a4%ec%b9%98%eb%a7%88%ed%81%ac aria-label=벤치마크>벤치마크</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=목적>목적<a hidden class=anchor aria-hidden=true href=#목적>#</a></h1><p>일반적인 Transaction이 필요한 RDB의 경우, 자체적으로 격리 수준을 설정하거나 Rollback과 Commit을 통해 트랜잭션을 구현한다.</p><p>하지만 Redis는 어떠한가?
Redis에서 데이터의 일관성과 원자성을 보장받기 위해 주어진 옵션은 그렇게 명확하지 않다.</p><p>하나의 <strong>Transaction을 격리</strong> 시켜야 하며, <strong>All or Nothing 원자성</strong>을 Redis에서 지켜야 할 때에 도움이 되고자 기록합니다.</p><hr><h1 id=선택지>선택지<a hidden class=anchor aria-hidden=true href=#선택지>#</a></h1><ol><li>Redis TxPipeline</li><li>Lua Script</li></ol><hr><h2 id=redis-txpipeline>Redis TxPipeline<a hidden class=anchor aria-hidden=true href=#redis-txpipeline>#</a></h2><p>Redis에서 여러 Command를 일괄적으로 처리하기 위해 떠올리게 되는 것은 Pipeline일 것이다</p><p>Pipeline은 연결된 Redis Client로 여러 개의 커맨드를 한번에 보내고 여러개의 응답을 한번에 받는 것을 가능하도록 한다</p><p>다만 일반적인 파이프라인이 트랜잭션이 보장된다고 할 수 없다. 즉, 파이프라인 실행 도중 해당 데이터에 대하여 다른 커맨드로 인해 변경될 수 있으며 데이터의 일관성에 문제가 발생할 수 있다</p><h3 id=edge-case>Edge Case<a hidden class=anchor aria-hidden=true href=#edge-case>#</a></h3><ol><li><code>네트워크 지연</code>: Redis Pipeline을 사용하면 여러 개의 커맨드를 한 번에 보내고, 한 번에 여러 개의 응답을 받는 것이 가능합니다. 그러나 네트워크 지연으로 인해 커맨드가 서버에 도착하는 순서와 응답이 도착하는 순서가 일치하지 않을 수 있습니다. 따라서 응답이 먼저 도착하는 경우에도, 실제로는 나중에 실행한 커맨드의 결과일 수 있습니다.</li><li><code>다중 스레드 환경</code>: Redis 서버는 다중 스레드로 동작하며, 여러 클라이언트가 동시에 요청을 보낼 수 있습니다. 따라서 여러 클라이언트가 동시에 Pipeline을 사용할 경우, 커맨드의 실행 순서가 보장되지 않을 수 있습니다.</li><li><code>Redis 서버 설정</code>: Redis 서버의 설정에 따라 일관성이 달라질 수 있습니다. 예를 들어, Redis 서버가 &ldquo;slaveof&rdquo; 설정을 사용하여 데이터를 레플리케이션하는 경우, 일관성이 보장되지 않을 수 있습니다.</li></ol><p>이를 해결하는 것이 <strong>TxPipeline</strong>이다</p><h3 id=pros>Pros<a hidden class=anchor aria-hidden=true href=#pros>#</a></h3><ul><li><code>트랜잭션 보장</code>: TxPipeline을 사용하면 일괄 처리된 커맨드는 하나의 트랜잭션으로 간주되어, 실행 중 다른 커맨드가 중간에 끼어들지 않습니다. 이로써 데이터의 일관성을 보장합니다.</li><li><code>성능 향상</code>: 여러 개의 커맨드를 한 번에 보내므로 네트워크 오버헤드를 줄일 수 있어 성능이 향상될 수 있습니다.</li><li><code>원자성 보장</code>: TxPipeline 내에서 실행되는 모든 커맨드는 성공하거나 실패되며, 롤백은 지원하지 않습니다.</li></ul><h3 id=cons>Cons<a hidden class=anchor aria-hidden=true href=#cons>#</a></h3><ul><li><code>메모리 사용</code>: 모든 커맨드와 결과가 메모리에 저장되므로, 큰 트랜잭션을 처리할 때 메모리 사용량이 증가할 수 있습니다.</li><li><code>복잡성</code>: TxPipeline은 다른 파이프라인과 혼합해서 사용할 때 주의가 필요하며, 트랜잭션의 범위를 신중하게 관리해야 합니다.</li></ul><h3 id=테스트>테스트<a hidden class=anchor aria-hidden=true href=#테스트>#</a></h3><p><img loading=lazy src=/posts/redis-transaction/2.png></p><blockquote><p>WATCH를 통해 특정 키의 변경을 감시하고, 이를 통해 트랜잭션의 일관성을 보장할 수 있습니다.
만약 WATCH 중에 감시된 키가 다른 클라이언트에 의해 변경되면, 해당 트랜잭션은 실패</p></blockquote><p>ex. TxPipeline 도중 에러 발생 시나리오</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>MULTI
</span></span><span class=line><span class=cl>SET key1 value1
</span></span><span class=line><span class=cl>SET key2 value2
</span></span><span class=line><span class=cl>SET key3 value3
</span></span><span class=line><span class=cl>EXEC
</span></span></code></pre></div><p>시나리오 : <strong>SET key2 value2 커맨드가 실패</strong></p><ul><li>CASE 1 : 메모리 부족</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl> <span class=s2>&#34;OOM command not allowed when used memory &gt; &#39;maxmemory&#39;&#34;</span>
</span></span></code></pre></div><ul><li>CASE 2 : 잘못된 데이터 형식</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=s2>&#34;WRONGTYPE Operation against a key holding the wrong kind of value&#34;</span>
</span></span></code></pre></div><p>일반적으로 일어날 수 있는 경우가 드무며, 가장 예상 가능한 시나리오는 Redis Client Connection이 끊어진 케이스가 될것이다.
만약 Client Connection이 끊어진 경우, 실패한 키에 대하여 롤백을 수동으로 진행한다 하여도 롤백 자체가 수행되지 않기 때문에 완벽한 해답은 되지 않는다</p><p>즉, TxPipeline은 일관성은 보장 되지만 완벽한 원자성은 보장되지 않는다</p><hr><h2 id=lua-script>Lua Script<a hidden class=anchor aria-hidden=true href=#lua-script>#</a></h2><p>Lua 스크립트 내에서 여러 Redis 커맨드를 실행하고, 이를 원자적으로 실행할 수 있다</p><h3 id=edge-case-1>Edge Case<a hidden class=anchor aria-hidden=true href=#edge-case-1>#</a></h3><ol><li><strong>스크립트 전송 중 네트워크 지연이나 중단</strong>: 클라이언트가 Lua 스크립트를 Redis 서버로 전송하는 과정에서 네트워크 지연이나 중단이 발생하면, 스크립트는 서버에 제대로 도달하지 못하고 실행되지 않을 수 있습니다.</li><li><strong>실행 결과 수신 중 네트워크 문제</strong>: 스크립트가 성공적으로 실행된 후, 그 결과를 클라이언트가 수신하는 과정에서 네트워크 지연이나 중단이 발생할 수 있습니다. 이 경우, 스크립트는 Redis 서버에서 정상적으로 실행되었지만, 클라이언트는 실행 결과를 받지 못할 수 있습니다.</li></ol><h3 id=pros-1>Pros:<a hidden class=anchor aria-hidden=true href=#pros-1>#</a></h3><ul><li><code>경량 및 빠른 실행</code>: Lua는 경량 스크립팅 언어로, 실행 시스템 자원을 적게 소모하며 빠르게 실행됩니다. 이러한 특징은 임베디드 시스템이나 게임 엔진 등 리소스가 제한된 환경에서 유용합니다.</li><li><code>내장 스크립트 언어</code>: Lua는 많은 애플리케이션과 게임 엔진에서 내장 스크립트 언어로 사용됩니다. 이는 애플리케이션의 확장성을 높이고 사용자 정의 스크립트를 통해 기능을 확장하기에 용이합니다.<ul><li>흔히 이전에 Statement로 관리 되던 DB 명령 방식</li><li>ORM이 등장한 배경을 생각해보았을 때, 커맨드(query)를 코드로 관리할 수 없기 때문에 Lua를 사용함에 회의적인 개인적 생각</li></ul></li><li><code>가독성과 간결성</code>: Lua는 간결하고 가독성이 높은 문법을 가지고 있어 쉽게 이해하고 작성할 수 있습니다.<ul><li>lua Script를 위해 문법을 수정해야 하기 때문에 러닝 커브가 동반될 수 있음</li></ul></li></ul><h3 id=cons-1>Cons:<a hidden class=anchor aria-hidden=true href=#cons-1>#</a></h3><ul><li>작은 생태계: 다른 언어에 비해 Lua의 생태계는 상대적으로 작습니다. 따라서 다양한 라이브러리 및 모듈을 찾기 어려울 수 있습니다.</li><li>제한된 자료형: Lua는 몇 가지 기본 자료형만을 지원하며, 정수와 부동 소수점 수의 구분이 없어서 정확한 숫자 처리가 어려울 수 있습니다.</li><li>엄격한 문법: Lua는 문법 검사가 엄격하며, 초보자에게는 초기 학습 곡선이 높을 수 있습니다.</li><li>쓰레드 처리 어려움: Lua는 기본적으로 싱글 스레드 환경에서 동작하며, 멀티 스레드 처리가 어려울 수 있습니다.</li></ul><h3 id=테스트-1>테스트<a hidden class=anchor aria-hidden=true href=#테스트-1>#</a></h3><p>결국 Lua 또한 트랜잭션에 대한 롤백은 지원하지 않습니다.</p><p>기본적으로 삽입 요청 시, Validation을 체크하는 것을 고려할 때에 일어날 수 있는 최악의 시나리오는 네트워크의 단절이며 해당 방법은 어떠한 방법으로도 복구 될 수 없습니다.</p><p>Redis Pipeline에 저장된 커맨드가 원자적으로 한번에 실행 될 수 없기 때문입니다</p><p><strong>테스트 시나리오</strong></p><p>key1 ~ key5 까지 세팅하는 도중 에러 발생 시, 롤백 테스트</p><ul><li><p>실행 코드 (go)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;context&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=s>&#34;github.com/go-redis/redis/v8&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>ctx</span> <span class=p>=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>rdb</span> <span class=o>:=</span> <span class=nx>redis</span><span class=p>.</span><span class=nf>NewClient</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>redis</span><span class=p>.</span><span class=nx>Options</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>Addr</span><span class=p>:</span> <span class=s>&#34;localhost:6379&#34;</span><span class=p>,</span> <span class=c1>// Redis 서버 주소</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>luaScript</span> <span class=o>:=</span> <span class=s>`
</span></span></span><span class=line><span class=cl><span class=s>    for i = 1, #KEYS do
</span></span></span><span class=line><span class=cl><span class=s>        if KEYS[i] == &#39;key3&#39; then
</span></span></span><span class=line><span class=cl><span class=s>            error(&#39;key3 설정 시 에러 발생&#39;)
</span></span></span><span class=line><span class=cl><span class=s>        else
</span></span></span><span class=line><span class=cl><span class=s>            redis.call(&#39;SET&#39;, KEYS[i], ARGV[i])
</span></span></span><span class=line><span class=cl><span class=s>        end
</span></span></span><span class=line><span class=cl><span class=s>    end
</span></span></span><span class=line><span class=cl><span class=s>    `</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>keys</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;key1&#34;</span><span class=p>,</span> <span class=s>&#34;key2&#34;</span><span class=p>,</span> <span class=s>&#34;key3&#34;</span><span class=p>,</span> <span class=s>&#34;key4&#34;</span><span class=p>,</span> <span class=s>&#34;key5&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>values</span> <span class=o>:=</span> <span class=p>[]</span><span class=kd>interface</span><span class=p>{}{</span><span class=s>&#34;value1&#34;</span><span class=p>,</span> <span class=s>&#34;value2&#34;</span><span class=p>,</span> <span class=s>&#34;value3&#34;</span><span class=p>,</span> <span class=s>&#34;value4&#34;</span><span class=p>,</span> <span class=s>&#34;value5&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>err</span> <span class=o>:=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>Eval</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>luaScript</span><span class=p>,</span> <span class=nx>keys</span><span class=p>,</span> <span class=nx>values</span><span class=o>...</span><span class=p>).</span><span class=nf>Err</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Lua 스크립트 실행 중 오류 발생: %v\n&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Lua 스크립트 실행 완료&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li></ul><p>[결과]
<img loading=lazy src=/posts/redis-transaction/1.png></p><hr><h1 id=종합>종합<a hidden class=anchor aria-hidden=true href=#종합>#</a></h1><h2 id=pros--cons>Pros & Cons<a hidden class=anchor aria-hidden=true href=#pros--cons>#</a></h2><table><thead><tr><th></th><th>TxPipeline</th><th>Lua Script</th></tr></thead><tbody><tr><td><strong>특징</strong></td><td>- Redis Pipeline과 동일한 코드로 수행 가능 - 데이터 무결성 보장 - 낙관적 락 (Watch 중인 키에 변경이 일어나면 트랜잭션 실패)</td><td>- Lua 언어를 통해 스크립트를 작성해야 함 - 데이터 무결성 보장 - 스크립트 전체가 하나의 단위로 실행</td></tr><tr><td><strong>트랜잭션 롤백 여부</strong></td><td>불가능</td><td>불가능</td></tr><tr><td><strong>단점</strong></td><td>- Lua에 비해 성능이 안 좋음 (Pipeline과는 비슷)</td><td>- 스크립트를 관리하는 것 또한 리소스가 소모됨 - 러닝 커브</td></tr></tbody></table><ul><li>두 가지 선택지 모두, <strong>트랜잭션 실패 시 롤백을 제공하지 않지만 데이터의 무결성은 보장됨.</strong></li><li>Value 삽입 전에 <strong>유효성 검증</strong>을 하기 때문에 데이터 삽입으로 인한 에러 발생 가능성은 적음.</li><li><strong>최악의 경우</strong>:<ul><li>Redis Connection이 끊어진 경우, Redis 트랜잭션 실패 시 <strong>삭제하여 롤백을 구현해야 함</strong>.</li><li>그러나 커넥션이 끊어진 상태라면 <strong>삭제 요청 또한 실패할 가능성이 높음</strong>.</li></ul></li><li>Redis Sentinel을 사용할 경우, <strong>가용성에 대한 엣지 케이스를 고려해야 하는가?</strong></li></ul><h2 id=벤치마크>벤치마크<a hidden class=anchor aria-hidden=true href=#벤치마크>#</a></h2><p>Redis에 1,000개 Key 세팅 기준</p><table><thead><tr><th>항목</th><th>테스트 횟수</th><th>평균 실행 시간 (ms)</th></tr></thead><tbody><tr><td>Lua 스크립트</td><td>1424</td><td>0.83</td></tr><tr><td>TxPipeline</td><td>460</td><td>2.56</td></tr><tr><td>Pipeline</td><td>506</td><td>2.34</td></tr></tbody></table><ul><li>성능차이가 크리티컬 하지 않으며, 무결성은 보장되는 것이 좋기 때문에 TxPipeline 또는 Lua 스크립트를 사용하는 것 권장</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://dingyu.dev/ko/tags/redis/>Redis</a></li><li><a href=https://dingyu.dev/ko/tags/transaction/>Transaction</a></li><li><a href=https://dingyu.dev/ko/tags/txpipeline/>Txpipeline</a></li></ul><nav class=paginav><a class=prev href=https://dingyu.dev/ko/posts/aws-well-architected/><span class=title>« 이전 페이지</span><br><span>[Infra] AWS Well Architected</span>
</a><a class=next href=https://dingyu.dev/ko/posts/fastapi-convention/><span class=title>다음 페이지 »</span><br><span>[Python] FastAPI Convention</span></a></nav></footer><div id=giscus_thread><script src=https://giscus.app/client.js data-repo=dings-things/blog data-repo-id=R_kgDON9IuAw data-category=Announcements data-category-id=DIC_kwDON9IuA84CnTai data-mapping=og:title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=ko data-loading=lazy crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://dingyu.dev/ko/>Ding's Coding Forge</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="복사";function s(){t.innerHTML="복사 완료!",setTimeout(()=>{t.innerHTML="복사"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>
<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[Crawler] Recaptcha Solver | Ding's Coding Forge</title>
<meta name=keywords content="c#,selenium,recaptcha,buster"><meta name=description content="This post explores bypassing Google Recaptcha using Selenium and Chrome Extensions for automated web scraping and login automation. It covers setting up ChromeDriver, integrating the Buster Recaptcha Solver extension, and analyzing Recaptcha behavior using browser DevTools and network monitoring. The post also walks through developing a Recaptcha-solving bot in C# using Selenium, handling iframe navigation, token extraction, and retry mechanisms. Additionally, it discusses the limitations of automated Recaptcha solving, Google’s detection mechanisms, and the challenges of scaling such solutions."><meta name=author content="dingyu"><link rel=canonical href=https://dingyu.dev/posts/crawling-selenium-solver/><meta name=google-site-verification content="8XY1hI6NVxQIrN7bQbnX-9TG9HHFw5HOQmlb6vcsFdQ"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.678f9035c217c5346e0b3de5bdc9ebac02c53b0502219858f8653d8d181c97b3.css integrity="sha256-Z4+QNcIXxTRuCz3lvcnrrALFOwUCIZhY+GU9jRgcl7M=" rel="preload stylesheet" as=style><link rel=icon href=https://dingyu.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dingyu.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dingyu.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://dingyu.dev/apple-touch-icon.png><link rel=mask-icon href=https://dingyu.dev/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://dingyu.dev/posts/crawling-selenium-solver/><link rel=alternate hreflang=en href=https://dingyu.dev/en/posts/crawling-selenium-solver/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-XH8830R9KK"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XH8830R9KK")}</script><meta property="og:url" content="https://dingyu.dev/posts/crawling-selenium-solver/"><meta property="og:site_name" content="Ding's Coding Forge"><meta property="og:title" content="[Crawler] Recaptcha Solver"><meta property="og:description" content="This post explores bypassing Google Recaptcha using Selenium and Chrome Extensions for automated web scraping and login automation. It covers setting up ChromeDriver, integrating the Buster Recaptcha Solver extension, and analyzing Recaptcha behavior using browser DevTools and network monitoring. The post also walks through developing a Recaptcha-solving bot in C# using Selenium, handling iframe navigation, token extraction, and retry mechanisms. Additionally, it discusses the limitations of automated Recaptcha solving, Google’s detection mechanisms, and the challenges of scaling such solutions."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-29T00:00:00+00:00"><meta property="article:modified_time" content="2022-06-29T00:00:00+00:00"><meta property="article:tag" content="C#"><meta property="article:tag" content="Selenium"><meta property="article:tag" content="Recaptcha"><meta property="article:tag" content="Buster"><meta property="og:image" content="https://dingyu.dev/posts/crawling-selenium-solver/img/selenium.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dingyu.dev/posts/crawling-selenium-solver/img/selenium.png"><meta name=twitter:title content="[Crawler] Recaptcha Solver"><meta name=twitter:description content="This post explores bypassing Google Recaptcha using Selenium and Chrome Extensions for automated web scraping and login automation. It covers setting up ChromeDriver, integrating the Buster Recaptcha Solver extension, and analyzing Recaptcha behavior using browser DevTools and network monitoring. The post also walks through developing a Recaptcha-solving bot in C# using Selenium, handling iframe navigation, token extraction, and retry mechanisms. Additionally, it discusses the limitations of automated Recaptcha solving, Google’s detection mechanisms, and the challenges of scaling such solutions."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://dingyu.dev/posts/"},{"@type":"ListItem","position":2,"name":"[Crawler] Recaptcha Solver","item":"https://dingyu.dev/posts/crawling-selenium-solver/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[Crawler] Recaptcha Solver","name":"[Crawler] Recaptcha Solver","description":"This post explores bypassing Google Recaptcha using Selenium and Chrome Extensions for automated web scraping and login automation. It covers setting up ChromeDriver, integrating the Buster Recaptcha Solver extension, and analyzing Recaptcha behavior using browser DevTools and network monitoring. The post also walks through developing a Recaptcha-solving bot in C# using Selenium, handling iframe navigation, token extraction, and retry mechanisms. Additionally, it discusses the limitations of automated Recaptcha solving, Google’s detection mechanisms, and the challenges of scaling such solutions.","keywords":["c#","selenium","recaptcha","buster"],"articleBody":"시작에 앞서서 목적 ? 스크래핑을 이용한 데이터 수집에서 로그인하는 과정을 자동화하는 절차는 모든 웹에서 공통적으로 수행해야 하는 과제중 하나이다. 포털 사이트중 일부는 구글 Recaptcha 를 도입하여 Selenium을 통한 접근을 막게 되는데 이를 우회하기 위해 시작하게 되었다. 일반적으로 Selenium 을 사용하게 될때에 쓰이는 Chrome Driver 에 대한 이해를 심화하기 위한 과제 현재는 구글 Extension 을 활용하여 진행하지만 외부에서 배포하고 있는 유료 recaptcha solver 는 사람이 직접 캡챠를 푸는 방식을 채택하는 것이 대부분인데 그 이유를 파악하고자 하는 목적이 있다 기본 설정 1. 크롬 드라이버 설정 사용하고 있는 크롬 브라우저의 버전을 확인한다 : 크롬브라우저 설정 - Chrome 정보 해당 버전과 동일한 버전의 chrome driver를 설치한다 : https://chromedriver.chromium.org/downloads -\u003e supports Chrom version {사용하고 있는 버전} 다운로드 또는 dependency 추가 / Nuget Package 추가 Code를 통하여 Chrome Version과 동일한 버전의 크롬 드라이버를 설치하여 자동화하는 과정은 추후 고도화하는 과정에서 추가할 예정에 있습니다\n2. Buster : Recaptcha Solver 다운로드 구글의 Recaptcha에서 음성을 인식하여 자동으로 타이핑 이후 우회하게 해주는 확장 프로그램입니다\n구글에 buster recaptcha 검색 이후 확장프로그램 다운로드를 진행합니다 추가 설정으로 Speech service 를 선택할 수 있습니다. Wit.ai 가 default 이며 무료로 사용할 수 있으며 Google Speech-to-Text 또한 선택할 수 있는데 논외로 한 기사에서 보았는데 97%의 recaptcha 통과율을 보이는 Speech service 라고 합니다. 다만 Recaptcha 자체가 구글에서 제공하는 것이다 보니 같은 구글의 speech 파일으로 AI의 학습 데이터셋을 활용했을 가능성이 높을것이며 해당 서비스는 유료 이기 때문에 pass 하겠습니다\nWit.ai를 통한 리캡챠 시도시 최대 8회까지 새로고침하여 리캡챠를 시도하였을 때 통과하는 수준을 보였습니다. 이것은 이후에 문제가 되는데 다음에 설명하겠습니다.\n3. Extension 설정 Python, JAVA, C# 을 막론하고 Selenium에서 제공하는 ChromeDriver() 클래스에서는 option으로 addExtension()이라는 메서드를 제공합니다\naddExtension(String extensionPath) : “.crx” 파일의 크롬 확장 프로그램의 압축 파일의 경로를 인스턴스로 옵션값을 설정하게 됩니다\n크롬 브라우저에서 도구 더보기 - 확장 프로그램 을 통하여 chrome://extentions 에 접근\n개발자 모드를 활성화 시키고 활용하고자 하는 extension의 아이디를 기억합니다 이후 확장 프로그램 압축 클릭 - extension 파일의 경로에 위치 시킵니다 (아래의 경우 1.3.1_0 을 폴더로 선택) 일반적으로 경로는 Users-{사용자 Desktop}-AppData-Local-Google-Default-Extensions에 위치합니다 (위에서 ID값을 기억한 이후 해당 ID값을 가지는 폴더를 선택하여 압축합니다) ! AppData 가 보이지 않는다면 사용자Desktop에서 \\AppData를 입력하여 접근합니다 !\n브라우저를 통한 리캡챠를 갖는 웹의 분석 코드로 작성하기에 앞서 스크래핑에 있어 가장 중요한 웹페이지의 분석 단계입니다 먼저 얻고자 하는 result(리캡챠 통과) 를 설정하고 과정을 시뮬레이션하여 바뀌게 되는 패킷의 이동이나 웹 브라우저의 변화를 감지합니다\nTest 하게 되는 url 은 https://patrickhlauke.github.io/recaptcha/ 이며 해당 url에는 항시 리캡챠가 적용되어있기 때문에 이를 토대로 분석해줍니다\nFiddler 를 통한 패킷의 변화 만약 로그인 시도시에 recaptcha가 존재한다면 HttpResponse 로 ex:needRecaptcha 와 같은 response를 로그인 페이지를 GET하게 될때에 얻을 수 있을 것입니다. 만약 needRecaptcha가 true 라면 이 일련의 과정을 거쳐야 한다고 판단할 수 있는 것이죠! needRecaptcha가 true라는 가정하에 로그인 POST 시에 Required 파라미터로 Recaptcha 토큰 값 또한 body에 넣어야 로그인이 진행됩니다. 이때문에 Recaptcha Api를 제공하는 곳에서는 이 토큰값을 반환하여 돈을 얻게 되는 것이죠. 브라우저의 변화 첫번째로 봐야 할 것은 위에 상단에 위치하는 recaptcha 입니다\ndata-sitekey 라는 속성을 갖는데 이는 웹마다 다른 고유값을 가집니다 (식별키) 실제로 recaptcha solve api를 제공하는 곳에선 이 data-sitekey 를 통하여 리캡챠를 사람이 푼뒤 토큰값을 반환하는 것으로 알고 있습니다 해당 div 에는 iframe이 존재하는데 Selenium 의 SwitchTO().Frame 을 통하여 접근할 수 있습니다 분석한 결과를 토대로 핵심만 말하자면 이 iframe 에서는 Recaptcha 가 체크되었는지, 즉 통과되었는지 여부를 알 수 있습니다 aria-checked = false 에서 true 로 바뀌는 시점이 리캡챠가 풀리는 시점입니다. 현재 Selenium을 통한 스크래핑 과정중에 있기때문에 현실에서는 눈으로 캡챠가 풀렸는지 확인할 수 있지만 Selenium을 통하였을때 통과되는 분기점을 찾는것은 매우 중요합니다. 저는 이 aria-checked 라는 attribute 값의 변화를 분기점으로 두고 스크래핑하였습니다 또한 리캡챠가 완료되었을때 token 값이 담기는 iframe 이기 때문에 핵심이라고 할 수 있습니다 두번째는 title=“recaptcha challenge expires in two minutes” 를 갖는 iframe 입니다\n만약 리캡챠를 푸는것이 초기라면 그림이나 음성을 통한 수행과정 없이도 바로 체크를 얻을 수 있을것입니다. 하지만 반복적인 리캡챠 수행이 이루어지게 되었을때 그림, 음성 수행과정을 수행하는 iframe 이 이곳입니다 buster 확장프로그램 버튼이 위치하는 iframe이기도 합니다 앞서 설명했듯 Wit.Ai 를 통한 Speech-to-Text 는 완벽하지 않습니다. 평균적으로 5회 정도하였을때 성공하는 정도를 보였습니다. 결국 성공할 때 까지 refresh 버튼을 통하여 Speech 를 초기화한뒤 buster button을 계속 눌러줘야 합니다 (성공할때까지)\n! 구글은 이러한 정형화된 Action 을 파악하여 일정 횟수를 초과하면 해당 ip 에서는 아에 리캡챠를 수행하지 못하도록 막아버립니다. 이러한 이유때문에 이 프로젝트가 실험적인 요소로 남을 수 밖에 없는 것입니다 !\nTo Code (C# Base) 위의 분석을 토대로 전체적인 Flow 를 구상합니다\n로그인 페이지에 접근 -\u003e response에서 needRecaptcha 가 true ? -\u003e Selenium을 통한 브라우저 조종 ( recaptcha checkbox 가 체크될때 까지 buster button 과 reload를 눌러 리캡챠를 통과 시킴 ) -\u003e recaptcha token 을 포함하는 POST 메서드를 통하여 로그인 통과\n유닛테스트 (MS Test)를 기반으로 프로젝트를 생성하겠습니다\nNuget Package 를 통하여 Selenium.WebDriver 를 다운로드하여 프로젝트 패키지에 넣어줍니다\n크롬 드라이버 생성\nNuget 을 통하여 ChromeDriver를 생성하였다면\nChromeOptions _options = new ChromeOptions(); _options.AddExtension(@\u0026#34;...\\...\\path_to_.crx\u0026#34;); ChromeDriver _driver = new ChromeDriver(_options); chromedriver.exe를 직접 설치하였다면 (chormedriver.exe 가 아닌 포함 된 폴더로 지정)\nChromeOptions _options = new ChromeOptions(); _options.AddExtension(@\u0026#34;...\\...\\path_to_.crx\u0026#34;); ChromeDriver _driver = new ChromeDriver(@\u0026#34;...\\...\\path_to_chromedriver_folder\u0026#34;,_options); Extra ) Profile 을 통한 설정으로 크롬드라이버 생성시 만약 다른 사용자가 만들어놓은 Profile에 접근 할 수 없어 보안상 문제가 없다고 한다면 통용되는 방법입니다\n크롬에서 프로필 사진 클릭 계정 없이 계속 신규 프로필 생성 새로 만든 프로필의 경로 Users-{사용자 Desktop}-AppData-Local-Google-Profile{만든순서} 에 위치합니다\n새로 만든 프로필에서 buster extension을 다운로드\nChromeDriverOption 설정을 통하여 드라이버 생성\nChromeOptions _options = new ChromeOptions(); _options.AddArgument(\u0026#34;--user-data-dir=\u0026#34; + @\u0026#34;path_to_profile\u0026#34;); _options.AddArgument(\u0026#34;--profile-directory=ProfileNumber\u0026#34;); ChromeDriver _driver = new ChromeDriver(_options); **! 주의 사항 ! **: 해당 프로필의 브라우저가 열려있을때 Selenium 으로 해당 프로필 정보로 드라이버 생성시 Error 가 발생합니다\n우선 리캡챠 체크 여부를 판별하는 메서드와 해당 WebElement 가 존재하는지 여부를 판별하는 메서드를 따로 생성하여 관리 하였습니다 public static bool IsChecked(ChromeDriver driver) { bool check = driver.FindElement(By.Id(\u0026#34;recaptcha-anchor\u0026#34;)).GetAttribute(\u0026#34;aria-checked\u0026#34;).Equals(\u0026#34;true\u0026#34;) ? true : false; return check; } public static bool IsExistByCss(ChromeDriver driver, string cssQuery) { try { driver.FindElement(By.CssSelector(cssQuery)); } catch (Exception e) { return false; } return true; } 세션시간 초과로 캡챠가 도중에 풀렸을 수도 있기때문에 미리 캡챠 div가 있는지 판별 if (IsExistByCss(_driver, \u0026#34;iframe[title=\\\u0026#34;reCAPTCHA\\\u0026#34;]\u0026#34;)) recaptcha 가 존재한다면 앞서 설명한 두개의 iframe Element를 저장해줍니다 IWebElement first = _driver.FindElement(By.CssSelector(\u0026#34;iframe[title=\\\u0026#34;reCAPTCHA\\\u0026#34;]\u0026#34;)); var x = _driver.PageSource; IWebElement second = _driver.FindElement(By.CssSelector(\u0026#34;iframe[title=\\\u0026#34;reCAPTCHA 보안문자 2분 후 만료\\\u0026#34;]\u0026#34;)); 첫번째 iframe 으로 전환후 리캡챠 체크박스를 클릭합니다 ( 이상하게 Element.Click()이 통하지 않아 executeScript를 사용하니 적용이 되었습니다 ) _driver.SwitchTo().Frame(first); var checkBox = _driver.FindElement(By.ClassName(\u0026#34;recaptcha-checkbox\u0026#34;)); _driver.ExecuteScript(\u0026#34;arguments[0].click()\u0026#34;, checkBox); // IFrame 에 접근시 JS를 통하지 않고 바로 Click() 수행시 동작하지 않는 문제 체크박스 클릭이후 체크여부를 판별합니다 if (!IsChecked(_driver)) 첫번째 iframe -\u003e 두번째 iframe 으로 접근합니다 ( iframe 간에는 바로 Switch가 불가능하며 본래 html로 복귀 이후 이동하여야 합니다 ) 이후 buster button을 클릭합니다 _driver.SwitchTo().DefaultContent(); // 본래 html 로 복귀 _driver.SwitchTo().Frame(second); _driver.Manage().Timeouts().ImplicitWait = TimeSpan.FromSeconds(200); var busterHolder = _driver.FindElement(By.ClassName(\u0026#34;help-button-holder\u0026#34;)); busterHolder.Click(); 만약 리캡챠가 풀리지 않았다면 풀릴때까지 10회 반복합니다 ( 이미지 버튼을 클릭하여 Speech reload 이후 buster button click) if (!IsChecked(_driver)) { _driver.SwitchTo().DefaultContent(); // 본래 html 로 복귀 _driver.SwitchTo().Frame(second); _driver.FindElement(By.ClassName(\u0026#34;rc-button-image\u0026#34;)).Click(); _driver.FindElement(By.ClassName(\u0026#34;help-button-holder\u0026#34;)).Click(); } else { isChecked=true; break; } 마지막으로 체크가 되었다면 토큰값을 반환합니다 if (isChecked) { _driver.SwitchTo().DefaultContent(); _driver.SwitchTo().Frame(second); _token = _driver.FindElement(By.Id(\u0026#34;recaptcha-token\u0026#34;)).GetAttribute(\u0026#34;value\u0026#34;); return _token; } 개선사항 위의 프로젝트를 진행하면서 구글의 똑똑함을 다시한번 느꼈습니다. 만약 과금을 하더라도 Google speech-to-text 를 이용하였다면 높은 성공율으로 트래픽이 다소 많더라도 리캡챠를 풀 수 있었겠지만 그렇지 않았기에 결국 자동화된 프로그램으로 인식되어 Recaptcha가 밴 될수도 있다는 것을 알게 되었죠..\nGoogle 의 Recaptcha v3 같은 경우에는 커서의 움직임이나 행동패턴을 통하여도 구분한다고 하는데 이 프로젝트를 고도화 한다 하여도 v3에는 아마 꼬리가 잡히지 않을까 합니다.\n그래서 많은 ReCaptcha Solver API 가 실제 사람들을 고용하여 수동으로 풀고 토큰값을 반환하는게 아닐까 그런 생각도 들고 말이죠.\n핵심적으로 위의 프로젝트에서 개선되어야 할점을 꼬집어 보자면 API로서의 역할을 하기에는 불완전 요소가 많다는 점입니다\nChrome 브라우저 버전과 Chrome driver 버전의 일치를 manually 하여야 한다는 점 트래픽이 많고 리캡챠의 실패가 잦아 질수록 구글에서의 리캡챠 밴이 될 확률이 높다는 점 리캡챠가 풀리는 2분내에 로그인까지 완료가 되지 않을 수도 있다는 점 이러한 점들이 있겠네요.\n","wordCount":"1223","inLanguage":"ko","image":"https://dingyu.dev/posts/crawling-selenium-solver/img/selenium.png","datePublished":"2022-06-29T00:00:00Z","dateModified":"2022-06-29T00:00:00Z","author":{"@type":"Person","name":"dingyu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://dingyu.dev/posts/crawling-selenium-solver/"},"publisher":{"@type":"Organization","name":"Ding's Coding Forge","logo":{"@type":"ImageObject","url":"https://dingyu.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dingyu.dev/ accesskey=h title="Ding's Coding Forge (Alt + H)"><img src=https://dingyu.dev/apple-touch-icon.png alt aria-label=logo height=35>Ding's Coding Forge</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button><span class=nav-separator>|</span><div class=lang-select-dropdown><button class=lang-select-dropdown-trigger aria-label=번역 type=button><svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 512 512" width="24" height="18"><path d="M478.33 433.6l-90-218a22 22 0 00-40.67.0l-90 218a22 22 0 1040.67 16.79L316.66 406h102.67l18.33 44.39A22 22 0 00458 464a22 22 0 0020.32-30.4zM334.83 362 368 281.65 401.17 362z" fill="currentcolor"/><path d="M267.84 342.92a22 22 0 00-4.89-30.7c-.2-.15-15-11.13-36.49-34.73 39.65-53.68 62.11-114.75 71.27-143.49H330a22 22 0 000-44H214V70a22 22 0 00-44 0v20H54a22 22 0 000 44h197.25c-9.52 26.95-27.05 69.5-53.79 108.36-31.41-41.68-43.08-68.65-43.17-68.87a22 22 0 00-40.58 17c.58 1.38 14.55 34.23 52.86 83.93.92 1.19 1.83 2.35 2.74 3.51-39.24 44.35-77.74 71.86-93.85 80.74a22 22 0 1021.07 38.63c2.16-1.18 48.6-26.89 101.63-85.59 22.52 24.08 38 35.44 38.93 36.1a22 22 0 0030.75-4.9z" fill="currentcolor"/></svg></button><div class=lang-select-dropdown-content><a lang=en href=https://dingyu.dev/en/ title=English aria-label=English>English</a></div></div></div></div><ul id=menu><li><a href=https://dingyu.dev/about/ title=소개><span>소개</span></a></li><li><a href=https://dingyu.dev/categories/ title=카테고리><span>카테고리</span></a></li><li><a href=https://dingyu.dev/tags/ title=태그><span>태그</span></a></li><li><a href=https://dingyu.dev/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://dingyu.dev/search/ title="검색 (Alt + /)" accesskey=/><span>검색</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://dingyu.dev/>홈</a>&nbsp;»&nbsp;<a href=https://dingyu.dev/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">[Crawler] Recaptcha Solver</h1><div class=post-description>This post explores bypassing Google Recaptcha using Selenium and Chrome Extensions for automated web scraping and login automation. It covers setting up ChromeDriver, integrating the Buster Recaptcha Solver extension, and analyzing Recaptcha behavior using browser DevTools and network monitoring. The post also walks through developing a Recaptcha-solving bot in C# using Selenium, handling iframe navigation, token extraction, and retry mechanisms. Additionally, it discusses the limitations of automated Recaptcha solving, Google’s detection mechanisms, and the challenges of scaling such solutions.</div><div class=post-meta><span title='2022-06-29 00:00:00 +0000 UTC'>6월 29, 2022</span>&nbsp;·&nbsp;6 분&nbsp;·&nbsp;1223 단어&nbsp;·&nbsp;dingyu&nbsp;|&nbsp;번역:<ul class=i18n_list><li><a href=https://dingyu.dev/en/posts/crawling-selenium-solver/>En</a></li></ul>&nbsp;|&nbsp;<a href=https://github.com/dings-things/blog/tree/main/content/posts/crawling-selenium-solver/index.ko.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://dingyu.dev/img/selenium.png alt></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><ul><li><a href=#%ec%8b%9c%ec%9e%91%ec%97%90-%ec%95%9e%ec%84%9c%ec%84%9c aria-label="시작에 앞서서">시작에 앞서서</a><ul><li><a href=#%eb%aa%a9%ec%a0%81- aria-label="목적 ?">목적 ?</a></li><li><a href=#%ea%b8%b0%eb%b3%b8-%ec%84%a4%ec%a0%95 aria-label="기본 설정">기본 설정</a><ul><li><a href=#1-%ed%81%ac%eb%a1%ac-%eb%93%9c%eb%9d%bc%ec%9d%b4%eb%b2%84-%ec%84%a4%ec%a0%95 aria-label="1. 크롬 드라이버 설정">1. 크롬 드라이버 설정</a></li><li><a href=#2-buster--recaptcha-solver-%eb%8b%a4%ec%9a%b4%eb%a1%9c%eb%93%9c aria-label="2. Buster : Recaptcha Solver 다운로드">2. Buster : Recaptcha Solver 다운로드</a></li><li><a href=#3-extension-%ec%84%a4%ec%a0%95 aria-label="3. Extension 설정">3. Extension 설정</a></li></ul></li><li><a href=#%eb%b8%8c%eb%9d%bc%ec%9a%b0%ec%a0%80%eb%a5%bc-%ed%86%b5%ed%95%9c-%eb%a6%ac%ec%ba%a1%ec%b1%a0%eb%a5%bc-%ea%b0%96%eb%8a%94-%ec%9b%b9%ec%9d%98-%eb%b6%84%ec%84%9d aria-label="브라우저를 통한 리캡챠를 갖는 웹의 분석">브라우저를 통한 리캡챠를 갖는 웹의 분석</a><ul><li><a href=#fiddler-%eb%a5%bc-%ed%86%b5%ed%95%9c-%ed%8c%a8%ed%82%b7%ec%9d%98-%eb%b3%80%ed%99%94 aria-label="Fiddler 를 통한 패킷의 변화">Fiddler 를 통한 패킷의 변화</a></li><li><a href=#%eb%b8%8c%eb%9d%bc%ec%9a%b0%ec%a0%80%ec%9d%98-%eb%b3%80%ed%99%94 aria-label="브라우저의 변화">브라우저의 변화</a></li></ul></li><li><a href=#to-code-c-base aria-label="To Code (C# Base)">To Code (C# Base)</a><ul><li><a href=#extra--profile-%ec%9d%84-%ed%86%b5%ed%95%9c-%ec%84%a4%ec%a0%95%ec%9c%bc%eb%a1%9c-%ed%81%ac%eb%a1%ac%eb%93%9c%eb%9d%bc%ec%9d%b4%eb%b2%84-%ec%83%9d%ec%84%b1%ec%8b%9c aria-label="Extra ) Profile 을 통한 설정으로 크롬드라이버 생성시">Extra ) Profile 을 통한 설정으로 크롬드라이버 생성시</a></li></ul></li><li><a href=#%ea%b0%9c%ec%84%a0%ec%82%ac%ed%95%ad aria-label=개선사항>개선사항</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=시작에-앞서서>시작에 앞서서<a hidden class=anchor aria-hidden=true href=#시작에-앞서서>#</a></h2><h3 id=목적->목적 ?<a hidden class=anchor aria-hidden=true href=#목적->#</a></h3><ul><li>스크래핑을 이용한 데이터 수집에서 로그인하는 과정을 자동화하는 절차는 모든 웹에서 공통적으로 수행해야 하는 과제중 하나이다. 포털 사이트중 일부는 구글 Recaptcha 를 도입하여 Selenium을 통한 접근을 막게 되는데 이를 우회하기 위해 시작하게 되었다.</li><li>일반적으로 Selenium 을 사용하게 될때에 쓰이는 Chrome Driver 에 대한 이해를 심화하기 위한 과제</li><li>현재는 구글 Extension 을 활용하여 진행하지만 외부에서 배포하고 있는 유료 recaptcha solver 는 사람이 직접 캡챠를 푸는 방식을 채택하는 것이 대부분인데 그 이유를 파악하고자 하는 목적이 있다</li></ul><hr><h3 id=기본-설정>기본 설정<a hidden class=anchor aria-hidden=true href=#기본-설정>#</a></h3><h4 id=1-크롬-드라이버-설정>1. 크롬 드라이버 설정<a hidden class=anchor aria-hidden=true href=#1-크롬-드라이버-설정>#</a></h4><ul><li>사용하고 있는 크롬 브라우저의 버전을 확인한다 : 크롬브라우저 설정 - Chrome 정보
<img loading=lazy src=/posts/crawling-selenium-solver/image.png></li><li>해당 버전과 동일한 버전의 chrome driver를 설치한다 : <a href=https://chromedriver.chromium.org/downloads>https://chromedriver.chromium.org/downloads</a>
-> supports Chrom version {사용하고 있는 버전} 다운로드
또는 dependency 추가 / Nuget Package 추가
<img loading=lazy src=/posts/crawling-selenium-solver/image-1.png></li></ul><p>Code를 통하여 Chrome Version과 동일한 버전의 크롬 드라이버를 설치하여 자동화하는 과정은 추후 고도화하는 과정에서 추가할 예정에 있습니다</p><h4 id=2-buster--recaptcha-solver-다운로드>2. Buster : Recaptcha Solver 다운로드<a hidden class=anchor aria-hidden=true href=#2-buster--recaptcha-solver-다운로드>#</a></h4><ul><li><p>구글의 Recaptcha에서 음성을 인식하여 자동으로 타이핑 이후 우회하게 해주는 확장 프로그램입니다</p></li><li><p>구글에 buster recaptcha 검색 이후 확장프로그램 다운로드를 진행합니다
<img loading=lazy src=/posts/crawling-selenium-solver/image-2.png>
추가 설정으로 Speech service 를 선택할 수 있습니다.
Wit.ai 가 default 이며 무료로 사용할 수 있으며 Google Speech-to-Text 또한 선택할 수 있는데 논외로 한 기사에서 보았는데 97%의 recaptcha 통과율을 보이는 Speech service 라고 합니다.
다만 Recaptcha 자체가 구글에서 제공하는 것이다 보니 같은 구글의 speech 파일으로 AI의 학습 데이터셋을 활용했을 가능성이 높을것이며 해당 서비스는 <strong>유료</strong> 이기 때문에 pass 하겠습니다</p></li><li><p>Wit.ai를 통한 리캡챠 시도시 최대 8회까지 새로고침하여 리캡챠를 시도하였을 때 통과하는 수준을 보였습니다. 이것은 이후에 문제가 되는데 다음에 설명하겠습니다.</p></li></ul><h4 id=3-extension-설정>3. Extension 설정<a hidden class=anchor aria-hidden=true href=#3-extension-설정>#</a></h4><ul><li><p>Python, JAVA, C# 을 막론하고 Selenium에서 제공하는 <code>ChromeDriver()</code> 클래스에서는 option으로 <code>addExtension()</code>이라는 메서드를 제공합니다</p></li><li><p><code>addExtension(String extensionPath)</code> : &ldquo;.crx&rdquo; 파일의 크롬 확장 프로그램의 압축 파일의 경로를 인스턴스로 옵션값을 설정하게 됩니다</p></li><li><p>크롬 브라우저에서 도구 더보기 - 확장 프로그램 을 통하여 chrome://extentions 에 접근</p></li></ul><p><img loading=lazy src=/posts/crawling-selenium-solver/image-3.png></p><ul><li><p>개발자 모드를 활성화 시키고 활용하고자 하는 extension의 아이디를 기억합니다
<img loading=lazy src=/posts/crawling-selenium-solver/image-4.png></p></li><li><p>이후 확장 프로그램 압축 클릭 - extension 파일의 경로에 위치 시킵니다 (아래의 경우 1.3.1_0 을 폴더로 선택)
<img loading=lazy src=/posts/crawling-selenium-solver/image-5.png>
<code>일반적으로 경로는 Users-{사용자 Desktop}-AppData-Local-Google-Default-Extensions에 위치합니다</code> (위에서 ID값을 기억한 이후 해당 ID값을 가지는 폴더를 선택하여 압축합니다)
<strong>! AppData 가 보이지 않는다면 사용자Desktop에서 \AppData를 입력하여 접근합니다 !</strong></p></li></ul><hr><h3 id=브라우저를-통한-리캡챠를-갖는-웹의-분석>브라우저를 통한 리캡챠를 갖는 웹의 분석<a hidden class=anchor aria-hidden=true href=#브라우저를-통한-리캡챠를-갖는-웹의-분석>#</a></h3><p>코드로 작성하기에 앞서 스크래핑에 있어 가장 중요한 웹페이지의 분석 단계입니다
먼저 얻고자 하는 result(리캡챠 통과) 를 설정하고 과정을 시뮬레이션하여 바뀌게 되는 패킷의 이동이나 웹 브라우저의 변화를 감지합니다</p><p>Test 하게 되는 url 은 <a href=https://patrickhlauke.github.io/recaptcha/>https://patrickhlauke.github.io/recaptcha/</a> 이며 해당 url에는 항시 리캡챠가 적용되어있기 때문에 이를 토대로 분석해줍니다</p><h4 id=fiddler-를-통한-패킷의-변화>Fiddler 를 통한 패킷의 변화<a hidden class=anchor aria-hidden=true href=#fiddler-를-통한-패킷의-변화>#</a></h4><ul><li>만약 로그인 시도시에 recaptcha가 존재한다면 HttpResponse 로 <code>ex:needRecaptcha</code> 와 같은 response를 로그인 페이지를 <code>GET</code>하게 될때에 얻을 수 있을 것입니다.</li><li>만약 <strong>needRecaptcha</strong>가 <strong>true</strong> 라면 이 일련의 과정을 거쳐야 한다고 판단할 수 있는 것이죠!</li><li>needRecaptcha가 true라는 가정하에 로그인 <code>POST</code> 시에 Required 파라미터로 Recaptcha 토큰 값 또한 body에 넣어야 로그인이 진행됩니다. 이때문에 Recaptcha Api를 제공하는 곳에서는 이 토큰값을 반환하여 돈을 얻게 되는 것이죠.</li></ul><h4 id=브라우저의-변화>브라우저의 변화<a hidden class=anchor aria-hidden=true href=#브라우저의-변화>#</a></h4><p>첫번째로 봐야 할 것은 위에 상단에 위치하는 recaptcha 입니다</p><ul><li><code>data-sitekey</code> 라는 속성을 갖는데 이는 웹마다 다른 고유값을 가집니다 (<strong>식별키</strong>)
실제로 recaptcha solve api를 제공하는 곳에선 이 data-sitekey 를 통하여 리캡챠를 사람이 푼뒤 토큰값을 반환하는 것으로 알고 있습니다</li><li>해당 div 에는 iframe이 존재하는데 Selenium 의 SwitchTO().Frame 을 통하여 접근할 수 있습니다</li><li>분석한 결과를 토대로 핵심만 말하자면 이 iframe 에서는 Recaptcha 가 체크되었는지, 즉 통과되었는지 여부를 알 수 있습니다
<img loading=lazy src=/posts/crawling-selenium-solver/image-6.png>
aria-checked = false 에서 true 로 바뀌는 시점이 리캡챠가 풀리는 시점입니다.
현재 Selenium을 통한 스크래핑 과정중에 있기때문에 현실에서는 눈으로 캡챠가 풀렸는지 확인할 수 있지만 Selenium을 통하였을때 통과되는 분기점을 찾는것은 매우 중요합니다.</li></ul><p>저는 이 aria-checked 라는 attribute 값의 변화를 분기점으로 두고 스크래핑하였습니다
<img loading=lazy src=/posts/crawling-selenium-solver/image-7.png></p><ul><li>또한 리캡챠가 완료되었을때 token 값이 담기는 iframe 이기 때문에 핵심이라고 할 수 있습니다</li></ul><p>두번째는 title=&ldquo;recaptcha challenge expires in two minutes&rdquo; 를 갖는 iframe 입니다</p><ul><li><p>만약 리캡챠를 푸는것이 초기라면 그림이나 음성을 통한 수행과정 없이도 바로 체크를 얻을 수 있을것입니다. 하지만 반복적인 리캡챠 수행이 이루어지게 되었을때 그림, 음성 수행과정을 수행하는 iframe 이 이곳입니다
<img loading=lazy src=/posts/crawling-selenium-solver/image-8.png></p></li><li><p>buster 확장프로그램 버튼이 위치하는 iframe이기도 합니다
<img loading=lazy src=/posts/crawling-selenium-solver/image-9.png></p></li><li><p>앞서 설명했듯 Wit.Ai 를 통한 Speech-to-Text 는 완벽하지 않습니다. 평균적으로 5회 정도하였을때 성공하는 정도를 보였습니다. 결국 성공할 때 까지 refresh 버튼을 통하여 Speech 를 초기화한뒤 buster button을 계속 눌러줘야 합니다 (성공할때까지)</p></li></ul><p><strong>! 구글은 이러한 정형화된 Action 을 파악하여 일정 횟수를 초과하면 해당 ip 에서는 아에 리캡챠를 수행하지 못하도록 막아버립니다. 이러한 이유때문에 이 프로젝트가 실험적인 요소로 남을 수 밖에 없는 것입니다 !</strong></p><hr><h3 id=to-code-c-base>To Code (C# Base)<a hidden class=anchor aria-hidden=true href=#to-code-c-base>#</a></h3><p>위의 분석을 토대로 전체적인 Flow 를 구상합니다</p><blockquote><p><strong>로그인 페이지에 접근 ->
response에서 needRecaptcha 가 true ? ->
Selenium을 통한 브라우저 조종 ( recaptcha checkbox 가 체크될때 까지 buster button 과 reload를 눌러 리캡챠를 통과 시킴 ) ->
recaptcha token 을 포함하는 POST 메서드를 통하여 로그인 통과</strong></p></blockquote><p>유닛테스트 (MS Test)를 기반으로 프로젝트를 생성하겠습니다</p><ol><li><p>Nuget Package 를 통하여 Selenium.WebDriver 를 다운로드하여 프로젝트 패키지에 넣어줍니다</p></li><li><p>크롬 드라이버 생성</p></li></ol><p>Nuget 을 통하여 ChromeDriver를 생성하였다면</p><pre tabindex=0><code class=language-cs>ChromeOptions _options = new ChromeOptions();
_options.AddExtension(@&amp;#34;...\...\path_to_.crx&amp;#34;);

ChromeDriver _driver = new ChromeDriver(_options);</code></pre><p>chromedriver.exe를 직접 설치하였다면 (chormedriver.exe 가 아닌 포함 된 폴더로 지정)</p><pre tabindex=0><code class=language-cs>  ChromeOptions _options = new ChromeOptions();
  _options.AddExtension(@&amp;#34;...\...\path_to_.crx&amp;#34;);

  ChromeDriver _driver = new ChromeDriver(@&amp;#34;...\...\path_to_chromedriver_folder&amp;#34;,_options);</code></pre><hr><h4 id=extra--profile-을-통한-설정으로-크롬드라이버-생성시>Extra ) Profile 을 통한 설정으로 크롬드라이버 생성시<a hidden class=anchor aria-hidden=true href=#extra--profile-을-통한-설정으로-크롬드라이버-생성시>#</a></h4><p>만약 다른 사용자가 만들어놓은 Profile에 접근 할 수 없어 보안상 문제가 없다고 한다면 통용되는 방법입니다</p><ol><li><p>크롬에서 프로필 사진 클릭
<img loading=lazy src=/posts/crawling-selenium-solver/image-10.png></p></li><li><p>계정 없이 계속
<img loading=lazy src=/posts/crawling-selenium-solver/image-11.png></p></li><li><p>신규 프로필 생성
<img loading=lazy src=/posts/crawling-selenium-solver/image-12.png></p></li><li><p>새로 만든 프로필의 경로
<img loading=lazy src=/posts/crawling-selenium-solver/image-13.png>
Users-{사용자 Desktop}-AppData-Local-Google-Profile{만든순서} 에 위치합니다</p></li><li><p>새로 만든 프로필에서 buster extension을 다운로드</p></li><li><p>ChromeDriverOption 설정을 통하여 드라이버 생성</p></li></ol><pre tabindex=0><code class=language-cs>ChromeOptions _options = new ChromeOptions();
_options.AddArgument(&amp;#34;--user-data-dir=&amp;#34; &#43; @&amp;#34;path_to_profile&amp;#34;);
_options.AddArgument(&amp;#34;--profile-directory=ProfileNumber&amp;#34;);

ChromeDriver _driver = new ChromeDriver(_options);</code></pre><p>**! 주의 사항 ! **: 해당 프로필의 브라우저가 열려있을때 Selenium 으로 해당 프로필 정보로 드라이버 생성시 <code>Error</code> 가 발생합니다</p><hr><ol start=3><li>우선 리캡챠 체크 여부를 판별하는 메서드와 해당 WebElement 가 존재하는지 여부를 판별하는 메서드를 따로 생성하여 관리 하였습니다</li></ol><pre tabindex=0><code class=language-cs>public static bool IsChecked(ChromeDriver driver)
{
    bool check = driver.FindElement(By.Id(&amp;#34;recaptcha-anchor&amp;#34;)).GetAttribute(&amp;#34;aria-checked&amp;#34;).Equals(&amp;#34;true&amp;#34;) ? true : false;
    return check;
}


public static bool IsExistByCss(ChromeDriver driver, string cssQuery)
{
    try
    {
        driver.FindElement(By.CssSelector(cssQuery));
    }
    catch (Exception e)
    {
        return false;
    }

    return true;
}</code></pre><ol start=4><li>세션시간 초과로 캡챠가 도중에 풀렸을 수도 있기때문에 미리 캡챠 div가 있는지 판별</li></ol><pre tabindex=0><code class=language-cs>if (IsExistByCss(_driver, &amp;#34;iframe[title=\&amp;#34;reCAPTCHA\&amp;#34;]&amp;#34;))</code></pre><ol start=5><li>recaptcha 가 존재한다면 앞서 설명한 두개의 iframe Element를 저장해줍니다</li></ol><pre tabindex=0><code class=language-cs>IWebElement first = _driver.FindElement(By.CssSelector(&amp;#34;iframe[title=\&amp;#34;reCAPTCHA\&amp;#34;]&amp;#34;));
var x = _driver.PageSource;
IWebElement second = _driver.FindElement(By.CssSelector(&amp;#34;iframe[title=\&amp;#34;reCAPTCHA 보안문자 2분 후 만료\&amp;#34;]&amp;#34;));</code></pre><ol start=6><li>첫번째 iframe 으로 전환후 리캡챠 체크박스를 클릭합니다 ( 이상하게 Element.Click()이 통하지 않아 executeScript를 사용하니 적용이 되었습니다 )</li></ol><pre tabindex=0><code class=language-cs>_driver.SwitchTo().Frame(first);
var checkBox = _driver.FindElement(By.ClassName(&amp;#34;recaptcha-checkbox&amp;#34;));
_driver.ExecuteScript(&amp;#34;arguments[0].click()&amp;#34;, checkBox); // IFrame 에 접근시 JS를 통하지 않고 바로 Click() 수행시 동작하지 않는 문제</code></pre><ol start=7><li>체크박스 클릭이후 체크여부를 판별합니다</li></ol><pre tabindex=0><code class=language->if (!IsChecked(_driver))</code></pre><ol start=8><li>첫번째 iframe -> 두번째 iframe 으로 접근합니다 ( iframe 간에는 바로 Switch가 불가능하며 본래 html로 복귀 이후 이동하여야 합니다 )
이후 buster button을 클릭합니다</li></ol><pre tabindex=0><code class=language-cs>_driver.SwitchTo().DefaultContent(); // 본래 html 로 복귀
_driver.SwitchTo().Frame(second);
_driver.Manage().Timeouts().ImplicitWait = TimeSpan.FromSeconds(200);
var busterHolder = _driver.FindElement(By.ClassName(&amp;#34;help-button-holder&amp;#34;));
busterHolder.Click();</code></pre><ol start=9><li>만약 리캡챠가 풀리지 않았다면 풀릴때까지 10회 반복합니다 ( 이미지 버튼을 클릭하여 Speech reload 이후 buster button click)</li></ol><pre tabindex=0><code class=language-cs>if (!IsChecked(_driver))
{
     _driver.SwitchTo().DefaultContent(); // 본래 html 로 복귀
     _driver.SwitchTo().Frame(second);
     _driver.FindElement(By.ClassName(&amp;#34;rc-button-image&amp;#34;)).Click();
     _driver.FindElement(By.ClassName(&amp;#34;help-button-holder&amp;#34;)).Click();
}
else
{
	isChecked=true;
    break;
}</code></pre><ol start=10><li>마지막으로 체크가 되었다면 토큰값을 반환합니다</li></ol><pre tabindex=0><code class=language-cs>if (isChecked)
{
    _driver.SwitchTo().DefaultContent(); 
    _driver.SwitchTo().Frame(second);
    _token = _driver.FindElement(By.Id(&amp;#34;recaptcha-token&amp;#34;)).GetAttribute(&amp;#34;value&amp;#34;);
    return _token;
}</code></pre><hr><h3 id=개선사항>개선사항<a hidden class=anchor aria-hidden=true href=#개선사항>#</a></h3><p>위의 프로젝트를 진행하면서 구글의 똑똑함을 다시한번 느꼈습니다. 만약 과금을 하더라도 Google speech-to-text 를 이용하였다면 높은 성공율으로 트래픽이 다소 많더라도 리캡챠를 풀 수 있었겠지만 그렇지 않았기에 결국 자동화된 프로그램으로 인식되어 Recaptcha가 밴 될수도 있다는 것을 알게 되었죠..</p><p>Google 의 Recaptcha v3 같은 경우에는 커서의 움직임이나 행동패턴을 통하여도 구분한다고 하는데 이 프로젝트를 고도화 한다 하여도 v3에는 아마 꼬리가 잡히지 않을까 합니다.</p><p>그래서 많은 ReCaptcha Solver API 가 실제 사람들을 고용하여 수동으로 풀고 토큰값을 반환하는게 아닐까 그런 생각도 들고 말이죠.</p><p>핵심적으로 위의 프로젝트에서 개선되어야 할점을 꼬집어 보자면 API로서의 역할을 하기에는 불완전 요소가 많다는 점입니다</p><blockquote><ol><li>Chrome 브라우저 버전과 Chrome driver 버전의 일치를 manually 하여야 한다는 점</li></ol></blockquote><ol start=2><li>트래픽이 많고 리캡챠의 실패가 잦아 질수록 구글에서의 리캡챠 밴이 될 확률이 높다는 점</li><li>리캡챠가 풀리는 2분내에 로그인까지 완료가 되지 않을 수도 있다는 점</li></ol><p>이러한 점들이 있겠네요.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://dingyu.dev/tags/c%23/>C#</a></li><li><a href=https://dingyu.dev/tags/selenium/>Selenium</a></li><li><a href=https://dingyu.dev/tags/recaptcha/>Recaptcha</a></li><li><a href=https://dingyu.dev/tags/buster/>Buster</a></li></ul><nav class=paginav><a class=prev href=https://dingyu.dev/posts/fastapi-convention/><span class=title>« 이전 페이지</span><br><span>[Python] FastAPI Convention</span></a></nav></footer><div id=giscus_thread><script src=https://giscus.app/client.js data-repo=dings-things/blog data-repo-id=R_kgDON9IuAw data-category=Announcements data-category-id=DIC_kwDON9IuA84CnTai data-mapping=og:title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=ko data-loading=lazy crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://dingyu.dev/>Ding's Coding Forge</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="복사";function s(){t.innerHTML="복사 완료!",setTimeout(()=>{t.innerHTML="복사"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>
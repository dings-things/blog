<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[EDA] Kafka (MSK) Monitoring with Burrow Prometheus And Thanos | Ding's Coding Forge</title>
<meta name=keywords content="kafka,burrow,monitoring,prometheus,thanos,lag"><meta name=description content="People often rely solely on basic Kafka metrics like Input/Output Bytes, missing crucial insights into their event-driven architecture. This post demonstrates how to set up comprehensive topic-level monitoring for Kafka (AWS MSK) using Burrow, Prometheus, and Thanos. By combining Burrow for accurate consumer lag tracking, Prometheus for metric collection, and Thanos for long-term data storage and high availability, you'll achieve effective Kafka monitoring without the high costs and limitations of cloud-native solutions."><meta name=author content="dingyu"><link rel=canonical href=https://dingyu.dev/posts/dance-with-burrow/><meta name=google-site-verification content="8XY1hI6NVxQIrN7bQbnX-9TG9HHFw5HOQmlb6vcsFdQ"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.678f9035c217c5346e0b3de5bdc9ebac02c53b0502219858f8653d8d181c97b3.css integrity="sha256-Z4+QNcIXxTRuCz3lvcnrrALFOwUCIZhY+GU9jRgcl7M=" rel="preload stylesheet" as=style><link rel=icon href=https://dingyu.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dingyu.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dingyu.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://dingyu.dev/apple-touch-icon.png><link rel=mask-icon href=https://dingyu.dev/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://dingyu.dev/posts/dance-with-burrow/><link rel=alternate hreflang=en href=https://dingyu.dev/en/posts/dance-with-burrow/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-XH8830R9KK"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XH8830R9KK")}</script><meta property="og:url" content="https://dingyu.dev/posts/dance-with-burrow/"><meta property="og:site_name" content="Ding's Coding Forge"><meta property="og:title" content="[EDA] Kafka (MSK) Monitoring with Burrow Prometheus And Thanos"><meta property="og:description" content="People often rely solely on basic Kafka metrics like Input/Output Bytes, missing crucial insights into their event-driven architecture. This post demonstrates how to set up comprehensive topic-level monitoring for Kafka (AWS MSK) using Burrow, Prometheus, and Thanos. By combining Burrow for accurate consumer lag tracking, Prometheus for metric collection, and Thanos for long-term data storage and high availability, you'll achieve effective Kafka monitoring without the high costs and limitations of cloud-native solutions."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-21T00:00:00+00:00"><meta property="article:modified_time" content="2025-03-21T00:00:00+00:00"><meta property="article:tag" content="Kafka"><meta property="article:tag" content="Burrow"><meta property="article:tag" content="Monitoring"><meta property="article:tag" content="Prometheus"><meta property="article:tag" content="Thanos"><meta property="article:tag" content="Lag"><meta property="og:image" content="https://dingyu.dev/posts/dance-with-burrow/img/kafka.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dingyu.dev/posts/dance-with-burrow/img/kafka.png"><meta name=twitter:title content="[EDA] Kafka (MSK) Monitoring with Burrow Prometheus And Thanos"><meta name=twitter:description content="People often rely solely on basic Kafka metrics like Input/Output Bytes, missing crucial insights into their event-driven architecture. This post demonstrates how to set up comprehensive topic-level monitoring for Kafka (AWS MSK) using Burrow, Prometheus, and Thanos. By combining Burrow for accurate consumer lag tracking, Prometheus for metric collection, and Thanos for long-term data storage and high availability, you'll achieve effective Kafka monitoring without the high costs and limitations of cloud-native solutions."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://dingyu.dev/posts/"},{"@type":"ListItem","position":2,"name":"[EDA] Kafka (MSK) Monitoring with Burrow Prometheus And Thanos","item":"https://dingyu.dev/posts/dance-with-burrow/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[EDA] Kafka (MSK) Monitoring with Burrow Prometheus And Thanos","name":"[EDA] Kafka (MSK) Monitoring with Burrow Prometheus And Thanos","description":"People often rely solely on basic Kafka metrics like Input/Output Bytes, missing crucial insights into their event-driven architecture. This post demonstrates how to set up comprehensive topic-level monitoring for Kafka (AWS MSK) using Burrow, Prometheus, and Thanos. By combining Burrow for accurate consumer lag tracking, Prometheus for metric collection, and Thanos for long-term data storage and high availability, you'll achieve effective Kafka monitoring without the high costs and limitations of cloud-native solutions.","keywords":["kafka","burrow","monitoring","prometheus","thanos","lag"],"articleBody":"배경 비동기 프로그래밍과 동기 프로그래밍의 가장 큰 트레이드오프(Trade-off)를 꼽자면, 성능을 확보하는 대신 추적이 어려워진다는 점이다.\nKafka를 활용한 이벤트 기반 아키텍처(EDA, Event-Driven Architecture)에서도 마찬가지로, 비동기적으로 처리되는 데이터의 흐름을 실시간으로 파악하는 것은 쉽지 않다.\n특히 이슈가 발생한 후에야 문제를 인지하는 상황이 반복되면서, Kafka 모니터링의 필요성이 더욱 절실해졌다.\n이벤트 기반 시스템에서 중요한 것은 퍼포먼스(Performance) 모니터링이다.\nREST API 기반의 아키텍처에서는 CPU/메모리 사용량 및 요청량을 기반으로 Kubernetes Horizontal Pod Autoscaler(HPA)를 이용해 트래픽을 견디는 방식이 일반적이다.\n그러나 Kafka 기반 아키텍처에서는 파티션(Partition)의 개수와 Consumer의 처리 속도가 성능을 결정하는 핵심 요소다.\n만약 파티션이 적거나 Consumer의 처리 속도가 느려 Lag이 발생한다면?\n→ 개발자가 직접 퍼포먼스를 분석하고, 파티션 확장(Partition Scaling) 및 Consumer 증설(Scale-out)을 수행해야 한다.\n이러한 문제를 사전에 감지하고 해결할 수 있도록 Kafka 모니터링 시스템을 구축하게 되었다.\nKafka의 성능을 모니터링하는 방법으로 아래 3가지 옵션을 고려했다.\n설계 Kafka 모니터링 솔루션 비교 AWS CloudWatch AWS에서 제공하는 CloudWatch의 Kafka 모니터링 기능을 사용하면\nPER_TOPIC_PER_PARTITION 단위로 지표를 수집할 수 있다.\n주요 모니터링 지표 지표명 (AWS/MSK) 설명 EstimatedTimeLag Consumer Group이 데이터를 소비한 후, 파티션의 Offset 지연시간(초) OffsetLag Consumer Group이 데이터를 소비한 후, 파티션의 Offset 지연 개수 항목 설명 ✅ 간편한 설정 AWS MSK와 기본 연동 가능 ✅ CloudWatch Alarm + SNS 활용 가능 손쉽게 경고(Alert) 설정 가능 ❌ AWS 콘솔에서만 데이터 확인 가능 외부 모니터링 툴과 연동 어려움 ❌ 비용 부담 토픽 수준 모니터링은 추가 비용 발생 EKS 기반 Helm 모니터링 (사내 솔루션, 실패) 기존에 사내에서 운영 중인 Helm Chart를 활용하여 Kafka 모니터링을 시도했으나,\nMSK와 EKS가 서로 다른 리전에 존재하여 사용이 불가능했다.\n항목 설명 ✅ 사내 시스템과 통합 가능 사내 시스템과 원활한 연동 가능 ❌ MSK와 EKS가 서로 다른 리전에 위치 연동 불가 문제 발생 ❌ EKS를 MSK와 동일 리전에 구축할 경우 비용 부담 발생 추가적인 비용이 발생할 수 있음 결과적으로 도입을 포기하게 되었다.\nEC2 기반 Docker Compose 모니터링 (최종 채택) 결국, MSK와 동일한 VPC 내에 EC2를 배포하고 Kafka 모니터링 스택을 직접 구성하는 방식을 선택했다.\nJMX Exporter \u0026 Node Exporter를 활용하여 Kafka 메트릭 수집 Burrow를 활용하여 Consumer Lag 모니터링 Thanos 및 Prometheus를 통해 장기적인 모니터링 가능 항목 설명 ✅ 비용 효율성 저렴한 T 시리즈 EC2 인스턴스를 활용하여 운영 가능 ✅ 확장성 커스터마이징이 자유로우며 필요에 따라 확장 가능 ✅ 보다 세밀한 Kafka 모니터링 가능 Burrow를 활용하여 Consumer Lag 추적 가능 ❌ 초기 세팅 부담 직접 설정해야 하며 시행착오가 발생할 가능성이 있음 ❌ Burrow 및 Thanos 운영 경험 부족 팀 내에서 Kafka 모니터링 노드를 운영한 경험이 없어 직접 해결해야 했음 오히려 좋아..! 바닥부터 새롭게 알아갈 수 있다는 것이 오히려 장점이 되어 EC2 기반 모니터링을 직접 구축하기로 했다\n아키텍처 구성하기 MSK 관련 배경 정보 zookeeper: 카프카의 메타 데이터 정보를 주키퍼에 저장하고, 카프카의 상태를 관리 broker: 카프카가 설치되어 있는 서버 또는 노드 JMX Exporter: JMX(Java Management Extensions) Exporter를 사용하여 Apache Kafka(브로커, 프로듀서, 컨슈머)의 성능과 상태를 모니터링할 수 있도록 다양한 메트릭을 제공 Node Exporter: Node Exporter를 사용하여 CPU 및 디스크 메트릭 노출이 가능 Kafka 모니터링 아키텍처 발전 과정: Prometheus, Thanos, Burrow 연동 Kafka 모니터링 시스템을 구축하는 과정에서 Prometheus 단독 운영(V1) → Thanos를 통한 확장(V2) → Burrow를 활용한 Kafka Consumer 모니터링 추가(V3)로 발전해 나갔다.\n각 버전별 아키텍처를 비교하며, 각 접근 방식의 장단점을 정리한다.\nV1: Prometheus 단독 구성으로 Metric 수집 Prometheus를 이용하여 Kafka 메트릭을 수집하고, Grafana에서 CloudWatch와 Prometheus를 데이터 소스로 추가하여 모니터링을 진행했다.\n구성 아키텍처 Pros (장점) Prometheus만 설정하면 별도 복잡한 설정 없이 Kafka 모니터링 가능 Grafana에서 Prometheus와 CloudWatch를 동시에 활용 가능하여 메트릭 비교 가능 Cons (단점) Prometheus가 다운되면 모니터링 시스템 전체가 중단되며, Single Point of Failure (SPOF) 문제가 발생 Prometheus는 모든 메트릭을 메모리(TSDB)에서 처리하므로, 수집하는 메트릭이 많아질수록 메모리 사용량 급증 TSDB의 크기가 증가할수록 Prometheus의 성능 저하 및 장애 가능성 증가 V2: Prometheus + Thanos Sidecar 구성으로 HA 보장 고가용성을 확보하기 위해 2대의 Prometheus 인스턴스를 운영하고, Thanos Sidecar를 추가하여 Thanos 중앙 서버(Query + Store)와 연동했다.\n구성 아키텍처 Thanos를 도입한 이유 Prometheus의 중복 적재 방지: N대의 Prometheus가 동일한 Metric을 수집할 경우, Thanos Query가 중복 데이터를 제거(Deduplication)하여 처리 TSDB 단기 저장(Short-term) + Thanos Store 장기 저장(Long-term) 분리: Prometheus는 단기적인 메트릭만 보관하고, 장기적인 데이터는 Thanos Store(S3 등)에 저장하여 복구 가능 Prometheus의 TSDB 크기를 줄일 수 있어, 메모리 사용량 감소 및 비용 절감 가능 Pros (장점) 고가용성(HA) 확보: 2대의 Prometheus + Thanos Query 구성으로 Prometheus 한 대가 장애가 나더라도 모니터링 지속 가능 장기적인 데이터 보존 가능: Prometheus TSDB는 단기 데이터만 저장하고, 장기 데이터는 Thanos Store에 저장 가능하여 S3, GCS 등 Object Storage를 활용하여 저비용으로 장기 보존 가능 Prometheus 리소스 최적화 가능: Prometheus의 TSDB 크기를 줄일 수 있어, 메모리 사용량 감소로 비용 절감 가능 Cons (단점) Thanos 추가 구성 필요로 인해 운영 복잡도 증가: 기존 Prometheus 단독 운영보다 Thanos Sidecar, Query, Store 설정이 추가로 필요하며, Thanos Store를 위한 Object Storage(S3 등) 연동이 필요함 Thanos Query의 성능 한계: 여러 Prometheus 인스턴스에서 메트릭을 조회하는데, 과도한 요청이 발생하면 성능 저하 가능성 있음 V3: Burrow + Prometheus + Thanos Sidecar로 Kafka Consumer 모니터링 강화 비용 절감 및 Kafka Consumer Lag 모니터링을 강화하기 위해, CloudWatch 대신 Burrow를 도입하여 Kafka Consumer 메트릭을 수집했다.\nCloudWatch를 걷어내고, Burrow + Prometheus + Thanos로 Kafka 모니터링을 최적화하였다.\n구성 아키텍처 burrow가 주기적으로 kafka Consumer 메트릭을 수집하고, prometheus가 burrow metric을 수집하도록 하여 최종적으로 thanos query가 thanos-sidecar를 통해 kafka 관련 메트릭을 모두 수집하도록 구성\nBurrow를 도입한 이유 CloudWatch 비용 절감: Kafka 모니터링을 CloudWatch에서 Burrow + Prometheus로 전환하여 비용 절감 가능 Kafka Consumer Lag 모니터링 강화: Burrow는 Kafka Consumer Group의 Offset 정보를 실시간으로 수집하며, Consumer Lag을 모니터링하여 Kafka가 정상적으로 동작하는지 추적 가능 ACL(Access Control) 기반 모니터링 가능: CloudWatch는 Kafka ACL을 기반으로 세부적인 Consumer 모니터링이 어려운 반면, Burrow는 Consumer Group 및 Topic 별로 상세한 Lag 정보를 제공 Pros (장점) CloudWatch 비용 절감: Kafka 모니터링을 CloudWatch에서 Burrow + Prometheus로 전환하여 비용 절감 가능 Kafka Consumer Group의 상세 모니터링 가능: Burrow를 통해 각 Consumer의 Offset, Lag, Partition 상태까지 상세 분석 가능 기존 Prometheus + Thanos와 원활한 연동 가능: Burrow에서 /metrics 엔드포인트를 제공하여, Prometheus에서 손쉽게 데이터 수집 가능하며, Thanos Query를 통해 Kafka 관련 메트릭을 Grafana에서 단일 인터페이스로 조회 가능 Cons (단점) Burrow 초기 설정 및 운영 부담 증가: Burrow는 Kafka Consumer Lag을 모니터링하는 강력한 도구지만, 처음 설정할 때 Kafka 클러스터와 연동하는 과정이 필요하며, Kafka ACL이 적용된 환경에서는 Burrow의 접근 권한 설정이 필요함 Burrow의 자체 Alerting 기능 한계: Burrow는 기본적으로 Alert 기능을 제공하지만, Prometheus Alertmanager보다 유연하지 않아 Prometheus Alertmanager 또는 Grafana Alerta와 함께 사용해야 효과적임 버전 별 정리 아키텍처 장점 단점 최종 평가 V1: Prometheus 단독 빠른 구성 가능, 별도 설정 불필요 고가용성 보장 안됨, 메모리 사용량 과다 SPOF 문제로 비효율적 V2: Prometheus + Thanos Sidecar 고가용성(HA) 확보, 장기 데이터 저장 가능, 메모리 최적화 가능 Thanos 추가 구성 필요, 운영 복잡도 증가 장기 저장 및 확장 가능 V3: Burrow + Prometheus + Thanos CloudWatch 비용 절감, Kafka Consumer 상세 모니터링, 기존 Prometheus 연동 가능 Burrow 설정 필요, Alert 기능 부족 최종 채택 Kafka 모니터링을 효과적으로 수행하기 위해, Burrow + Prometheus + Thanos를 조합하여 Kafka Consumer Lag까지 포함한 종합적인 모니터링 시스템을 구축하는 것이 최적의 해결책이었다.\n구현 Burrow Kafka Consumer Lag Monitoring with Burrow Kafka client의 consumer에서 metrics() 메서드를 사용하여 records-lag-max를 기록할 수 있지만, 가장 뒤처진 파티션의 지연만을 보여주므로 전체 상태 파악이 어렵다. 또한, consumer가 멈추면 lag을 감지할 수 없어 외부 모니터링 시스템이 필요하다. 이를 해결하는 대표적인 솔루션이 LinkedIn의 Burrow이다.\nBurrow: Kafka Consumer Monitoring Reinvented\nConsumer A: lag이 지속적으로 감소 → 정상 Consumer B: lag이 일시적으로 증가했으나 복구됨 → 정상 Consumer C: lag이 일정하게 유지됨 → 정상 Consumer D: lag이 일시적으로 증가했으나 복구됨 → 정상적인 트래픽 처리 Kafka Lag Threshold의 문제점 임계값(threshold) 기반 감지는 오탐 가능성이 높다. 예를 들어, threshold를 250으로 설정하면 실제 정상적으로 동작하는 B, D도 이상 상태로 감지될 수 있다.\n⚠️ Kafka consumer의 MaxLag 값만으로 장애 여부를 판단할 수 없다!\nBurrow는 어떻게 해결하는가? Burrow는 Kafka 내부의 consumer offset을 기록하는 토픽을 읽어 개별 consumer 상태를 독립적으로 평가한다. 특정 consumer에 종속되지 않으며, 모든 consumer를 자동으로 모니터링하여 객관적인 상태 분석이 가능하다.\nBurrow의 동작 방식 Burrow는 sliding window 기법을 활용하여 최근 N개의 offset commit을 분석한다. LinkedIn에서는 10개의 offset commit(약 10분)을 기준으로 다음을 평가한다:\nConsumer가 지속적으로 offset을 커밋하는가? Consumer offset이 증가하고 있는가? Lag이 증가하고 있는가? Lag 증가 패턴이 지속적인가? 이를 기반으로 consumer 상태를 다음과 같이 분류한다:\n✅ OK: 정상 작동 ⚠️ Warning: lag이 증가하는 상태 ❌ Error: consumer가 멈추거나 동작이 중단됨 Burrow는 임계값 없이 패턴 분석을 통해 자동으로 이상 감지하며, HTTP API 및 알림 시스템을 통해 정보를 제공한다.\nBurrow API 예제 GET /v2/kafka/local/consumer/dingyu/status consumer의 현재 상태와 문제가 발생한 topic과 partition 정보를 확인할 수 있다.\n연동 방안 1. 사전 준비 OS: Amazon Linux 2 또는 Ubuntu 20.04 이상 Docker 및 Docker Compose 설치 EC2 보안 그룹에서 다음 포트 허용 Prometheus: 9090 Thanos Sidecar: 10901, 10902 Burrow: 8000 2. 패키지 설치 # Docker 설치 sudo yum install -y docker sudo systemctl enable docker --now # Docker Compose 설치 sudo curl -L \"https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose 3. 폴더 구조 MSK-MONITORING/ │── templates/ # 설정 템플릿 폴더 │ ├── burrow.tmpl.toml # Burrow 설정 템플릿 │ ├── prometheus.tmpl.yaml # Prometheus 설정 템플릿 │ ├── targets.tmpl.json # Prometheus 타겟 설정 템플릿 │── deploy.sh # 배포 스크립트 │── docker-compose.yaml # Docker Compose 설정 파일 │── Makefile # 설정 렌더링 및 빌드 관리 │── README.md # 프로젝트 문서 4. 주요 구성 요소 4.1 Burrow Kafka Consumer 상태를 모니터링하는 도구 burrow.tmpl.toml 파일을 기반으로 환경 변수를 대체하여 설정 SASL/TLS 인증을 사용하여 MSK에 연결 HTTP 서버를 통해 상태 제공 Burrow 관련 트러블슈팅 SASL 인증을 하는 경우, 레퍼런스가 전혀 없어서 무한 삽질을 거듭하였다\nTLS의 경우 인증을 하지 않아 별도로 설정하지 않았으나, skip verify 옵션으로 무조건 필요했다\n이 부분은 sarama client 생성 시, config를 고쳐 가며 디버깅을 거듭했다\nSASL Mechanism은 SCRAM-SHA-512/SCRAM-SHA-256을 지원한다! MSK에서 어떠한 Mechanism으로 설정하였는지 필히 확인하자\n4.2 Prometheus Kafka 및 Burrow 메트릭 수집 prometheus.tmpl.yaml을 기반으로 환경 변수 대체 후 설정 targets.tmpl.json을 통해 JMX 및 Node Exporter 메트릭 수집 4.3 Docker Compose docker-compose.yaml을 사용하여 Burrow, Prometheus, Thanos Sidecar 컨테이너 실행 컨테이너 간 네트워크를 구성하여 원활한 통신 지원 4.4 Makefile make render: 환경 변수를 반영하여 설정 파일을 생성 (generated/ 디렉토리) 4.5 환경 변수 관리 환경 변수는 아래 example 처럼 docker-compose와 같은 디렉토리에 .env 형태로 관리하세요\nPROM_CLUSTER={your-cluster-name} PROMETHEUS_PORT=9090 BURROW_PORT=8000 ZOOKEEPER_HOST_1={zookeeper1_endpoint} ZOOKEEPER_HOST_2={zookeeper2_endpoint} ZOOKEEPER_HOST_3={zookeeper3_endpoint} BROKER_HOST_1={broker1_endpoint} BROKER_HOST_2={broker2_endpoint} BROKER_HOST_3={broker3_endpoint} BURROW_USERNAME={user} BURROW_PASSWORD={password} 5. 설치 및 실행 방법 5.1 프로젝트 클론 git clone https://github.com/dings-things/msk-monitoring-docker-compose.git cd msk-monitoring-docker-compose 5.2 환경 변수 설정 .env 파일을 생성\n5.3 배포 스크립트 실행 chmod +x deploy.sh ./deploy.sh 5.4 개별 실행 (수동 실행) make render docker compose up -d 배포 프로세스 자세한 사용법은 github 참고 !\n실무 환경에서는 gitlab snippets를 사용하여 환경 변수를 snippets API를 통해 불러와 환경 별로 매핑합니다.\n대시보드 구성하기 꼭 구성해야 하는 중요한 지표를 아래와 같이 분류하였다\nTopic/Partition 별 Status Check : 특정 토픽, 파티션의 이상 여부 확인 burrow_kafka_topic_partition_status 지표 활용 Disk Usage : Disk 임계치 초과 시 Alert 설정 (증설) node_filesystem_avail_bytes 지표 활용 (현재 남아있는 공간(avail_bytes) 을 전체 디스크 용량(size_bytes) 과 비교하여 사용된 비율을 계산) CPU Usage : CPU 임계치 초과 시 Alert 설정 (파티션 증설) node_cpu_seconds_total 지표 활용 (user[kafka]사용 CPU, 전체 - idle[유휴] CPU 확인) Consumer Group Status Check : 컨슈머 그룹(애플리케이션) 상태 체크 burrow_kafka_consumer_status 지표 활용 Consumer Group/Topic Lag : 컨슈머 그룹 / 토픽 별 쌓인 Lag 체크 burrow_kafka_consumer_partition_lag 지표 활용 Lag Per Partition : 파티션 별 쌓인 Lag 체크 burrow_kafka_consumer_partition_lag 지표 Table 활용 Current Offset : 현재 컨슈머 그룹이 처리하고 있는 최근 Offset burrow_kafka_consumer_status 지표 활용 최종 구성 REFS Burrow 공식 문서 Prometheus 공식 문서 Prometheus 를 스케일링 하기 위한 Thanos AWS MSK Connect 효과적으로 운영하기 여기어때 MSK 모니터링 구축해볼까요? ","wordCount":"1803","inLanguage":"ko","image":"https://dingyu.dev/posts/dance-with-burrow/img/kafka.png","datePublished":"2025-03-21T00:00:00Z","dateModified":"2025-03-21T00:00:00Z","author":{"@type":"Person","name":"dingyu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://dingyu.dev/posts/dance-with-burrow/"},"publisher":{"@type":"Organization","name":"Ding's Coding Forge","logo":{"@type":"ImageObject","url":"https://dingyu.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dingyu.dev/ accesskey=h title="Ding's Coding Forge (Alt + H)"><img src=https://dingyu.dev/apple-touch-icon.png alt aria-label=logo height=35>Ding's Coding Forge</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button><span class=nav-separator>|</span><div class=lang-select-dropdown><button class=lang-select-dropdown-trigger aria-label=번역 type=button><svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 512 512" width="24" height="18"><path d="M478.33 433.6l-90-218a22 22 0 00-40.67.0l-90 218a22 22 0 1040.67 16.79L316.66 406h102.67l18.33 44.39A22 22 0 00458 464a22 22 0 0020.32-30.4zM334.83 362 368 281.65 401.17 362z" fill="currentcolor"/><path d="M267.84 342.92a22 22 0 00-4.89-30.7c-.2-.15-15-11.13-36.49-34.73 39.65-53.68 62.11-114.75 71.27-143.49H330a22 22 0 000-44H214V70a22 22 0 00-44 0v20H54a22 22 0 000 44h197.25c-9.52 26.95-27.05 69.5-53.79 108.36-31.41-41.68-43.08-68.65-43.17-68.87a22 22 0 00-40.58 17c.58 1.38 14.55 34.23 52.86 83.93.92 1.19 1.83 2.35 2.74 3.51-39.24 44.35-77.74 71.86-93.85 80.74a22 22 0 1021.07 38.63c2.16-1.18 48.6-26.89 101.63-85.59 22.52 24.08 38 35.44 38.93 36.1a22 22 0 0030.75-4.9z" fill="currentcolor"/></svg></button><div class=lang-select-dropdown-content><a lang=en href=https://dingyu.dev/en/ title=English aria-label=English>English</a></div></div></div></div><ul id=menu><li><a href=https://dingyu.dev/about/ title=소개><span>소개</span></a></li><li><a href=https://dingyu.dev/categories/ title=카테고리><span>카테고리</span></a></li><li><a href=https://dingyu.dev/tags/ title=태그><span>태그</span></a></li><li><a href=https://dingyu.dev/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://dingyu.dev/search/ title="검색 (Alt + /)" accesskey=/><span>검색</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://dingyu.dev/>홈</a>&nbsp;»&nbsp;<a href=https://dingyu.dev/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">[EDA] Kafka (MSK) Monitoring with Burrow Prometheus And Thanos</h1><div class=post-description>People often rely solely on basic Kafka metrics like Input/Output Bytes, missing crucial insights into their event-driven architecture. This post demonstrates how to set up comprehensive topic-level monitoring for Kafka (AWS MSK) using Burrow, Prometheus, and Thanos. By combining Burrow for accurate consumer lag tracking, Prometheus for metric collection, and Thanos for long-term data storage and high availability, you'll achieve effective Kafka monitoring without the high costs and limitations of cloud-native solutions.</div><div class=post-meta><span title='2025-03-21 00:00:00 +0000 UTC'>3월 21, 2025</span>&nbsp;·&nbsp;9 분&nbsp;·&nbsp;1803 단어&nbsp;·&nbsp;dingyu&nbsp;|&nbsp;번역:<ul class=i18n_list><li><a href=https://dingyu.dev/en/posts/dance-with-burrow/>En</a></li></ul>&nbsp;|&nbsp;<a href=https://github.com/dings-things/blog/tree/main/content/posts/dance-with-burrow/index.ko.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://dingyu.dev/img/kafka.png alt></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><ul><li><a href=#%eb%b0%b0%ea%b2%bd aria-label=배경>배경</a></li><li><a href=#%ec%84%a4%ea%b3%84 aria-label=설계>설계</a><ul><li><a href=#kafka-%eb%aa%a8%eb%8b%88%ed%84%b0%eb%a7%81-%ec%86%94%eb%a3%a8%ec%85%98-%eb%b9%84%ea%b5%90 aria-label="Kafka 모니터링 솔루션 비교">Kafka 모니터링 솔루션 비교</a><ul><li><a href=#aws-cloudwatch aria-label="AWS CloudWatch">AWS CloudWatch</a><ul><li><a href=#%ec%a3%bc%ec%9a%94-%eb%aa%a8%eb%8b%88%ed%84%b0%eb%a7%81-%ec%a7%80%ed%91%9c aria-label="주요 모니터링 지표"><strong>주요 모니터링 지표</strong></a></li></ul></li><li><a href=#eks-%ea%b8%b0%eb%b0%98-helm-%eb%aa%a8%eb%8b%88%ed%84%b0%eb%a7%81-%ec%82%ac%eb%82%b4-%ec%86%94%eb%a3%a8%ec%85%98-%ec%8b%a4%ed%8c%a8 aria-label="EKS 기반 Helm 모니터링 (사내 솔루션, 실패)">EKS 기반 Helm 모니터링 (사내 솔루션, 실패)</a></li><li><a href=#ec2-%ea%b8%b0%eb%b0%98-docker-compose-%eb%aa%a8%eb%8b%88%ed%84%b0%eb%a7%81-%ec%b5%9c%ec%a2%85-%ec%b1%84%ed%83%9d aria-label="EC2 기반 Docker Compose 모니터링 (최종 채택)">EC2 기반 Docker Compose 모니터링 (최종 채택)</a></li></ul></li><li><a href=#%ec%95%84%ed%82%a4%ed%85%8d%ec%b2%98-%ea%b5%ac%ec%84%b1%ed%95%98%ea%b8%b0 aria-label="아키텍처 구성하기">아키텍처 구성하기</a><ul><ul><li><a href=#msk-%ea%b4%80%eb%a0%a8-%eb%b0%b0%ea%b2%bd-%ec%a0%95%eb%b3%b4 aria-label="MSK 관련 배경 정보">MSK 관련 배경 정보</a></li><li><a href=#kafka-%eb%aa%a8%eb%8b%88%ed%84%b0%eb%a7%81-%ec%95%84%ed%82%a4%ed%85%8d%ec%b2%98-%eb%b0%9c%ec%a0%84-%ea%b3%bc%ec%a0%95-prometheus-thanos-burrow-%ec%97%b0%eb%8f%99 aria-label="Kafka 모니터링 아키텍처 발전 과정: Prometheus, Thanos, Burrow 연동">Kafka 모니터링 아키텍처 발전 과정: Prometheus, Thanos, Burrow 연동</a></li></ul><li><a href=#v1-prometheus-%eb%8b%a8%eb%8f%85-%ea%b5%ac%ec%84%b1%ec%9c%bc%eb%a1%9c-metric-%ec%88%98%ec%a7%91 aria-label="V1: Prometheus 단독 구성으로 Metric 수집">V1: Prometheus 단독 구성으로 Metric 수집</a><ul><li><a href=#%ea%b5%ac%ec%84%b1-%ec%95%84%ed%82%a4%ed%85%8d%ec%b2%98 aria-label="구성 아키텍처">구성 아키텍처</a></li><li><a href=#pros-%ec%9e%a5%ec%a0%90 aria-label="Pros (장점)">Pros (장점)</a></li><li><a href=#cons-%eb%8b%a8%ec%a0%90 aria-label="Cons (단점)">Cons (단점)</a></li></ul></li><li><a href=#v2-prometheus--thanos-sidecar-%ea%b5%ac%ec%84%b1%ec%9c%bc%eb%a1%9c-ha-%eb%b3%b4%ec%9e%a5 aria-label="V2: Prometheus + Thanos Sidecar 구성으로 HA 보장">V2: Prometheus + Thanos Sidecar 구성으로 HA 보장</a><ul><li><a href=#%ea%b5%ac%ec%84%b1-%ec%95%84%ed%82%a4%ed%85%8d%ec%b2%98-1 aria-label="구성 아키텍처">구성 아키텍처</a></li><li><a href=#thanos%eb%a5%bc-%eb%8f%84%ec%9e%85%ed%95%9c-%ec%9d%b4%ec%9c%a0 aria-label="Thanos를 도입한 이유">Thanos를 도입한 이유</a></li><li><a href=#pros-%ec%9e%a5%ec%a0%90-1 aria-label="Pros (장점)">Pros (장점)</a></li><li><a href=#cons-%eb%8b%a8%ec%a0%90-1 aria-label="Cons (단점)">Cons (단점)</a></li></ul></li><li><a href=#v3-burrow--prometheus--thanos-sidecar%eb%a1%9c-kafka-consumer-%eb%aa%a8%eb%8b%88%ed%84%b0%eb%a7%81-%ea%b0%95%ed%99%94 aria-label="V3: Burrow + Prometheus + Thanos Sidecar로 Kafka Consumer 모니터링 강화">V3: Burrow + Prometheus + Thanos Sidecar로 Kafka Consumer 모니터링 강화</a><ul><li><a href=#%ea%b5%ac%ec%84%b1-%ec%95%84%ed%82%a4%ed%85%8d%ec%b2%98-2 aria-label="구성 아키텍처">구성 아키텍처</a></li><li><a href=#burrow%eb%a5%bc-%eb%8f%84%ec%9e%85%ed%95%9c-%ec%9d%b4%ec%9c%a0 aria-label="Burrow를 도입한 이유">Burrow를 도입한 이유</a></li><li><a href=#pros-%ec%9e%a5%ec%a0%90-2 aria-label="Pros (장점)">Pros (장점)</a></li><li><a href=#cons-%eb%8b%a8%ec%a0%90-2 aria-label="Cons (단점)">Cons (단점)</a></li></ul></li><li><a href=#%eb%b2%84%ec%a0%84-%eb%b3%84-%ec%a0%95%eb%a6%ac aria-label="버전 별 정리">버전 별 정리</a></li></ul></li></ul></li><li><a href=#%ea%b5%ac%ed%98%84 aria-label=구현>구현</a><ul><li><a href=#burrow aria-label=Burrow>Burrow</a><ul><li><a href=#kafka-consumer-lag-monitoring-with-burrow aria-label="Kafka Consumer Lag Monitoring with Burrow">Kafka Consumer Lag Monitoring with Burrow</a></li><li><a href=#kafka-lag-threshold%ec%9d%98-%eb%ac%b8%ec%a0%9c%ec%a0%90 aria-label="Kafka Lag Threshold의 문제점">Kafka Lag Threshold의 문제점</a></li><li><a href=#burrow%eb%8a%94-%ec%96%b4%eb%96%bb%ea%b2%8c-%ed%95%b4%ea%b2%b0%ed%95%98%eb%8a%94%ea%b0%80 aria-label="Burrow는 어떻게 해결하는가?">Burrow는 어떻게 해결하는가?</a><ul><li><a href=#burrow%ec%9d%98-%eb%8f%99%ec%9e%91-%eb%b0%a9%ec%8b%9d aria-label="Burrow의 동작 방식">Burrow의 동작 방식</a></li><li><a href=#burrow-api-%ec%98%88%ec%a0%9c aria-label="Burrow API 예제">Burrow API 예제</a></li></ul></li></ul></li><li><a href=#%ec%97%b0%eb%8f%99-%eb%b0%a9%ec%95%88 aria-label="연동 방안">연동 방안</a><ul><li><a href=#1-%ec%82%ac%ec%a0%84-%ec%a4%80%eb%b9%84 aria-label="1. 사전 준비">1. 사전 준비</a></li><li><a href=#2-%ed%8c%a8%ed%82%a4%ec%a7%80-%ec%84%a4%ec%b9%98 aria-label="2. 패키지 설치">2. 패키지 설치</a></li><li><a href=#3-%ed%8f%b4%eb%8d%94-%ea%b5%ac%ec%a1%b0 aria-label="3. 폴더 구조">3. 폴더 구조</a></li><li><a href=#4-%ec%a3%bc%ec%9a%94-%ea%b5%ac%ec%84%b1-%ec%9a%94%ec%86%8c aria-label="4. 주요 구성 요소">4. 주요 구성 요소</a><ul><li><a href=#41-burrow aria-label="4.1 Burrow">4.1 Burrow</a></li><li><a href=#burrow-%ea%b4%80%eb%a0%a8-%ed%8a%b8%eb%9f%ac%eb%b8%94%ec%8a%88%ed%8c%85 aria-label="Burrow 관련 트러블슈팅">Burrow 관련 트러블슈팅</a></li><li><a href=#42-prometheus aria-label="4.2 Prometheus">4.2 Prometheus</a></li><li><a href=#43-docker-compose aria-label="4.3 Docker Compose">4.3 Docker Compose</a></li><li><a href=#44-makefile aria-label="4.4 Makefile">4.4 Makefile</a></li><li><a href=#45-%ed%99%98%ea%b2%bd-%eb%b3%80%ec%88%98-%ea%b4%80%eb%a6%ac aria-label="4.5 환경 변수 관리">4.5 환경 변수 관리</a></li></ul></li><li><a href=#5-%ec%84%a4%ec%b9%98-%eb%b0%8f-%ec%8b%a4%ed%96%89-%eb%b0%a9%eb%b2%95 aria-label="5. 설치 및 실행 방법">5. 설치 및 실행 방법</a><ul><li><a href=#51-%ed%94%84%eb%a1%9c%ec%a0%9d%ed%8a%b8-%ed%81%b4%eb%a1%a0 aria-label="5.1 프로젝트 클론">5.1 프로젝트 클론</a></li><li><a href=#52-%ed%99%98%ea%b2%bd-%eb%b3%80%ec%88%98-%ec%84%a4%ec%a0%95 aria-label="5.2 환경 변수 설정">5.2 환경 변수 설정</a></li><li><a href=#53-%eb%b0%b0%ed%8f%ac-%ec%8a%a4%ed%81%ac%eb%a6%bd%ed%8a%b8-%ec%8b%a4%ed%96%89 aria-label="5.3 배포 스크립트 실행">5.3 배포 스크립트 실행</a></li><li><a href=#54-%ea%b0%9c%eb%b3%84-%ec%8b%a4%ed%96%89-%ec%88%98%eb%8f%99-%ec%8b%a4%ed%96%89 aria-label="5.4 개별 실행 (수동 실행)">5.4 개별 실행 (수동 실행)</a></li></ul></li><li><a href=#%eb%b0%b0%ed%8f%ac-%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4 aria-label="배포 프로세스">배포 프로세스</a></li></ul></li><li><a href=#%eb%8c%80%ec%8b%9c%eb%b3%b4%eb%93%9c-%ea%b5%ac%ec%84%b1%ed%95%98%ea%b8%b0 aria-label="대시보드 구성하기">대시보드 구성하기</a></li></ul></li><li><a href=#%ec%b5%9c%ec%a2%85-%ea%b5%ac%ec%84%b1 aria-label="최종 구성">최종 구성</a><ul><li><a href=#refs aria-label=REFS>REFS</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=배경>배경<a hidden class=anchor aria-hidden=true href=#배경>#</a></h1><p>비동기 프로그래밍과 동기 프로그래밍의 가장 큰 트레이드오프(Trade-off)를 꼽자면, 성능을 확보하는 대신 <strong>추적이 어려워진다</strong>는 점이다.</p><p>Kafka를 활용한 이벤트 기반 아키텍처(EDA, Event-Driven Architecture)에서도 마찬가지로, 비동기적으로 처리되는 데이터의 흐름을 실시간으로 파악하는 것은 쉽지 않다.<br>특히 이슈가 발생한 후에야 문제를 인지하는 상황이 반복되면서, Kafka 모니터링의 필요성이 더욱 절실해졌다.</p><p>이벤트 기반 시스템에서 중요한 것은 <strong>퍼포먼스(Performance) 모니터링</strong>이다.<br>REST API 기반의 아키텍처에서는 CPU/메모리 사용량 및 요청량을 기반으로 Kubernetes Horizontal Pod Autoscaler(HPA)를 이용해 트래픽을 견디는 방식이 일반적이다.<br>그러나 Kafka 기반 아키텍처에서는 <strong>파티션(Partition)의 개수와 Consumer의 처리 속도</strong>가 성능을 결정하는 핵심 요소다.</p><p>만약 <strong>파티션이 적거나 Consumer의 처리 속도가 느려 Lag이 발생</strong>한다면?<br>→ 개발자가 직접 퍼포먼스를 분석하고, <code>파티션 확장(Partition Scaling)</code> 및 <code>Consumer 증설(Scale-out)</code>을 수행해야 한다.</p><p>이러한 문제를 사전에 감지하고 해결할 수 있도록 <strong>Kafka 모니터링 시스템을 구축</strong>하게 되었다.</p><p>Kafka의 성능을 모니터링하는 방법으로 아래 3가지 옵션을 고려했다.</p><h1 id=설계>설계<a hidden class=anchor aria-hidden=true href=#설계>#</a></h1><h2 id=kafka-모니터링-솔루션-비교>Kafka 모니터링 솔루션 비교<a hidden class=anchor aria-hidden=true href=#kafka-모니터링-솔루션-비교>#</a></h2><h3 id=aws-cloudwatch>AWS CloudWatch<a hidden class=anchor aria-hidden=true href=#aws-cloudwatch>#</a></h3><p>AWS에서 제공하는 CloudWatch의 Kafka 모니터링 기능을 사용하면<br><strong>PER_TOPIC_PER_PARTITION</strong> 단위로 지표를 수집할 수 있다.</p><h4 id=주요-모니터링-지표><strong>주요 모니터링 지표</strong><a hidden class=anchor aria-hidden=true href=#주요-모니터링-지표>#</a></h4><table><thead><tr><th>지표명 (<code>AWS/MSK</code>)</th><th>설명</th></tr></thead><tbody><tr><td><code>EstimatedTimeLag</code></td><td>Consumer Group이 데이터를 소비한 후, 파티션의 Offset 지연시간(초)</td></tr><tr><td><code>OffsetLag</code></td><td>Consumer Group이 데이터를 소비한 후, 파티션의 Offset 지연 개수</td></tr></tbody></table><table><thead><tr><th>항목</th><th>설명</th></tr></thead><tbody><tr><td><strong>✅ 간편한 설정</strong></td><td>AWS MSK와 기본 연동 가능</td></tr><tr><td><strong>✅ CloudWatch Alarm + SNS 활용 가능</strong></td><td>손쉽게 경고(Alert) 설정 가능</td></tr><tr><td><strong>❌ AWS 콘솔에서만 데이터 확인 가능</strong></td><td>외부 모니터링 툴과 연동 어려움</td></tr><tr><td><strong>❌ 비용 부담</strong></td><td>토픽 수준 모니터링은 추가 비용 발생</td></tr></tbody></table><hr><h3 id=eks-기반-helm-모니터링-사내-솔루션-실패>EKS 기반 Helm 모니터링 (사내 솔루션, 실패)<a hidden class=anchor aria-hidden=true href=#eks-기반-helm-모니터링-사내-솔루션-실패>#</a></h3><p>기존에 사내에서 운영 중인 Helm Chart를 활용하여 Kafka 모니터링을 시도했으나,<br>MSK와 EKS가 <strong>서로 다른 리전에 존재</strong>하여 사용이 불가능했다.</p><table><thead><tr><th>항목</th><th>설명</th></tr></thead><tbody><tr><td><strong>✅ 사내 시스템과 통합 가능</strong></td><td>사내 시스템과 원활한 연동 가능</td></tr><tr><td><strong>❌ MSK와 EKS가 서로 다른 리전에 위치</strong></td><td>연동 불가 문제 발생</td></tr><tr><td><strong>❌ EKS를 MSK와 동일 리전에 구축할 경우 비용 부담 발생</strong></td><td>추가적인 비용이 발생할 수 있음</td></tr></tbody></table><p>결과적으로 도입을 포기하게 되었다.</p><hr><h3 id=ec2-기반-docker-compose-모니터링-최종-채택>EC2 기반 Docker Compose 모니터링 (최종 채택)<a hidden class=anchor aria-hidden=true href=#ec2-기반-docker-compose-모니터링-최종-채택>#</a></h3><p>결국, <strong>MSK와 동일한 VPC 내에 EC2를 배포하고 Kafka 모니터링 스택을 직접 구성</strong>하는 방식을 선택했다.</p><ul><li><strong>JMX Exporter & Node Exporter</strong>를 활용하여 Kafka 메트릭 수집</li><li><strong>Burrow를 활용하여 Consumer Lag 모니터링</strong></li><li><strong>Thanos 및 Prometheus를 통해 장기적인 모니터링 가능</strong></li></ul><table><thead><tr><th>항목</th><th>설명</th></tr></thead><tbody><tr><td><strong>✅ 비용 효율성</strong></td><td>저렴한 T 시리즈 EC2 인스턴스를 활용하여 운영 가능</td></tr><tr><td><strong>✅ 확장성</strong></td><td>커스터마이징이 자유로우며 필요에 따라 확장 가능</td></tr><tr><td><strong>✅ 보다 세밀한 Kafka 모니터링 가능</strong></td><td>Burrow를 활용하여 Consumer Lag 추적 가능</td></tr><tr><td><strong>❌ 초기 세팅 부담</strong></td><td>직접 설정해야 하며 시행착오가 발생할 가능성이 있음</td></tr><tr><td><strong>❌ Burrow 및 Thanos 운영 경험 부족</strong></td><td>팀 내에서 Kafka 모니터링 노드를 운영한 경험이 없어 직접 해결해야 했음</td></tr></tbody></table><p>오히려 좋아..! 바닥부터 새롭게 알아갈 수 있다는 것이 오히려 장점이 되어 EC2 기반 모니터링을 직접 구축하기로 했다</p><h2 id=아키텍처-구성하기>아키텍처 구성하기<a hidden class=anchor aria-hidden=true href=#아키텍처-구성하기>#</a></h2><blockquote><h4 id=msk-관련-배경-정보>MSK 관련 배경 정보<a hidden class=anchor aria-hidden=true href=#msk-관련-배경-정보>#</a></h4><ul><li><code>zookeeper</code>: 카프카의 메타 데이터 정보를 주키퍼에 저장하고, 카프카의 상태를 관리</li><li><code>broker</code>: 카프카가 설치되어 있는 서버 또는 노드</li><li><code>JMX Exporter</code>: JMX(Java Management Extensions) Exporter를 사용하여 Apache Kafka(브로커, 프로듀서, 컨슈머)의 성능과 상태를 모니터링할 수 있도록 다양한 메트릭을 제공</li><li><code>Node Exporter</code>: Node Exporter를 사용하여 CPU 및 디스크 메트릭 노출이 가능</li></ul></blockquote><h4 id=kafka-모니터링-아키텍처-발전-과정-prometheus-thanos-burrow-연동>Kafka 모니터링 아키텍처 발전 과정: Prometheus, Thanos, Burrow 연동<a hidden class=anchor aria-hidden=true href=#kafka-모니터링-아키텍처-발전-과정-prometheus-thanos-burrow-연동>#</a></h4><p>Kafka 모니터링 시스템을 구축하는 과정에서 Prometheus 단독 운영(V1) → Thanos를 통한 확장(V2) → Burrow를 활용한 Kafka Consumer 모니터링 추가(V3)로 발전해 나갔다.</p><p>각 버전별 아키텍처를 비교하며, 각 접근 방식의 장단점을 정리한다.</p><hr><h3 id=v1-prometheus-단독-구성으로-metric-수집>V1: Prometheus 단독 구성으로 Metric 수집<a hidden class=anchor aria-hidden=true href=#v1-prometheus-단독-구성으로-metric-수집>#</a></h3><p>Prometheus를 이용하여 Kafka 메트릭을 수집하고, Grafana에서 <code>CloudWatch</code>와 <code>Prometheus</code>를 <strong>데이터 소스로 추가하여 모니터링</strong>을 진행했다.</p><h4 id=구성-아키텍처>구성 아키텍처<a hidden class=anchor aria-hidden=true href=#구성-아키텍처>#</a></h4><p><img loading=lazy src=/posts/dance-with-burrow/v1-monitor.png></p><h4 id=pros-장점>Pros (장점)<a hidden class=anchor aria-hidden=true href=#pros-장점>#</a></h4><ul><li>Prometheus만 설정하면 별도 복잡한 설정 없이 Kafka 모니터링 가능</li><li>Grafana에서 Prometheus와 CloudWatch를 동시에 활용 가능하여 메트릭 비교 가능</li></ul><h4 id=cons-단점>Cons (단점)<a hidden class=anchor aria-hidden=true href=#cons-단점>#</a></h4><ul><li>Prometheus가 다운되면 모니터링 시스템 전체가 중단되며, <strong>Single Point of Failure (SPOF) 문제가 발생</strong></li><li>Prometheus는 <strong>모든 메트릭을 메모리(TSDB)에서 처리</strong>하므로, 수집하는 메트릭이 많아질수록 메모리 사용량 급증</li><li>TSDB의 크기가 증가할수록 Prometheus의 성능 저하 및 장애 가능성 증가</li></ul><hr><h3 id=v2-prometheus--thanos-sidecar-구성으로-ha-보장>V2: Prometheus + Thanos Sidecar 구성으로 HA 보장<a hidden class=anchor aria-hidden=true href=#v2-prometheus--thanos-sidecar-구성으로-ha-보장>#</a></h3><p>고가용성을 확보하기 위해 <strong>2대의 Prometheus 인스턴스를 운영</strong>하고,
Thanos Sidecar를 추가하여 <strong>Thanos 중앙 서버(Query + Store)와 연동</strong>했다.</p><h4 id=구성-아키텍처-1>구성 아키텍처<a hidden class=anchor aria-hidden=true href=#구성-아키텍처-1>#</a></h4><p><img loading=lazy src=/posts/dance-with-burrow/v2-monitor.png></p><h4 id=thanos를-도입한-이유>Thanos를 도입한 이유<a hidden class=anchor aria-hidden=true href=#thanos를-도입한-이유>#</a></h4><ul><li><strong>Prometheus의 중복 적재 방지</strong>: N대의 Prometheus가 동일한 Metric을 수집할 경우, <strong>Thanos Query가 중복 데이터를 제거(Deduplication)하여 처리</strong></li><li><strong>TSDB 단기 저장(Short-term) + Thanos Store 장기 저장(Long-term) 분리</strong>: Prometheus는 단기적인 메트릭만 보관하고, 장기적인 데이터는 <strong>Thanos Store(S3 등)에 저장</strong>하여 복구 가능</li><li><strong>Prometheus의 TSDB 크기를 줄일 수 있어, 메모리 사용량 감소 및 비용 절감 가능</strong></li></ul><h4 id=pros-장점-1>Pros (장점)<a hidden class=anchor aria-hidden=true href=#pros-장점-1>#</a></h4><ul><li><strong>고가용성(HA) 확보</strong>: 2대의 Prometheus + Thanos Query 구성으로 Prometheus 한 대가 장애가 나더라도 모니터링 지속 가능</li><li><strong>장기적인 데이터 보존 가능</strong>: Prometheus TSDB는 단기 데이터만 저장하고, 장기 데이터는 Thanos Store에 저장 가능하여 S3, GCS 등 Object Storage를 활용하여 저비용으로 장기 보존 가능</li><li><strong>Prometheus 리소스 최적화 가능</strong>: Prometheus의 TSDB 크기를 줄일 수 있어, 메모리 사용량 감소로 비용 절감 가능</li></ul><h4 id=cons-단점-1>Cons (단점)<a hidden class=anchor aria-hidden=true href=#cons-단점-1>#</a></h4><ul><li><strong>Thanos 추가 구성 필요로 인해 운영 복잡도 증가</strong>: 기존 Prometheus 단독 운영보다 <strong>Thanos Sidecar, Query, Store 설정이 추가로 필요</strong>하며, Thanos Store를 위한 Object Storage(S3 등) 연동이 필요함</li><li><strong>Thanos Query의 성능 한계</strong>: 여러 Prometheus 인스턴스에서 메트릭을 조회하는데, 과도한 요청이 발생하면 성능 저하 가능성 있음</li></ul><hr><h3 id=v3-burrow--prometheus--thanos-sidecar로-kafka-consumer-모니터링-강화>V3: Burrow + Prometheus + Thanos Sidecar로 Kafka Consumer 모니터링 강화<a hidden class=anchor aria-hidden=true href=#v3-burrow--prometheus--thanos-sidecar로-kafka-consumer-모니터링-강화>#</a></h3><p>비용 절감 및 Kafka Consumer Lag 모니터링을 강화하기 위해,
<strong>CloudWatch 대신 Burrow를 도입하여 Kafka Consumer 메트릭을 수집</strong>했다.</p><p><strong>CloudWatch를 걷어내고, Burrow + Prometheus + Thanos로 Kafka 모니터링을 최적화</strong>하였다.</p><h4 id=구성-아키텍처-2>구성 아키텍처<a hidden class=anchor aria-hidden=true href=#구성-아키텍처-2>#</a></h4><p><img loading=lazy src=/posts/dance-with-burrow/v3-monitor.png></p><blockquote><p>burrow가 주기적으로 kafka Consumer 메트릭을 수집하고, prometheus가 burrow metric을 수집하도록 하여 최종적으로 thanos query가 thanos-sidecar를 통해 kafka 관련 메트릭을 모두 수집하도록 구성</p></blockquote><h4 id=burrow를-도입한-이유>Burrow를 도입한 이유<a hidden class=anchor aria-hidden=true href=#burrow를-도입한-이유>#</a></h4><ul><li><strong>CloudWatch 비용 절감</strong>: Kafka 모니터링을 <strong>CloudWatch에서 Burrow + Prometheus로 전환</strong>하여 비용 절감 가능</li><li><strong>Kafka Consumer Lag 모니터링 강화</strong>: Burrow는 <strong>Kafka Consumer Group의 Offset 정보를 실시간으로 수집</strong>하며, Consumer Lag을 모니터링하여 Kafka가 정상적으로 동작하는지 추적 가능</li><li><strong>ACL(Access Control) 기반 모니터링 가능</strong>: CloudWatch는 Kafka ACL을 기반으로 세부적인 Consumer 모니터링이 어려운 반면, Burrow는 Consumer Group 및 Topic 별로 상세한 Lag 정보를 제공</li></ul><h4 id=pros-장점-2>Pros (장점)<a hidden class=anchor aria-hidden=true href=#pros-장점-2>#</a></h4><ul><li><strong>CloudWatch 비용 절감</strong>: Kafka 모니터링을 CloudWatch에서 Burrow + Prometheus로 전환하여 비용 절감 가능</li><li><strong>Kafka Consumer Group의 상세 모니터링 가능</strong>: Burrow를 통해 각 Consumer의 Offset, Lag, Partition 상태까지 상세 분석 가능</li><li><strong>기존 Prometheus + Thanos와 원활한 연동 가능</strong>: Burrow에서 <code>/metrics</code> 엔드포인트를 제공하여, Prometheus에서 손쉽게 데이터 수집 가능하며, Thanos Query를 통해 Kafka 관련 메트릭을 Grafana에서 단일 인터페이스로 조회 가능</li></ul><h4 id=cons-단점-2>Cons (단점)<a hidden class=anchor aria-hidden=true href=#cons-단점-2>#</a></h4><ul><li><strong>Burrow 초기 설정 및 운영 부담 증가</strong>: Burrow는 Kafka Consumer Lag을 모니터링하는 강력한 도구지만, 처음 설정할 때 Kafka 클러스터와 연동하는 과정이 필요하며, Kafka ACL이 적용된 환경에서는 Burrow의 접근 권한 설정이 필요함</li><li><strong>Burrow의 자체 Alerting 기능 한계</strong>: Burrow는 기본적으로 Alert 기능을 제공하지만, Prometheus Alertmanager보다 유연하지 않아 Prometheus Alertmanager 또는 Grafana Alerta와 함께 사용해야 효과적임</li></ul><hr><h3 id=버전-별-정리>버전 별 정리<a hidden class=anchor aria-hidden=true href=#버전-별-정리>#</a></h3><table><thead><tr><th>아키텍처</th><th>장점</th><th>단점</th><th>최종 평가</th></tr></thead><tbody><tr><td><strong>V1: Prometheus 단독</strong></td><td>빠른 구성 가능, 별도 설정 불필요</td><td>고가용성 보장 안됨, 메모리 사용량 과다</td><td>SPOF 문제로 비효율적</td></tr><tr><td><strong>V2: Prometheus + Thanos Sidecar</strong></td><td>고가용성(HA) 확보, 장기 데이터 저장 가능, 메모리 최적화 가능</td><td>Thanos 추가 구성 필요, 운영 복잡도 증가</td><td>장기 저장 및 확장 가능</td></tr><tr><td><strong>V3: Burrow + Prometheus + Thanos</strong></td><td>CloudWatch 비용 절감, Kafka Consumer 상세 모니터링, 기존 Prometheus 연동 가능</td><td>Burrow 설정 필요, Alert 기능 부족</td><td>최종 채택</td></tr></tbody></table><p>Kafka 모니터링을 효과적으로 수행하기 위해,
<strong>Burrow + Prometheus + Thanos를 조합하여 Kafka Consumer Lag까지 포함한 종합적인 모니터링 시스템을 구축하는 것이 최적의 해결책이었다.</strong></p><h1 id=구현>구현<a hidden class=anchor aria-hidden=true href=#구현>#</a></h1><h2 id=burrow>Burrow<a hidden class=anchor aria-hidden=true href=#burrow>#</a></h2><h3 id=kafka-consumer-lag-monitoring-with-burrow>Kafka Consumer Lag Monitoring with Burrow<a hidden class=anchor aria-hidden=true href=#kafka-consumer-lag-monitoring-with-burrow>#</a></h3><p>Kafka client의 consumer에서 <code>metrics()</code> 메서드를 사용하여 <code>records-lag-max</code>를 기록할 수 있지만, <strong>가장 뒤처진 파티션의 지연만을 보여주므로 전체 상태 파악이 어렵다</strong>. 또한, consumer가 멈추면 lag을 감지할 수 없어 <strong>외부 모니터링 시스템이 필요</strong>하다. 이를 해결하는 대표적인 솔루션이 LinkedIn의 <strong>Burrow</strong>이다.</p><p><img alt="Kafka Consumer Lag Monitoring" loading=lazy src=/posts/dance-with-burrow/image.png></p><p><a href=https://engineering.linkedin.com/apache-kafka/burrow-kafka-consumer-monitoring-reinvented>Burrow: Kafka Consumer Monitoring Reinvented</a></p><ul><li><strong>Consumer A</strong>: lag이 지속적으로 감소 → 정상</li><li><strong>Consumer B</strong>: lag이 일시적으로 증가했으나 복구됨 → 정상</li><li><strong>Consumer C</strong>: lag이 일정하게 유지됨 → 정상</li><li><strong>Consumer D</strong>: lag이 일시적으로 증가했으나 복구됨 → 정상적인 트래픽 처리</li></ul><h3 id=kafka-lag-threshold의-문제점>Kafka Lag Threshold의 문제점<a hidden class=anchor aria-hidden=true href=#kafka-lag-threshold의-문제점>#</a></h3><p><strong>임계값(threshold) 기반 감지는 오탐 가능성이 높다</strong>. 예를 들어, threshold를 <code>250</code>으로 설정하면 실제 정상적으로 동작하는 <strong>B, D</strong>도 이상 상태로 감지될 수 있다.</p><blockquote><p>⚠️ Kafka consumer의 <code>MaxLag</code> 값만으로 장애 여부를 판단할 수 없다!</p></blockquote><hr><h3 id=burrow는-어떻게-해결하는가>Burrow는 어떻게 해결하는가?<a hidden class=anchor aria-hidden=true href=#burrow는-어떻게-해결하는가>#</a></h3><p>Burrow는 <strong>Kafka 내부의 consumer offset을 기록하는 토픽을 읽어 개별 consumer 상태를 독립적으로 평가</strong>한다. 특정 consumer에 종속되지 않으며, <strong>모든 consumer를 자동으로 모니터링</strong>하여 <strong>객관적인 상태 분석</strong>이 가능하다.</p><p><img loading=lazy src=/posts/dance-with-burrow/image-1.png></p><h4 id=burrow의-동작-방식>Burrow의 동작 방식<a hidden class=anchor aria-hidden=true href=#burrow의-동작-방식>#</a></h4><p>Burrow는 <strong>sliding window 기법을 활용하여 최근 N개의 offset commit을 분석</strong>한다. LinkedIn에서는 <strong>10개의 offset commit(약 10분)을 기준</strong>으로 다음을 평가한다:</p><ol><li><strong>Consumer가 지속적으로 offset을 커밋하는가?</strong></li><li><strong>Consumer offset이 증가하고 있는가?</strong></li><li><strong>Lag이 증가하고 있는가?</strong></li><li><strong>Lag 증가 패턴이 지속적인가?</strong></li></ol><p>이를 기반으로 consumer 상태를 다음과 같이 분류한다:</p><ul><li><strong>✅ OK</strong>: 정상 작동</li><li><strong>⚠️ Warning</strong>: lag이 증가하는 상태</li><li><strong>❌ Error</strong>: consumer가 멈추거나 동작이 중단됨</li></ul><p>Burrow는 <strong>임계값 없이 패턴 분석을 통해 자동으로 이상 감지</strong>하며, HTTP API 및 알림 시스템을 통해 정보를 제공한다.</p><h4 id=burrow-api-예제>Burrow API 예제<a hidden class=anchor aria-hidden=true href=#burrow-api-예제>#</a></h4><pre tabindex=0><code>GET /v2/kafka/local/consumer/dingyu/status
</code></pre><p>consumer의 현재 상태와 <strong>문제가 발생한 topic과 partition 정보</strong>를 확인할 수 있다.</p><h2 id=연동-방안>연동 방안<a hidden class=anchor aria-hidden=true href=#연동-방안>#</a></h2><h3 id=1-사전-준비>1. 사전 준비<a hidden class=anchor aria-hidden=true href=#1-사전-준비>#</a></h3><ul><li>OS: Amazon Linux 2 또는 Ubuntu 20.04 이상</li><li>Docker 및 Docker Compose 설치</li><li>EC2 보안 그룹에서 다음 포트 허용<ul><li>Prometheus: <code>9090</code></li><li>Thanos Sidecar: <code>10901</code>, <code>10902</code></li><li>Burrow: <code>8000</code></li></ul></li></ul><h3 id=2-패키지-설치>2. 패키지 설치<a hidden class=anchor aria-hidden=true href=#2-패키지-설치>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Docker 설치</span>
</span></span><span class=line><span class=cl>sudo yum install -y docker
</span></span><span class=line><span class=cl>sudo systemctl <span class=nb>enable</span> docker --now
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Docker Compose 설치</span>
</span></span><span class=line><span class=cl>sudo curl -L <span class=s2>&#34;https://github.com/docker/compose/releases/latest/download/docker-compose-</span><span class=k>$(</span>uname -s<span class=k>)</span><span class=s2>-</span><span class=k>$(</span>uname -m<span class=k>)</span><span class=s2>&#34;</span> -o /usr/local/bin/docker-compose
</span></span><span class=line><span class=cl>sudo chmod +x /usr/local/bin/docker-compose
</span></span></code></pre></div><h3 id=3-폴더-구조>3. 폴더 구조<a hidden class=anchor aria-hidden=true href=#3-폴더-구조>#</a></h3><pre tabindex=0><code>MSK-MONITORING/
│── templates/                # 설정 템플릿 폴더
│   ├── burrow.tmpl.toml       # Burrow 설정 템플릿
│   ├── prometheus.tmpl.yaml   # Prometheus 설정 템플릿
│   ├── targets.tmpl.json      # Prometheus 타겟 설정 템플릿
│── deploy.sh                  # 배포 스크립트
│── docker-compose.yaml        # Docker Compose 설정 파일
│── Makefile                   # 설정 렌더링 및 빌드 관리
│── README.md                  # 프로젝트 문서
</code></pre><h3 id=4-주요-구성-요소>4. 주요 구성 요소<a hidden class=anchor aria-hidden=true href=#4-주요-구성-요소>#</a></h3><h4 id=41-burrow>4.1 Burrow<a hidden class=anchor aria-hidden=true href=#41-burrow>#</a></h4><ul><li>Kafka Consumer 상태를 모니터링하는 도구</li><li><code>burrow.tmpl.toml</code> 파일을 기반으로 환경 변수를 대체하여 설정</li><li>SASL/TLS 인증을 사용하여 MSK에 연결</li><li>HTTP 서버를 통해 상태 제공</li></ul><h4 id=burrow-관련-트러블슈팅>Burrow 관련 트러블슈팅<a hidden class=anchor aria-hidden=true href=#burrow-관련-트러블슈팅>#</a></h4><p>SASL 인증을 하는 경우, 레퍼런스가 전혀 없어서 무한 삽질을 거듭하였다</p><p>TLS의 경우 인증을 하지 않아 별도로 설정하지 않았으나, <code>skip verify</code> 옵션으로 무조건 필요했다</p><p>이 부분은 sarama client 생성 시, config를 고쳐 가며 디버깅을 거듭했다</p><p><img loading=lazy src=/posts/dance-with-burrow/image-3.png></p><p><code>SASL Mechanism</code>은 <code>SCRAM-SHA-512</code>/<code>SCRAM-SHA-256</code>을 지원한다! MSK에서 어떠한 Mechanism으로 설정하였는지 필히 확인하자</p><h4 id=42-prometheus>4.2 Prometheus<a hidden class=anchor aria-hidden=true href=#42-prometheus>#</a></h4><ul><li>Kafka 및 Burrow 메트릭 수집</li><li><code>prometheus.tmpl.yaml</code>을 기반으로 환경 변수 대체 후 설정</li><li><code>targets.tmpl.json</code>을 통해 JMX 및 Node Exporter 메트릭 수집</li></ul><h4 id=43-docker-compose>4.3 Docker Compose<a hidden class=anchor aria-hidden=true href=#43-docker-compose>#</a></h4><ul><li><code>docker-compose.yaml</code>을 사용하여 Burrow, Prometheus, Thanos Sidecar 컨테이너 실행</li><li>컨테이너 간 네트워크를 구성하여 원활한 통신 지원</li></ul><h4 id=44-makefile>4.4 Makefile<a hidden class=anchor aria-hidden=true href=#44-makefile>#</a></h4><ul><li><code>make render</code>: 환경 변수를 반영하여 설정 파일을 생성 (<code>generated/</code> 디렉토리)</li></ul><h4 id=45-환경-변수-관리>4.5 환경 변수 관리<a hidden class=anchor aria-hidden=true href=#45-환경-변수-관리>#</a></h4><p>환경 변수는 아래 example 처럼 docker-compose와 같은 디렉토리에 <code>.env</code> 형태로 관리하세요</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-env data-lang=env><span class=line><span class=cl><span class=nv>PROM_CLUSTER</span><span class=o>={</span>your-cluster-name<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=nv>PROMETHEUS_PORT</span><span class=o>=</span><span class=m>9090</span>
</span></span><span class=line><span class=cl><span class=nv>BURROW_PORT</span><span class=o>=</span><span class=m>8000</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>ZOOKEEPER_HOST_1</span><span class=o>={</span>zookeeper1_endpoint<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=nv>ZOOKEEPER_HOST_2</span><span class=o>={</span>zookeeper2_endpoint<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=nv>ZOOKEEPER_HOST_3</span><span class=o>={</span>zookeeper3_endpoint<span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>BROKER_HOST_1</span><span class=o>={</span>broker1_endpoint<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=nv>BROKER_HOST_2</span><span class=o>={</span>broker2_endpoint<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=nv>BROKER_HOST_3</span><span class=o>={</span>broker3_endpoint<span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>BURROW_USERNAME</span><span class=o>={</span>user<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=nv>BURROW_PASSWORD</span><span class=o>={</span>password<span class=o>}</span>
</span></span></code></pre></div><h3 id=5-설치-및-실행-방법>5. 설치 및 실행 방법<a hidden class=anchor aria-hidden=true href=#5-설치-및-실행-방법>#</a></h3><h4 id=51-프로젝트-클론>5.1 프로젝트 클론<a hidden class=anchor aria-hidden=true href=#51-프로젝트-클론>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>git clone https://github.com/dings-things/msk-monitoring-docker-compose.git
</span></span><span class=line><span class=cl><span class=nb>cd</span> msk-monitoring-docker-compose
</span></span></code></pre></div><h4 id=52-환경-변수-설정>5.2 환경 변수 설정<a hidden class=anchor aria-hidden=true href=#52-환경-변수-설정>#</a></h4><p><code>.env</code> 파일을 생성</p><h4 id=53-배포-스크립트-실행>5.3 배포 스크립트 실행<a hidden class=anchor aria-hidden=true href=#53-배포-스크립트-실행>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>chmod +x deploy.sh
</span></span><span class=line><span class=cl>./deploy.sh
</span></span></code></pre></div><h4 id=54-개별-실행-수동-실행>5.4 개별 실행 (수동 실행)<a hidden class=anchor aria-hidden=true href=#54-개별-실행-수동-실행>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>make render
</span></span><span class=line><span class=cl>docker compose up -d
</span></span></code></pre></div><h3 id=배포-프로세스>배포 프로세스<a hidden class=anchor aria-hidden=true href=#배포-프로세스>#</a></h3><p>자세한 사용법은 <a href=https://github.com/dings-things/msk-monitoring-docker-compose>github</a> 참고 !</p><p>실무 환경에서는 <a href=https://docs.gitlab.com/user/snippets/>gitlab snippets</a>를 사용하여 환경 변수를 <code>snippets API</code>를 통해 불러와 환경 별로 매핑합니다.</p><p><img loading=lazy src=/posts/dance-with-burrow/image-2.png></p><h2 id=대시보드-구성하기>대시보드 구성하기<a hidden class=anchor aria-hidden=true href=#대시보드-구성하기>#</a></h2><p>꼭 구성해야 하는 중요한 지표를 아래와 같이 분류하였다</p><ul><li>Topic/Partition 별 Status Check : 특정 토픽, 파티션의 이상 여부 확인<ul><li><code>burrow_kafka_topic_partition_status</code> 지표 활용</li></ul></li><li>Disk Usage : Disk 임계치 초과 시 Alert 설정 (증설)<ul><li><code>node_filesystem_avail_bytes</code> 지표 활용 (현재 남아있는 공간(<code>avail_bytes</code>) 을 전체 디스크 용량(<code>size_bytes</code>) 과 비교하여 사용된 비율을 계산)</li></ul></li><li>CPU Usage : CPU 임계치 초과 시 Alert 설정 (파티션 증설)<ul><li><code>node_cpu_seconds_total</code> 지표 활용 (user[kafka]사용 CPU, 전체 - idle[유휴] CPU 확인)</li></ul></li><li>Consumer Group Status Check : 컨슈머 그룹(애플리케이션) 상태 체크<ul><li><code>burrow_kafka_consumer_status</code> 지표 활용</li></ul></li><li>Consumer Group/Topic Lag : 컨슈머 그룹 / 토픽 별 쌓인 Lag 체크<ul><li><code>burrow_kafka_consumer_partition_lag</code> 지표 활용</li></ul></li><li>Lag Per Partition : 파티션 별 쌓인 Lag 체크<ul><li><code>burrow_kafka_consumer_partition_lag</code> 지표 Table 활용</li></ul></li><li>Current Offset : 현재 컨슈머 그룹이 처리하고 있는 최근 Offset<ul><li><code>burrow_kafka_consumer_status</code> 지표 활용</li></ul></li></ul><p><img loading=lazy src=/posts/dance-with-burrow/msk-monitoring-dashboard.png></p><h1 id=최종-구성>최종 구성<a hidden class=anchor aria-hidden=true href=#최종-구성>#</a></h1><p><img loading=lazy src=/posts/dance-with-burrow/msk-monitoring-full.png></p><h2 id=refs>REFS<a hidden class=anchor aria-hidden=true href=#refs>#</a></h2><ul><li><a href=https://github.com/linkedin/Burrow>Burrow 공식 문서</a></li><li><a href=https://prometheus.io/docs/>Prometheus 공식 문서</a></li><li><a href=https://bcho.tistory.com/1375>Prometheus 를 스케일링 하기 위한 Thanos</a></li><li><a href=https://oliveyoung.tech/2023-10-04/oliveyoung-b2b-msk-connect-introduction/>AWS MSK Connect 효과적으로 운영하기</a></li><li><a href=https://techblog.gccompany.co.kr/aws-msk-part3-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81%EC%9D%84-%EA%B5%AC%EC%B6%95%ED%95%B4%EB%B3%BC%EA%B9%8C%EC%9A%94-fe9a7109f4d>여기어때 MSK 모니터링 구축해볼까요?</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://dingyu.dev/tags/kafka/>Kafka</a></li><li><a href=https://dingyu.dev/tags/burrow/>Burrow</a></li><li><a href=https://dingyu.dev/tags/monitoring/>Monitoring</a></li><li><a href=https://dingyu.dev/tags/prometheus/>Prometheus</a></li><li><a href=https://dingyu.dev/tags/thanos/>Thanos</a></li><li><a href=https://dingyu.dev/tags/lag/>Lag</a></li></ul><nav class=paginav><a class=prev href=https://dingyu.dev/posts/local-sasl-kafka/><span class=title>« 이전 페이지</span><br><span>[EDA] Local SASL SCRAM Mechanism Kafka Docker compose 구성하기</span>
</a><a class=next href=https://dingyu.dev/posts/schema-registry/><span class=title>다음 페이지 »</span><br><span>[EDA] Schema Registry</span></a></nav></footer><div id=giscus_thread><script src=https://giscus.app/client.js data-repo=dings-things/blog data-repo-id=R_kgDON9IuAw data-category=Announcements data-category-id=DIC_kwDON9IuA84CnTai data-mapping=og:title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=ko data-loading=lazy crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://dingyu.dev/>Ding's Coding Forge</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="복사";function s(){t.innerHTML="복사 완료!",setTimeout(()=>{t.innerHTML="복사"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>
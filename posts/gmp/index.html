<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[Go] 고루틴 1억 개 돌려도 괜찮을까? | Ding's Coding Forge</title>
<meta name=keywords content="go,async,channel,gmp,thread,goroutine,pprof"><meta name=description content="Go의 런타임 스케줄링 모델(GMP)을 기반으로, 고루틴의 파킹(gopark) 및 웨이크업(goready) 동작이 실제로 어떻게 이루어지는지 상세히 분석. 채널, 뮤텍스, I/O 등 다양한 블로킹 상황에서 고루틴이 어떻게 파킹되고, M이 언제 새로 생성되며, 파킹된 고루틴이 너무 많아질 경우 어떤 성능 문제가 발생하는지 알아보자"><meta name=author content="dingyu"><link rel=canonical href=https://dingyu.dev/posts/gmp/><meta name=google-site-verification content="8XY1hI6NVxQIrN7bQbnX-9TG9HHFw5HOQmlb6vcsFdQ"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.678f9035c217c5346e0b3de5bdc9ebac02c53b0502219858f8653d8d181c97b3.css integrity="sha256-Z4+QNcIXxTRuCz3lvcnrrALFOwUCIZhY+GU9jRgcl7M=" rel="preload stylesheet" as=style><link rel=icon href=https://dingyu.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dingyu.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dingyu.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://dingyu.dev/apple-touch-icon.png><link rel=mask-icon href=https://dingyu.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://dingyu.dev/posts/gmp/><link rel=alternate hreflang=en href=https://dingyu.dev/en/posts/gmp/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-XH8830R9KK"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XH8830R9KK")}</script><meta property="og:url" content="https://dingyu.dev/posts/gmp/"><meta property="og:site_name" content="Ding's Coding Forge"><meta property="og:title" content="[Go] 고루틴 1억 개 돌려도 괜찮을까?"><meta property="og:description" content="Go의 런타임 스케줄링 모델(GMP)을 기반으로, 고루틴의 파킹(gopark) 및 웨이크업(goready) 동작이 실제로 어떻게 이루어지는지 상세히 분석. 채널, 뮤텍스, I/O 등 다양한 블로킹 상황에서 고루틴이 어떻게 파킹되고, M이 언제 새로 생성되며, 파킹된 고루틴이 너무 많아질 경우 어떤 성능 문제가 발생하는지 알아보자"><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-20T00:00:00+00:00"><meta property="article:modified_time" content="2025-05-20T00:00:00+00:00"><meta property="article:tag" content="Go"><meta property="article:tag" content="Async"><meta property="article:tag" content="Channel"><meta property="article:tag" content="Gmp"><meta property="article:tag" content="Thread"><meta property="article:tag" content="Goroutine"><meta property="og:image" content="https://dingyu.dev/posts/gmp/img/go-thumbnail.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dingyu.dev/posts/gmp/img/go-thumbnail.png"><meta name=twitter:title content="[Go] 고루틴 1억 개 돌려도 괜찮을까?"><meta name=twitter:description content="Go의 런타임 스케줄링 모델(GMP)을 기반으로, 고루틴의 파킹(gopark) 및 웨이크업(goready) 동작이 실제로 어떻게 이루어지는지 상세히 분석. 채널, 뮤텍스, I/O 등 다양한 블로킹 상황에서 고루틴이 어떻게 파킹되고, M이 언제 새로 생성되며, 파킹된 고루틴이 너무 많아질 경우 어떤 성능 문제가 발생하는지 알아보자"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://dingyu.dev/posts/"},{"@type":"ListItem","position":2,"name":"[Go] 고루틴 1억 개 돌려도 괜찮을까?","item":"https://dingyu.dev/posts/gmp/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[Go] 고루틴 1억 개 돌려도 괜찮을까?","name":"[Go] 고루틴 1억 개 돌려도 괜찮을까?","description":"Go의 런타임 스케줄링 모델(GMP)을 기반으로, 고루틴의 파킹(gopark) 및 웨이크업(goready) 동작이 실제로 어떻게 이루어지는지 상세히 분석. 채널, 뮤텍스, I/O 등 다양한 블로킹 상황에서 고루틴이 어떻게 파킹되고, M이 언제 새로 생성되며, 파킹된 고루틴이 너무 많아질 경우 어떤 성능 문제가 발생하는지 알아보자","keywords":["go","async","channel","gmp","thread","goroutine","pprof"],"articleBody":"본 글은… 아래 질문에 대한 궁금증으로 작성하게 되었습니다. 만약 초당 수천만건의 API 요청이 들어오며, 해당 API가 외부 API로 통신하는 환경에서 외부 API의 응답이 10초라면 서버는 어떻게 되는가?\n⨳ TCP connection timeout은 별도로 설정되어 있지 않다고 가정한다\n고루틴이 무엇인가? 고루틴을 흔히 경량 스레드라고 부른다… 그래서 스레드인데 메모리만 낮은 스레드라는 건가?\n고루틴의 장점 낮은 컨텍스트 스위칭 비용 하드웨어가 발전함에 따라 이를 효율적으로 사용하기 위해 *멀티스레딩 과 *멀티태스킹 개념이 등장한다.\n멀티스레딩 : 하나의 프로세스 안에서 여러 스레드 실행 (싱글 코어 환경일 경우? 멀티스레딩=멀티태스킹)\n멀티태스킹 : 여러 작업을 동시에 실행되는 것처럼 보여줌\n타 언어(C/C++/Java) Go언어 Go 런타임은 커널 수준의 TCB(Task Control Block)를 직접 스위칭하지 않고, 자체적인 G(고루틴), M(OS Thread), P(Scheduler Context)를 활용한 경량 컨텍스트 스위칭을 수행한다\n생성 및 소멸 비용 OS Thread를 생성하고 모두 사용한 뒤에 소멸하는 작업은 높은 비용을 요구한다. 이러한 비용 지불을 매번 하지 않기 위해 스레드 풀을 사용하기도 한다\nGo언어에서는 어떨까?\nGo 런타임의 GMP 모델 M이 바로 OS Thread에 해당된다. P(processor)가 M과 연결되어 고루틴이 수행되는 과정에서 M 또한 새롭게 생성되거나 소멸될 수 있다.\n※ G 는 User-level Thread, M 은 Os Thread. 이 둘이 m:n 으로 맵핑됨\n하지만 이는 go 런타임 스케쥴러에 의해 최적화되기에 일반적인 프로그래밍 언어에 비해 훨씬 저비용으로 관리가 가능해진다\n적은 메모리 소비 스레드로 생성할 경우, 스레드 간 메모리 보호 역할을 하는 공간을 포함하여 1MB 정도의 스택을 필요로 한다.\n반면에 고루틴은 2KB의 스택만 필요하기에 엄청난 경량 효과를 보게 된다 (물론 어떤 코드를 고루틴으로 돌리느냐에 따라, 메모리가 추가적인 할당이 필요함. 이는 다른 언어도 마찬가지)\n수치로 비교하자면 다음과 같다\n언어 기본 실행 단위 기본 스택 크기 총 메모리 소비 추정 C/C++ pthread 8MB 약 8MB 이상 Java java.lang.Thread 1MB 약 1MB 이상 Go goroutine (G) 2KB (초기) 수 KB 수준 GMP Go런타임은 모든 고루틴을 다중화된 스레드들에 할당하고 모니터링하며, 효율적으로 최적화된 스케쥴링을 진행한다. 구성 요소는 다음과 같다. 자세한 구조체는 runtime.runtime2.go 참고\n구성 요소 의미 역할 주요 정보 G (Goroutine) 고루틴 실행 단위 스택 포인터, 고루틴 상태 등 컨텍스트 정보 보유/LRQ 또는 GRQ에 대기 M (Machine) OS 스레드 고루틴 실행 실행 중인 고루틴(G), 연결된 P, 스레드 핸들 정보 보유 P (Processor) 논리 프로세서 고루틴 스케줄링 최대 GOMAXPROCS 개 존재/자신의 LRQ로부터 G를 POP하여 M에 할당 LRQ (Local Run Queue) 지역 실행 큐 고루틴 큐 (P별) 각 P에 하나씩 존재G를 M에 할당/경쟁 조건 줄이기 용이 GRQ (Global Run Queue) 글로벌 실행 큐 고루틴 큐 (공용) 모든 P가 공유/LRQ가 가득 찼거나 실행 시간 초과된 G가 들어감 P (Processor) P는 기본값으로 GOMAXPROCS=(CPU Core)를 가짐 P는 하나의 M에 할당되며 각 P는 자신의 Local Run Queue를 지님 P는 G의 context 정보를 갖는다 findRunnable()을 호출하여 다음 실행 될 G를 결정함 [runtime/proc.go]\nfunc findRunnable() (gp *g, inheritTime, tryWakeP bool) { mp := getg().m pp := mp.p.ptr() // local runq if gp, inheritTime := runqget(pp); gp != nil { return gp, inheritTime, false } // global runq if sched.runqsize != 0 { lock(\u0026sched.lock) gp := globrunqget(pp, 0) unlock(\u0026sched.lock) if gp != nil { return gp, false, false } } // Poll network. if netpollinited() \u0026\u0026 netpollAnyWaiters() \u0026\u0026 sched.lastpoll.Load() != 0 { if list, delta := netpoll(0); !list.empty() { gp := list.pop() injectglist(\u0026list) netpollAdjustWaiters(delta) casgstatus(gp, _Gwaiting, _Grunnable) return gp, false, false } } // Spinning Ms: steal work from other Ps. if mp.spinning || 2*sched.nmspinning.Load() \u003c gomaxprocs-sched.npidle.Load() { if !mp.spinning { mp.becomeSpinning() } gp, inheritTime, _, _, _ := stealWork(nanotime()) if gp != nil { return gp, inheritTime, false } } // fallback: no G found return nil, false, false } 순서 소스 설명 사용 상황 ① Local Run Queue (LRQ) P마다 존재하는 고유 큐 가장 빠르고 비용이 적음 → 우선 선택 대상 ② Global Run Queue (GRQ) 모든 P가 공유하는 큐 LRQ가 비어있을 때 fallback ③ Network Poller (Netpoll) epoll/kqueue/I/O 이벤트로 wake-up된 G들 네트워크 I/O 완료 후 G를 되살리는 역할 ④ Work Stealing (다른 P의 LRQ) 다른 P의 LRQ에서 G를 훔쳐옴 자신이 빈 상태이고 GRQ도 비어 있을 때 수행 그럼 자연스럽게 이런 생각이 들 것이다..\nI/O 작업을 하는 경우 LRQ와 GRQ가 모두 소비된 후에야 처리될 수 있을까? 우선 아니다. 대표적으로 아래 경우에 netpoll queue에서 GRQ로 inject 된다\n*sysmon() 시스템 모니터 내부\nsysmon : 독립적으로 백그라운드에서 반복 실행하며, P/M/Netpoll 하여 스케쥴링\n[runtime/proc.go]\nfunc sysmon() { for { ... if netpollinited() { list, _ := netpoll(0) // 비차단 injectglist(\u0026list) } ... } } Blocking 작업 완료 후, G는 어떻게 다시 P에게 돌아가는가? 하나의 P(processor)에서 goroutine 스위칭 과정이다\nG1은 syscall을 수행하는 고루틴이다 (ex. HTTPRequest)\n단계 설명 ① G1이 syscall 진입 net.Read() 호출 ② M1은 syscall에 block entersyscall() 호출, P1 분리됨 ③ P1은 M2에게 전달됨 M2가 idle 상태거나 newm()으로 새로 생성됨 ④ M2는 G2를 선택하고 실행 P1의 run queue에서 G2를 선택해 실행 ⑤ OS에서 syscall 완료 감지 epoll, kqueue, IOCP 등에 의해 ⑥ netpoller가 G1을 runnable로 마킹 G1.status = _Grunnable, run queue에 다시 등록 ⑦ 스케줄러가 적절한 시점에 G1을 재실행 이후 schedule()에서 G1이 선택되면 재개됨 findRunnable에서 Runnable한 Goroutine이 없다면? 현재 M(OS thread)은 더 이상 실행할 G가 없음 stopm() 호출 → 현재 M은 park M이 보유하던 P는 releasep()를 통해 반납됨 반납된 P는 idle P 큐에 들어감 GOMAXPROCS 개수만큼 생성된 P는 사라지지 않고 idle 상태 유지 새로운 runnable G가 나타나면, idle한 P를 다시 획득하여 실행 재개 M도 필요 시 다시 생성되거나 idle M을 재사용 M (Machine) M은 G를 받아 실제 수행을 수행하는 OS Thread이다 maxcount는 기본값으로 10000 앞선 P가 Blocking 작업 고루틴으로 수행하는 경우 M1의 운명은? (syscall 실행 이후의 흐름)\n[runtime/proc.go]\nfunc exitsyscall() { gp := getg() // Validate syscall stack frame if sys.GetCallerSP() \u003e gp.syscallsp { throw(\"exitsyscall: syscall frame is no longer valid\") } gp.waitsince = 0 oldp := gp.m.oldp.ptr() gp.m.oldp = 0 // Fast path: try to reacquire P and resume execution // if P is IDLE, return true and resume running goroutine if exitsyscallfast(oldp) { ... casgstatus(gp, _Gsyscall, _Grunning) // mark G as running return } // Slow path: failed to reacquire P // Call scheduler (park M and let scheduler run G later) mcall(exitsyscall0) } 조건 처리 P를 reacquire 가능 G1 즉시 실행 (execute(g)) P를 못 얻음 G1은 runnable로 enqueue, M1은 stop (stopm()) M이 많고 idle M1은 완전히 종료될 수도 있음 M이 부족하면서 idle M1은 다시 사용될 수도 있음 (newm() 피함) 다른 언어에서의 M(OS Thread)을 통한 멀티스레딩 매 요청마다 1개의 OS 스레드를 생성하고, 해당 스레드에서 epoll_wait/syscall 수행 N개의 워커 스레드를 만들어 각기 epoll_wait 또는 read 처리 Cons 1000개의 동시 요청을 처리하려면 최대 1000개의 스레드가 필요 각각의 M(epoll_wait)은 syscall blocking이므로 context switch 발생 *캐시 미스, 커널 진입 비용, 스케줄링 오버헤드 등이 급증 캐시 미스 : Context Switch 이후, CPU 캐시에서 자신의 데이터가 없음 → 메모리에서 다시 로드 (느림)\nNetpoller M Netpoller M은 Go 런타임이 하나만 유지하는 전용 OS 쓰레드(M)로, epoll/kqueue 등의 커널 I/O readiness 감시 시스템과 연결되어 있다\n고루틴들이 non-blocking I/O(fd)를 사용할 때, 해당 fd의 readable/writable 상태를 감시하는 역할만 전담 하나의 M만으로 수천 개의 fd를 감시, 적은 자원으로 수많은 I/O 고루틴을 효율적으로 처리 두 개의 syscall을 포함하는 고루틴과 Netpoller M의 flow\n왜 M이 바로 syscall 하면 안되는 거죠? Example : G1이 TCP 소켓을 통해 conn.Read()를 호출했다고 가정 만약 상대방이 갑자기 죽거나, NAT 타임아웃 등으로 연결이 끊겼는데도 커널에서 EOF 신호를 전달하지 않는다면?\nread(fd) syscall은 영원히 반환되지 않는다 (block 상태 지속) G1을 실행한 M은 syscall에서 block 해당 M이 보유한 P도 함께 릴리즈되면서 전체 병렬성에 영향 이러한 이유로 Go는 고루틴이 syscall 전에 fd의 readiness를 epoll 등을 통해 확인하고, 실제 read()는 ready일 때만 호출한다\n왜 Netpoller M이 전담해서 epoll하나요? Example : 1000개의 M이 각자 epoll_wait(fd)를 호출\n1000개가 제각각 epoll_wait() epoll 또한 syscall로, 커널-유저 전환 오버헤드 존재 얼마의 주기로 epoll 할것인가? polling interval도 추가로 고려해야 함 G (Goroutine) Goroutine 스케쥴링 고루틴이 어떠한 흐름으로 실행되는지 살펴봅시다\ngo dosomething()을 통해 신규 고루틴을 생성하게 되었습니다.\n현재 상태\nLRQ가 가득 참 신규 고루틴 생성됨 신규 고루틴(G0)이 생성되어 좌측 P에게 LRQ의 공간이 있는지 확인한다 현재 P의 LRQ가 full인 상태이다 (실제 상황에서는 lrq size = 256) 기존 LRQ의 반을 GRQ에 삽입한다 (G2 → GRQ) G0은 P가 비었기 때문에 LRQ로 삽입된다 G1이 수행되고 G0이 runnext에 위치한다 LRQ가 비었으므로 GRQ에서 고루틴을 가져온다 (global runqueue의 현재 길이/GOMAXPROCS + 1 만큼) G0은 M에서 실행되며 소켓에 요청을 전송한다 G0은 epoll_ctl(..., EPOLLIN)을 통해 readiness 등록한다 blocking 되지 않도록 기존 P와 연결을 끊는다 Netpoller M은 epoll_wait을 통해 readiness fd를 확인한다 M은 IDLE 상태로 돌아가며 G0은 Gopark로 대기한다 (이후 스케쥴러에 의해 삭제 혹은 P와 다시 맺어줌) Netpoller M은 G0 fd의 readiness fd를 확인한다 Netpoller M은 G0 fd의 readiness를 확인하고 Goready 상태로 전환한다 P는 LRQ와 GRQ에서 G를 찾지만 더이상 소비할 G가 없다 P는 netpoll으로 Ready 상태인 G를 바로 가져와 실행한다 몇몇 유의사항 GRQ Starvation LRQ만 계속 확인하고 GRQ polling이 일어나지 않을 수 있다. schedTick 변수가 존재하여, 61번의 polling이 일어날 때마다 LRQ → GRQ 순으로 확인하지 않고 GRQ를 먼저 확인하여 polling한다. schedTick 값이 61인 이유는 일단 실험적으로 성능이 좋았던 값의 범위 안에서 prime number를 고른 것이다. prime number를 사용한 이유는 hash map에서 균일 분포를 위해 prime length를 사용하던 것과 마찬가지로 어플리케이션 패턴과의 충돌을 피하기 위함이다. [runtime/proc.go]\nfunc findRunnable() (gp *g, inheritTime, tryWakeP bool) { mp := getg().m pp := mp.p.ptr() // Check the global runnable queue once in a while to ensure fairness // Otherwise two goroutines can completely occupy the local runqueue // by constantly respawning each other. if pp.schedtick%61 == 0 \u0026\u0026 !sched.runq.empty() { lock(\u0026sched.lock) gp := globrunqget() unlock(\u0026sched.lock) if gp != nil { return gp, false, false } } // local runq if gp, inheritTime := runqget(pp); gp != nil { return gp, inheritTime, false } ... } Time slice based preemption 하나의 고루틴이 프로세서를 오래 점유하는 것을 막기 위해 기본 10ms의 time slice가 정의되어 시간을 넘겼을 때 실행 중이던 고루틴은 preempted되어 GRQ로 들어간다.\n[runtime/proc.go]\nfunc sysmon() { ... for { ... lock(\u0026sched.sysmonlock) now = nanotime() ... // retake P's blocked in syscalls // and preempt long running G's if retake(now) != 0 { idle = 0 } else { idle++ } ... unlock(\u0026sched.sysmonlock) } } 수천만건의 네트워크 I/O를 수행하는 작업이 있는 경우 어떻게 되는가? Go의 고루틴은 경량 컨텍스트 스위칭, 작은 메모리 점유, epoll 기반의 네트워크 폴링 구조 덕분에 대규모 네트워크 I/O 환경에서도 효율적으로 작동할 수 있다.\n그러나 외부 API의 응답이 매우 느린 경우 (예: 10초), 그리고 초당 수천만 건의 요청이 쏟아지는 상황에서는 몇 가지 중요한 병목과 리스크가 발생할 수 있다.\n발생 가능 에러 케이스 1. 고루틴 수의 폭발적 증가 모든 요청이 외부 API 호출을 포함하고 있고, 이 API가 10초 이상 block 된다면, 10초 동안 고루틴이 대기 상태로 남음 초당 1,000만 건의 요청이 들어오고 10초 응답이라면, 최대 1억 개의 고루틴이 동시에 존재 고루틴 하나당 초기 스택이 2KB라고 가정해도, 1억 × 2KB ≒ 200GB 이상의 메모리를 소비 고루틴 수가 너무 많아지면 시스템 메모리가 고갈 2. file descriptor(fd) 수 제한 외부 API와 통신하는 각 요청은 TCP 연결을 맺기 때문에, OS는 각각의 fd를 유지 리눅스에서는 기본적으로 ulimit -n(open files 수)이 수천~수만 개로 제한됨 초당 수천만 건의 연결 요청은 결국 fd exhaustion 문제로 새로운 네트워크 요청이 실패하게 됨 참고 - OS 별 Default FD 운영체제 기본 fd 제한 (soft limit) 하드 제한 (hard limit) 비고 Ubuntu (20.04~) 1024 1048576 /etc/security/limits.conf 에서 조정 가능 Debian 1024 4096 시스템별로 차이 있음 CentOS 7 1024 4096 또는 1024 systemd 또는 limits.conf에서 조정 가능 macOS 256 10240 Ventura 기준 soft=256, hard=10240 (터미널/앱 별 다름) 고루틴 1억 개 돌려도 괜찮을까? 테스트 func init() { http.HandleFunc(\"/slow\", func(w http.ResponseWriter, r *http.Request) { time.Sleep(10 * time.Second) }) go func() { log.Println(\"slow API server start in :18080\") http.ListenAndServe(\":18080\", nil) }() } func main() { // ===== trace start ===== traceFile, err := os.Create(\"trace.out\") if err != nil { log.Fatalf(\"trace file creation failed: %v\", err) } if err := trace.Start(traceFile); err != nil { log.Fatalf(\"trace start failed: %v\", err) } defer func() { trace.Stop() traceFile.Close() }() // ===================== startProfiler() // start profiler for i := 0; i \u003c 100000000; i++ { go func(i int) { client := \u0026http.Client{} resp, err := client.Get(\"http://localhost:18080/slow\") if err != nil { fmt.Printf(\"[%d] Error: %v\\n\", i, err) return } io.Copy(io.Discard, resp.Body) resp.Body.Close() }(i) if i%100000 == 0 { fmt.Printf( \"Current Request Count: %d, Goroutine Count: %d\\n\", i, runtime.NumGoroutine(), ) } } select {} // wait forever (trace cancels from defer) } fd 재사용을 막기 위해 http.Client를 매번 생성하여 HTTP 요청 API 서버에서는 10초의 delay가 있다고 가정 heap / cpu 프로파일링 활성화 heap profile net/http.(*Transport).getConn\n내부적으로 HTTP connection pool을 관리하면서, 새로운 연결을 만들거나 재사용하는 함수 connection을 재사용하지 못함 → 계속 dial → new FD → getConn → heap 사용 증가 runtime.malg\nGo 런타임이 고루틴을 생성할 때 사용하는 stack 및 G 구조체 메모리 서버 응답을 기다리는 Waiting 상태의 고루틴 증가 → GC는 사용 중인 goroutine stack을 해제할 수 없음 → runtime.malg 급증 cpu profile runtime.cgocall\nGo에서 C 코드 또는 시스템 호출 (syscall) 을 실행할 때 사용되는 내부 함수 수많은 고루틴이 동시에 http.Client.Get()을 호출 → 각 요청마다 새로운 연결을 시도 → 네트워크 syscall 폭주 runtime.(*timers).adjust\nGo의 타이머 시스템은 내부적으로 min heap 기반으로 동작 테스트 코드 중, time.Sleep이 각 고루틴 별로 수행 → 수십만 개의 타이머가 힙에 삽입되어 힙 정렬 (adjust) 연산이 반복 connection timeout의 이유 Default HTTP Client에서 MaxConnectionPool을 모두 소비한 이후에는 결국 새롭게 Connection을 생성하여 3-way-handshake를 거친다\n클라이언트 요청 서버 측 처리 ------------- ------------------------- SYN ───────────▶ [SYN queue에 대기] (accept() 호출 전 상태) accept() 호출 → 커넥션 수락 ⇩ SYN-ACK ◀────────── 커넥션 수락됨 ACK ───────────▶ 커넥션 완료 (3-way handshake) 서버 측 syn queue가 full인 상태에서는 connection이 맺어지지 못하는 상태로 blocking 되다가 timeout 발생\n정리하자면, blocking 되는 처리를 대기하는 고루틴이 무한히 증가하면? → 종료되지 않은 고루틴의 Heap 점유 → OOM으로 Server Down\n번외로 동일한 커넥션을 만들도록 설정하더라도…\nfunc main() { ... client := \u0026http.Client{ Transport: \u0026http.Transport{ MaxIdleConns: 10000, // 전체 idle 연결 수 MaxIdleConnsPerHost: 10000, // 호스트당 idle 연결 수 IdleConnTimeout: 90 * time.Second, DisableKeepAlives: false, }, Timeout: 30 * time.Second, } for i := 0; i \u003c 100000000; i++ { go func(i int) { ... }(i) ... } select {} // wait forever (trace cancels from defer) } OOM으로 인해 Server Down된다 waiting 중인 goroutine의 heap 점유 connection pool을 초과하는 경우, new connection → getConn → heap 사용 증가 runnable 상태의 goroutine의 스케쥴링 과정에서 CPU 폭주 REFS Dmitry Vtukov GopherCon 2021: Madhav Jivrajani - Queues, Fairness, and The Go Scheduler ","wordCount":"2246","inLanguage":"ko","image":"https://dingyu.dev/posts/gmp/img/go-thumbnail.png","datePublished":"2025-05-20T00:00:00Z","dateModified":"2025-05-20T00:00:00Z","author":{"@type":"Person","name":"dingyu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://dingyu.dev/posts/gmp/"},"publisher":{"@type":"Organization","name":"Ding's Coding Forge","logo":{"@type":"ImageObject","url":"https://dingyu.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dingyu.dev/ accesskey=h title="Ding's Coding Forge (Alt + H)"><img src=https://dingyu.dev/apple-touch-icon.png alt aria-label=logo height=35>Ding's Coding Forge</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button><span class=nav-separator>|</span><div class=lang-select-dropdown><button class=lang-select-dropdown-trigger aria-label=번역 type=button><svg xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 512 512" width="24" height="18"><path d="M478.33 433.6l-90-218a22 22 0 00-40.67.0l-90 218a22 22 0 1040.67 16.79L316.66 406h102.67l18.33 44.39A22 22 0 00458 464a22 22 0 0020.32-30.4zM334.83 362 368 281.65 401.17 362z" fill="currentcolor"/><path d="M267.84 342.92a22 22 0 00-4.89-30.7c-.2-.15-15-11.13-36.49-34.73 39.65-53.68 62.11-114.75 71.27-143.49H330a22 22 0 000-44H214V70a22 22 0 00-44 0v20H54a22 22 0 000 44h197.25c-9.52 26.95-27.05 69.5-53.79 108.36-31.41-41.68-43.08-68.65-43.17-68.87a22 22 0 00-40.58 17c.58 1.38 14.55 34.23 52.86 83.93.92 1.19 1.83 2.35 2.74 3.51-39.24 44.35-77.74 71.86-93.85 80.74a22 22 0 1021.07 38.63c2.16-1.18 48.6-26.89 101.63-85.59 22.52 24.08 38 35.44 38.93 36.1a22 22 0 0030.75-4.9z" fill="currentcolor"/></svg></button><div class=lang-select-dropdown-content><a lang=en href=https://dingyu.dev/en/ title=English aria-label=English>English</a></div></div></div></div><ul id=menu><li><a href=https://dingyu.dev/ko/about/ title=소개><span>소개</span></a></li><li><a href=https://dingyu.dev/categories/ title=카테고리><span>카테고리</span></a></li><li><a href=https://dingyu.dev/tags/ title=태그><span>태그</span></a></li><li><a href=https://dingyu.dev/ko/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://dingyu.dev/ko/search/ title="검색 (Alt + /)" accesskey=/><span>검색</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://dingyu.dev/>홈</a>&nbsp;»&nbsp;<a href=https://dingyu.dev/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">[Go] 고루틴 1억 개 돌려도 괜찮을까?</h1><div class=post-description>Go의 런타임 스케줄링 모델(GMP)을 기반으로, 고루틴의 파킹(gopark) 및 웨이크업(goready) 동작이 실제로 어떻게 이루어지는지 상세히 분석. 채널, 뮤텍스, I/O 등 다양한 블로킹 상황에서 고루틴이 어떻게 파킹되고, M이 언제 새로 생성되며, 파킹된 고루틴이 너무 많아질 경우 어떤 성능 문제가 발생하는지 알아보자</div><div class=post-meta><span title='2025-05-20 00:00:00 +0000 UTC'>5월 20, 2025</span>&nbsp;·&nbsp;11 분&nbsp;·&nbsp;2246 단어&nbsp;·&nbsp;dingyu&nbsp;|&nbsp;번역:<ul class=i18n_list><li><a href=https://dingyu.dev/en/posts/gmp/>En</a></li></ul>&nbsp;|&nbsp;<a href=https://github.com/dings-things/blog/tree/main/content/posts/gmp/index.ko.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://dingyu.dev/img/go-thumbnail.png alt></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><ul><li><a href=#%ea%b3%a0%eb%a3%a8%ed%8b%b4%ec%9d%b4-%eb%ac%b4%ec%97%87%ec%9d%b8%ea%b0%80 aria-label="고루틴이 무엇인가?">고루틴이 무엇인가?</a><ul><li><a href=#%ea%b3%a0%eb%a3%a8%ed%8b%b4%ec%9d%98-%ec%9e%a5%ec%a0%90 aria-label="고루틴의 장점">고루틴의 장점</a><ul><li><a href=#%eb%82%ae%ec%9d%80-%ec%bb%a8%ed%85%8d%ec%8a%a4%ed%8a%b8-%ec%8a%a4%ec%9c%84%ec%b9%ad-%eb%b9%84%ec%9a%a9 aria-label="낮은 컨텍스트 스위칭 비용">낮은 컨텍스트 스위칭 비용</a><ul><li><a href=#%ed%83%80-%ec%96%b8%ec%96%b4ccjava aria-label="타 언어(C/C++/Java)">타 언어(C/C++/Java)</a></li><li><a href=#go%ec%96%b8%ec%96%b4 aria-label=Go언어>Go언어</a></li></ul></li><li><a href=#%ec%83%9d%ec%84%b1-%eb%b0%8f-%ec%86%8c%eb%a9%b8-%eb%b9%84%ec%9a%a9 aria-label="생성 및 소멸 비용">생성 및 소멸 비용</a></li><li><a href=#%ec%a0%81%ec%9d%80-%eb%a9%94%eb%aa%a8%eb%a6%ac-%ec%86%8c%eb%b9%84 aria-label="적은 메모리 소비">적은 메모리 소비</a></li></ul></li></ul></li><li><a href=#gmp aria-label=GMP>GMP</a><ul><li><a href=#p-processor aria-label="P (Processor)">P (Processor)</a><ul><ul><li><a href=#io-%ec%9e%91%ec%97%85%ec%9d%84-%ed%95%98%eb%8a%94-%ea%b2%bd%ec%9a%b0-lrq%ec%99%80-grq%ea%b0%80-%eb%aa%a8%eb%91%90-%ec%86%8c%eb%b9%84%eb%90%9c-%ed%9b%84%ec%97%90%ec%95%bc-%ec%b2%98%eb%a6%ac%eb%90%a0-%ec%88%98-%ec%9e%88%ec%9d%84%ea%b9%8c aria-label="I/O 작업을 하는 경우 LRQ와 GRQ가 모두 소비된 후에야 처리될 수 있을까?">I/O 작업을 하는 경우 LRQ와 GRQ가 모두 소비된 후에야 처리될 수 있을까?</a></li><li><a href=#blocking-%ec%9e%91%ec%97%85-%ec%99%84%eb%a3%8c-%ed%9b%84-g%eb%8a%94-%ec%96%b4%eb%96%bb%ea%b2%8c-%eb%8b%a4%ec%8b%9c-p%ec%97%90%ea%b2%8c-%eb%8f%8c%ec%95%84%ea%b0%80%eb%8a%94%ea%b0%80 aria-label="Blocking 작업 완료 후, G는 어떻게 다시 P에게 돌아가는가?">Blocking 작업 완료 후, G는 어떻게 다시 P에게 돌아가는가?</a></li><li><a href=#findrunnable%ec%97%90%ec%84%9c-runnable%ed%95%9c-goroutine%ec%9d%b4-%ec%97%86%eb%8b%a4%eb%a9%b4 aria-label="findRunnable에서 Runnable한 Goroutine이 없다면?">findRunnable에서 Runnable한 Goroutine이 없다면?</a></li></ul></ul></li><li><a href=#m-machine aria-label="M (Machine)">M (Machine)</a><ul><li><a href=#%eb%8b%a4%eb%a5%b8-%ec%96%b8%ec%96%b4%ec%97%90%ec%84%9c%ec%9d%98-mos-thread%ec%9d%84-%ed%86%b5%ed%95%9c-%eb%a9%80%ed%8b%b0%ec%8a%a4%eb%a0%88%eb%94%a9 aria-label="다른 언어에서의 M(OS Thread)을 통한 멀티스레딩">다른 언어에서의 M(OS Thread)을 통한 멀티스레딩</a><ul><li><a href=#cons aria-label=Cons>Cons</a></li></ul></li><li><a href=#netpoller-m aria-label="Netpoller M">Netpoller M</a><ul><li><a href=#%ec%99%9c-m%ec%9d%b4-%eb%b0%94%eb%a1%9c-syscall-%ed%95%98%eb%a9%b4-%ec%95%88%eb%90%98%eb%8a%94-%ea%b1%b0%ec%a3%a0 aria-label="왜 M이 바로 syscall 하면 안되는 거죠?">왜 M이 바로 syscall 하면 안되는 거죠?</a></li><li><a href=#%ec%99%9c-netpoller-m%ec%9d%b4-%ec%a0%84%eb%8b%b4%ed%95%b4%ec%84%9c-epoll%ed%95%98%eb%82%98%ec%9a%94 aria-label="왜 Netpoller M이 전담해서 epoll하나요?">왜 Netpoller M이 전담해서 epoll하나요?</a></li></ul></li></ul></li><li><a href=#g-goroutine aria-label="G (Goroutine)">G (Goroutine)</a><ul><li><a href=#goroutine-%ec%8a%a4%ec%bc%80%ec%a5%b4%eb%a7%81 aria-label="Goroutine 스케쥴링">Goroutine 스케쥴링</a></li></ul></li><li><a href=#%eb%aa%87%eb%aa%87-%ec%9c%a0%ec%9d%98%ec%82%ac%ed%95%ad aria-label="몇몇 유의사항">몇몇 유의사항</a><ul><li><a href=#grq-starvation aria-label="GRQ Starvation">GRQ Starvation</a></li><li><a href=#time-slice-based-preemption aria-label="Time slice based preemption">Time slice based preemption</a></li></ul></li></ul></li><li><a href=#%ec%88%98%ec%b2%9c%eb%a7%8c%ea%b1%b4%ec%9d%98-%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac-io%eb%a5%bc-%ec%88%98%ed%96%89%ed%95%98%eb%8a%94-%ec%9e%91%ec%97%85%ec%9d%b4-%ec%9e%88%eb%8a%94-%ea%b2%bd%ec%9a%b0-%ec%96%b4%eb%96%bb%ea%b2%8c-%eb%90%98%eb%8a%94%ea%b0%80 aria-label="수천만건의 네트워크 I/O를 수행하는 작업이 있는 경우 어떻게 되는가?">수천만건의 네트워크 I/O를 수행하는 작업이 있는 경우 어떻게 되는가?</a><ul><li><a href=#%eb%b0%9c%ec%83%9d-%ea%b0%80%eb%8a%a5-%ec%97%90%eb%9f%ac-%ec%bc%80%ec%9d%b4%ec%8a%a4 aria-label="발생 가능 에러 케이스">발생 가능 에러 케이스</a><ul><li><a href=#1-%ea%b3%a0%eb%a3%a8%ed%8b%b4-%ec%88%98%ec%9d%98-%ed%8f%ad%eb%b0%9c%ec%a0%81-%ec%a6%9d%ea%b0%80 aria-label="1. 고루틴 수의 폭발적 증가">1. 고루틴 수의 폭발적 증가</a></li><li><a href=#2-file-descriptorfd-%ec%88%98-%ec%a0%9c%ed%95%9c aria-label="2. file descriptor(fd) 수 제한">2. file descriptor(fd) 수 제한</a><ul><li><a href=#%ec%b0%b8%ea%b3%a0---os-%eb%b3%84-default-fd aria-label="참고 - OS 별 Default FD">참고 - OS 별 Default FD</a></li></ul></li></ul></li><li><a href=#%ea%b3%a0%eb%a3%a8%ed%8b%b4-1%ec%96%b5-%ea%b0%9c-%eb%8f%8c%eb%a0%a4%eb%8f%84-%ea%b4%9c%ec%b0%ae%ec%9d%84%ea%b9%8c-%ed%85%8c%ec%8a%a4%ed%8a%b8 aria-label="고루틴 1억 개 돌려도 괜찮을까? 테스트">고루틴 1억 개 돌려도 괜찮을까? 테스트</a><ul><li><a href=#heap-profile aria-label="heap profile">heap profile</a></li><li><a href=#cpu-profile aria-label="cpu profile">cpu profile</a></li></ul></li></ul></li><li><a href=#refs aria-label=REFS>REFS</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>본 글은&mldr; 아래 질문에 대한 궁금증으로 작성하게 되었습니다.
<img loading=lazy src=/posts/gmp/test-scenario.png></p><blockquote><p>만약 초당 수천만건의 API 요청이 들어오며, 해당 API가 외부 API로 통신하는 환경에서 외부 API의 응답이 10초라면 서버는 어떻게 되는가?</p><p>⨳ TCP connection timeout은 별도로 설정되어 있지 않다고 가정한다</p></blockquote><h1 id=고루틴이-무엇인가>고루틴이 무엇인가?<a hidden class=anchor aria-hidden=true href=#고루틴이-무엇인가>#</a></h1><p>고루틴을 흔히 경량 스레드라고 부른다&mldr; 그래서 스레드인데 메모리만 낮은 스레드라는 건가?</p><h2 id=고루틴의-장점>고루틴의 장점<a hidden class=anchor aria-hidden=true href=#고루틴의-장점>#</a></h2><h3 id=낮은-컨텍스트-스위칭-비용>낮은 컨텍스트 스위칭 비용<a hidden class=anchor aria-hidden=true href=#낮은-컨텍스트-스위칭-비용>#</a></h3><p>하드웨어가 발전함에 따라 이를 효율적으로 사용하기 위해 *<em>멀티스레딩</em> 과 *<em>멀티태스킹</em> 개념이 등장한다.</p><blockquote><p>멀티스레딩 : 하나의 프로세스 안에서 여러 스레드 실행 (싱글 코어 환경일 경우? 멀티스레딩=멀티태스킹)</p><p>멀티태스킹 : 여러 작업을 동시에 실행되는 것처럼 보여줌</p></blockquote><h4 id=타-언어ccjava>타 언어(C/C++/Java)<a hidden class=anchor aria-hidden=true href=#타-언어ccjava>#</a></h4><p><img loading=lazy src=/posts/gmp/image.png></p><h4 id=go언어>Go언어<a hidden class=anchor aria-hidden=true href=#go언어>#</a></h4><p>Go 런타임은 커널 수준의 TCB(Task Control Block)를 직접 스위칭하지 않고, 자체적인 G(고루틴), M(OS Thread), P(Scheduler Context)를 활용한 <strong>경량 컨텍스트 스위칭</strong>을 수행한다</p><hr><h3 id=생성-및-소멸-비용>생성 및 소멸 비용<a hidden class=anchor aria-hidden=true href=#생성-및-소멸-비용>#</a></h3><p><code>OS Thread</code>를 생성하고 모두 사용한 뒤에 소멸하는 작업은 높은 비용을 요구한다. 이러한 비용 지불을 매번 하지 않기 위해 <strong>스레드 풀</strong>을 사용하기도 한다</p><p>Go언어에서는 어떨까?</p><p>Go 런타임의 GMP 모델 M이 바로 <code>OS Thread</code>에 해당된다. P(processor)가 M과 연결되어 고루틴이 수행되는 과정에서 M 또한 새롭게 생성되거나 소멸될 수 있다.</p><p>※ <code>G</code> 는 User-level Thread, <code>M</code> 은 Os Thread. 이 둘이 <strong>m:n</strong> 으로 맵핑됨</p><p>하지만 이는 go 런타임 스케쥴러에 의해 최적화되기에 일반적인 프로그래밍 언어에 비해 훨씬 저비용으로 관리가 가능해진다</p><hr><h3 id=적은-메모리-소비>적은 메모리 소비<a hidden class=anchor aria-hidden=true href=#적은-메모리-소비>#</a></h3><p>스레드로 생성할 경우, 스레드 간 메모리 보호 역할을 하는 공간을 포함하여 <code>1MB</code> 정도의 스택을 필요로 한다.</p><p>반면에 고루틴은 <code>2KB</code>의 스택만 필요하기에 엄청난 경량 효과를 보게 된다 (물론 어떤 코드를 고루틴으로 돌리느냐에 따라, 메모리가 추가적인 할당이 필요함. 이는 다른 언어도 마찬가지)</p><p>수치로 비교하자면 다음과 같다</p><table><thead><tr><th>언어</th><th>기본 실행 단위</th><th>기본 스택 크기</th><th>총 메모리 소비 추정</th></tr></thead><tbody><tr><td>C/C++</td><td>pthread</td><td>8MB</td><td>약 8MB 이상</td></tr><tr><td>Java</td><td>java.lang.Thread</td><td>1MB</td><td>약 1MB 이상</td></tr><tr><td>Go</td><td>goroutine (G)</td><td>2KB (초기)</td><td>수 KB 수준</td></tr></tbody></table><hr><h1 id=gmp>GMP<a hidden class=anchor aria-hidden=true href=#gmp>#</a></h1><p>Go런타임은 모든 고루틴을 다중화된 스레드들에 할당하고 모니터링하며, 효율적으로 최적화된 스케쥴링을 진행한다.
<img loading=lazy src=/posts/gmp/gmp.png></p><p>구성 요소는 다음과 같다. 자세한 구조체는 <a href=https://github.com/golang/go/blob/master/src/runtime/runtime2.go>runtime.runtime2.go</a> 참고</p><table><thead><tr><th>구성 요소</th><th>의미</th><th>역할</th><th>주요 정보</th></tr></thead><tbody><tr><td><strong>G (Goroutine)</strong></td><td>고루틴</td><td>실행 단위</td><td>스택 포인터, 고루틴 상태 등 컨텍스트 정보 보유/LRQ 또는 GRQ에 대기</td></tr><tr><td><strong>M (Machine)</strong></td><td>OS 스레드</td><td>고루틴 실행</td><td>실행 중인 고루틴(G), 연결된 P, 스레드 핸들 정보 보유</td></tr><tr><td><strong>P (Processor)</strong></td><td>논리 프로세서</td><td>고루틴 스케줄링</td><td>최대 <code>GOMAXPROCS</code> 개 존재/자신의 LRQ로부터 G를 POP하여 M에 할당</td></tr><tr><td><strong>LRQ (Local Run Queue)</strong></td><td>지역 실행 큐</td><td>고루틴 큐 (P별)</td><td>각 P에 하나씩 존재G를 M에 할당/경쟁 조건 줄이기 용이</td></tr><tr><td><strong>GRQ (Global Run Queue)</strong></td><td>글로벌 실행 큐</td><td>고루틴 큐 (공용)</td><td>모든 P가 공유/LRQ가 가득 찼거나 실행 시간 초과된 G가 들어감</td></tr></tbody></table><h2 id=p-processor>P (Processor)<a hidden class=anchor aria-hidden=true href=#p-processor>#</a></h2><ul><li>P는 기본값으로 <code>GOMAXPROCS</code>=(CPU Core)를 가짐</li><li>P는 하나의 M에 할당되며 각 P는 자신의 <code>Local Run Queue</code>를 지님</li><li>P는 G의 context 정보를 갖는다</li><li><code>findRunnable()</code>을 호출하여 다음 실행 될 G를 결정함</li></ul><p><img loading=lazy src=/posts/gmp/findrunnable.png></p><p>[<a href=https://go.dev/src/runtime/proc.go>runtime/proc.go</a>]</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>findRunnable</span><span class=p>()</span> <span class=p>(</span><span class=nx>gp</span> <span class=o>*</span><span class=nx>g</span><span class=p>,</span> <span class=nx>inheritTime</span><span class=p>,</span> <span class=nx>tryWakeP</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>mp</span> <span class=o>:=</span> <span class=nf>getg</span><span class=p>().</span><span class=nx>m</span>
</span></span><span class=line><span class=cl>    <span class=nx>pp</span> <span class=o>:=</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>ptr</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// local runq</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>gp</span><span class=p>,</span> <span class=nx>inheritTime</span> <span class=o>:=</span> <span class=nf>runqget</span><span class=p>(</span><span class=nx>pp</span><span class=p>);</span> <span class=nx>gp</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>gp</span><span class=p>,</span> <span class=nx>inheritTime</span><span class=p>,</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// global runq</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>sched</span><span class=p>.</span><span class=nx>runqsize</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>gp</span> <span class=o>:=</span> <span class=nf>globrunqget</span><span class=p>(</span><span class=nx>pp</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>gp</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>gp</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Poll network.</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nf>netpollinited</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=nf>netpollAnyWaiters</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=nx>sched</span><span class=p>.</span><span class=nx>lastpoll</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>list</span><span class=p>,</span> <span class=nx>delta</span> <span class=o>:=</span> <span class=nf>netpoll</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span> <span class=p>!</span><span class=nx>list</span><span class=p>.</span><span class=nf>empty</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>gp</span> <span class=o>:=</span> <span class=nx>list</span><span class=p>.</span><span class=nf>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=nf>injectglist</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>list</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nf>netpollAdjustWaiters</span><span class=p>(</span><span class=nx>delta</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nf>casgstatus</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=nx>_Gwaiting</span><span class=p>,</span> <span class=nx>_Grunnable</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>gp</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Spinning Ms: steal work from other Ps.</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>spinning</span> <span class=o>||</span> <span class=mi>2</span><span class=o>*</span><span class=nx>sched</span><span class=p>.</span><span class=nx>nmspinning</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span> <span class=p>&lt;</span> <span class=nx>gomaxprocs</span><span class=o>-</span><span class=nx>sched</span><span class=p>.</span><span class=nx>npidle</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>!</span><span class=nx>mp</span><span class=p>.</span><span class=nx>spinning</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>mp</span><span class=p>.</span><span class=nf>becomeSpinning</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nx>gp</span><span class=p>,</span> <span class=nx>inheritTime</span><span class=p>,</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nf>stealWork</span><span class=p>(</span><span class=nf>nanotime</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>gp</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>gp</span><span class=p>,</span> <span class=nx>inheritTime</span><span class=p>,</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// fallback: no G found</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><table><thead><tr><th>순서</th><th>소스</th><th>설명</th><th>사용 상황</th></tr></thead><tbody><tr><td>①</td><td><strong>Local Run Queue (LRQ)</strong></td><td>P마다 존재하는 고유 큐</td><td>가장 빠르고 비용이 적음 → <strong>우선 선택 대상</strong></td></tr><tr><td>②</td><td><strong>Global Run Queue (GRQ)</strong></td><td>모든 P가 공유하는 큐</td><td>LRQ가 비어있을 때 fallback</td></tr><tr><td>③</td><td><strong>Network Poller (Netpoll)</strong></td><td>epoll/kqueue/I/O 이벤트로 wake-up된 G들</td><td>네트워크 I/O 완료 후 G를 되살리는 역할</td></tr><tr><td>④</td><td><strong>Work Stealing (다른 P의 LRQ)</strong></td><td>다른 P의 LRQ에서 G를 훔쳐옴</td><td>자신이 빈 상태이고 GRQ도 비어 있을 때 수행</td></tr></tbody></table><p>그럼 자연스럽게 이런 생각이 들 것이다..</p><hr><h4 id=io-작업을-하는-경우-lrq와-grq가-모두-소비된-후에야-처리될-수-있을까>I/O 작업을 하는 경우 LRQ와 GRQ가 모두 소비된 후에야 처리될 수 있을까?<a hidden class=anchor aria-hidden=true href=#io-작업을-하는-경우-lrq와-grq가-모두-소비된-후에야-처리될-수-있을까>#</a></h4><p>우선 아니다. 대표적으로 아래 경우에 netpoll queue에서 GRQ로 inject 된다</p><p>*<em>sysmon()</em> 시스템 모니터 내부</p><blockquote><p>sysmon : 독립적으로 백그라운드에서 반복 실행하며, P/M/Netpoll 하여 스케쥴링</p></blockquote><p>[<a href=https://go.dev/src/runtime/proc.go>runtime/proc.go</a>]</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>sysmon</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nf>netpollinited</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>list</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nf>netpoll</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=c1>// 비차단</span>
</span></span><span class=line><span class=cl>            <span class=nf>injectglist</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>list</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><hr><h4 id=blocking-작업-완료-후-g는-어떻게-다시-p에게-돌아가는가>Blocking 작업 완료 후, G는 어떻게 다시 P에게 돌아가는가?<a hidden class=anchor aria-hidden=true href=#blocking-작업-완료-후-g는-어떻게-다시-p에게-돌아가는가>#</a></h4><p>하나의 P(processor)에서 <code>goroutine</code> 스위칭 과정이다</p><p>G1은 syscall을 수행하는 고루틴이다 (ex. <code>HTTPRequest</code>)</p><p><img loading=lazy src=/posts/gmp/gmp-flow.png></p><table><thead><tr><th>단계</th><th>설명</th></tr></thead><tbody><tr><td>① <code>G1</code>이 syscall 진입</td><td><code>net.Read()</code> 호출</td></tr><tr><td>② <code>M1</code>은 syscall에 block</td><td><code>entersyscall()</code> 호출, <code>P1</code> 분리됨</td></tr><tr><td>③ <code>P1</code>은 <code>M2</code>에게 전달됨</td><td><code>M2</code>가 idle 상태거나 <code>newm()</code>으로 새로 생성됨</td></tr><tr><td>④ <code>M2</code>는 G2를 선택하고 실행</td><td>P1의 run queue에서 G2를 선택해 실행</td></tr><tr><td>⑤ OS에서 syscall 완료 감지</td><td><code>epoll</code>, <code>kqueue</code>, IOCP 등에 의해</td></tr><tr><td>⑥ <code>netpoller</code>가 G1을 runnable로 마킹</td><td><code>G1.status = _Grunnable</code>, run queue에 다시 등록</td></tr><tr><td>⑦ 스케줄러가 적절한 시점에 G1을 재실행</td><td>이후 <code>schedule()</code>에서 G1이 선택되면 재개됨</td></tr></tbody></table><hr><h4 id=findrunnable에서-runnable한-goroutine이-없다면>findRunnable에서 Runnable한 Goroutine이 없다면?<a hidden class=anchor aria-hidden=true href=#findrunnable에서-runnable한-goroutine이-없다면>#</a></h4><ol><li>현재 M(OS thread)은 더 이상 실행할 G가 없음</li><li>stopm() 호출 → 현재 M은 park</li><li>M이 보유하던 P는 releasep()를 통해 반납됨</li><li>반납된 P는 idle P 큐에 들어감</li></ol><ul><li><code>GOMAXPROCS</code> 개수만큼 생성된 P는 사라지지 않고 idle 상태 유지</li><li>새로운 runnable G가 나타나면, idle한 P를 다시 획득하여 실행 재개</li><li>M도 필요 시 다시 생성되거나 idle M을 재사용</li></ul><hr><h2 id=m-machine>M (Machine)<a hidden class=anchor aria-hidden=true href=#m-machine>#</a></h2><ul><li>M은 G를 받아 실제 수행을 수행하는 <code>OS Thread</code>이다</li><li>maxcount는 기본값으로 <strong>10000</strong></li></ul><p>앞선 P가 Blocking 작업 고루틴으로 수행하는 경우 M1의 운명은? (syscall 실행 이후의 흐름)</p><p>[<a href=https://go.dev/src/runtime/proc.go>runtime/proc.go</a>]</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>exitsyscall</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>gp</span> <span class=o>:=</span> <span class=nf>getg</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Validate syscall stack frame</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>sys</span><span class=p>.</span><span class=nf>GetCallerSP</span><span class=p>()</span> <span class=p>&gt;</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>syscallsp</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;exitsyscall: syscall frame is no longer valid&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>gp</span><span class=p>.</span><span class=nx>waitsince</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=nx>oldp</span> <span class=o>:=</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>oldp</span><span class=p>.</span><span class=nf>ptr</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>oldp</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Fast path: try to reacquire P and resume execution</span>
</span></span><span class=line><span class=cl>    <span class=c1>// if P is IDLE, return true and resume running goroutine</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nf>exitsyscallfast</span><span class=p>(</span><span class=nx>oldp</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=o>...</span>
</span></span><span class=line><span class=cl>		<span class=nf>casgstatus</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span> <span class=nx>_Gsyscall</span><span class=p>,</span> <span class=nx>_Grunning</span><span class=p>)</span> <span class=c1>// mark G as running</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Slow path: failed to reacquire P</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Call scheduler (park M and let scheduler run G later)</span>
</span></span><span class=line><span class=cl>	<span class=nf>mcall</span><span class=p>(</span><span class=nx>exitsyscall0</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><table><thead><tr><th>조건</th><th>처리</th></tr></thead><tbody><tr><td>P를 reacquire 가능</td><td>G1 즉시 실행 (<code>execute(g)</code>)</td></tr><tr><td>P를 못 얻음</td><td>G1은 runnable로 enqueue, M1은 stop (<code>stopm()</code>)</td></tr><tr><td>M이 많고 idle</td><td>M1은 완전히 종료될 수도 있음</td></tr><tr><td>M이 부족하면서 idle</td><td>M1은 다시 사용될 수도 있음 (<code>newm()</code> 피함)</td></tr></tbody></table><hr><h3 id=다른-언어에서의-mos-thread을-통한-멀티스레딩>다른 언어에서의 M(OS Thread)을 통한 멀티스레딩<a hidden class=anchor aria-hidden=true href=#다른-언어에서의-mos-thread을-통한-멀티스레딩>#</a></h3><ul><li>매 요청마다 1개의 OS 스레드를 생성하고, 해당 스레드에서 <code>epoll_wait/syscall</code> 수행</li><li>N개의 워커 스레드를 만들어 각기 <code>epoll_wait</code> 또는 <code>read</code> 처리</li></ul><h4 id=cons>Cons<a hidden class=anchor aria-hidden=true href=#cons>#</a></h4><ul><li>1000개의 동시 요청을 처리하려면 <strong>최대 1000개의 스레드가 필요</strong></li><li>각각의 M(epoll_wait)은 syscall blocking이므로 context switch 발생</li><li>*<em>캐시 미스</em>, 커널 진입 비용, 스케줄링 오버헤드 등이 급증</li></ul><blockquote><p>캐시 미스 : Context Switch 이후, CPU 캐시에서 자신의 데이터가 없음 → 메모리에서 다시 로드 (느림)</p></blockquote><h3 id=netpoller-m>Netpoller M<a hidden class=anchor aria-hidden=true href=#netpoller-m>#</a></h3><p><img loading=lazy src=/posts/gmp/netpoller.png>
Netpoller M은 Go 런타임이 하나만 유지하는 전용 OS 쓰레드(M)로, <code>epoll/kqueue</code> 등의 커널 I/O readiness 감시 시스템과 연결되어 있다</p><ul><li>고루틴들이 non-blocking I/O(fd)를 사용할 때, 해당 fd의 <strong>readable/writable 상태를 감시</strong>하는 역할만 전담</li><li>하나의 M만으로 수천 개의 fd를 감시, 적은 자원으로 수많은 I/O 고루틴을 효율적으로 처리</li></ul><blockquote><p>두 개의 syscall을 포함하는 고루틴과 Netpoller M의 flow</p></blockquote><p><img loading=lazy src=/posts/gmp/image-4.png></p><hr><h4 id=왜-m이-바로-syscall-하면-안되는-거죠>왜 M이 바로 syscall 하면 안되는 거죠?<a hidden class=anchor aria-hidden=true href=#왜-m이-바로-syscall-하면-안되는-거죠>#</a></h4><blockquote><p>Example : G1이 TCP 소켓을 통해 <code>conn.Read()</code>를 호출했다고 가정
만약 상대방이 갑자기 죽거나, NAT 타임아웃 등으로 연결이 끊겼는데도
커널에서 EOF 신호를 전달하지 않는다면?</p></blockquote><ul><li><code>read(fd)</code> syscall은 영원히 반환되지 않는다 (block 상태 지속)</li><li>G1을 실행한 M은 syscall에서 block</li><li>해당 M이 보유한 P도 함께 릴리즈되면서 전체 병렬성에 영향</li></ul><p>이러한 이유로 Go는 고루틴이 syscall 전에 fd의 readiness를 epoll 등을 통해 확인하고, 실제 <code>read()</code>는 ready일 때만 호출한다</p><h4 id=왜-netpoller-m이-전담해서-epoll하나요>왜 Netpoller M이 전담해서 epoll하나요?<a hidden class=anchor aria-hidden=true href=#왜-netpoller-m이-전담해서-epoll하나요>#</a></h4><blockquote><p>Example : 1000개의 M이 각자 <code>epoll_wait(fd)</code>를 호출</p></blockquote><ul><li>1000개가 제각각 <code>epoll_wait()</code></li><li>epoll 또한 syscall로, 커널-유저 전환 오버헤드 존재</li><li>얼마의 주기로 epoll 할것인가? polling interval도 추가로 고려해야 함</li></ul><h2 id=g-goroutine>G (Goroutine)<a hidden class=anchor aria-hidden=true href=#g-goroutine>#</a></h2><h3 id=goroutine-스케쥴링>Goroutine 스케쥴링<a hidden class=anchor aria-hidden=true href=#goroutine-스케쥴링>#</a></h3><p>고루틴이 어떠한 흐름으로 실행되는지 살펴봅시다</p><blockquote><p><code>go dosomething()</code>을 통해 신규 고루틴을 생성하게 되었습니다.</p><p><strong>현재 상태</strong></p><ul><li>LRQ가 가득 참</li><li>신규 고루틴 생성됨</li></ul></blockquote><p><img loading=lazy src=/posts/gmp/gmp1.png></p><ol><li>신규 고루틴(G0)이 생성되어 좌측 P에게 LRQ의 공간이 있는지 확인한다</li><li>현재 P의 LRQ가 full인 상태이다 (실제 상황에서는 lrq size = 256)
<img loading=lazy src=/posts/gmp/gmp2.png></li><li>기존 LRQ의 반을 GRQ에 삽입한다 (G2 → GRQ)</li><li>G0은 P가 비었기 때문에 LRQ로 삽입된다
<img loading=lazy src=/posts/gmp/gmp3.png></li><li>G1이 수행되고 G0이 <code>runnext</code>에 위치한다</li><li>LRQ가 비었으므로 GRQ에서 고루틴을 가져온다 (<code>global runqueue의 현재 길이/GOMAXPROCS + 1</code> 만큼)
<img loading=lazy src=/posts/gmp/gmp4.png></li><li>G0은 M에서 실행되며 소켓에 요청을 전송한다</li><li>G0은 <code>epoll_ctl(..., EPOLLIN)</code>을 통해 readiness 등록한다
<img loading=lazy src=/posts/gmp/gmp5-1.png></li><li>blocking 되지 않도록 기존 P와 연결을 끊는다</li><li>Netpoller M은 <code>epoll_wait</code>을 통해 readiness fd를 확인한다
<img loading=lazy src=/posts/gmp/gmp6.png></li><li>M은 IDLE 상태로 돌아가며 G0은 <code>Gopark</code>로 대기한다 (이후 스케쥴러에 의해 삭제 혹은 P와 다시 맺어줌)</li><li>Netpoller M은 G0 fd의 readiness fd를 확인한다
<img loading=lazy src=/posts/gmp/gmp7.png></li><li>Netpoller M은 G0 fd의 readiness를 확인하고 Goready 상태로 전환한다</li><li>P는 LRQ와 GRQ에서 G를 찾지만 더이상 소비할 G가 없다
<img loading=lazy src=/posts/gmp/gmp8.png></li><li>P는 <code>netpoll</code>으로 Ready 상태인 G를 바로 가져와 실행한다</li></ol><h2 id=몇몇-유의사항>몇몇 유의사항<a hidden class=anchor aria-hidden=true href=#몇몇-유의사항>#</a></h2><h3 id=grq-starvation>GRQ Starvation<a hidden class=anchor aria-hidden=true href=#grq-starvation>#</a></h3><ul><li>LRQ만 계속 확인하고 GRQ polling이 일어나지 않을 수 있다.</li><li>schedTick 변수가 존재하여, 61번의 polling이 일어날 때마다 LRQ → GRQ 순으로 확인하지 않고 GRQ를 먼저 확인하여 polling한다.</li><li>schedTick 값이 61인 이유는 일단 실험적으로 성능이 좋았던 값의 범위 안에서 prime number를 고른 것이다. prime number를 사용한 이유는 hash map에서 균일 분포를 위해 prime length를 사용하던 것과 마찬가지로 어플리케이션 패턴과의 충돌을 피하기 위함이다.</li></ul><p>[<a href=https://go.dev/src/runtime/proc.go>runtime/proc.go</a>]</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>findRunnable</span><span class=p>()</span> <span class=p>(</span><span class=nx>gp</span> <span class=o>*</span><span class=nx>g</span><span class=p>,</span> <span class=nx>inheritTime</span><span class=p>,</span> <span class=nx>tryWakeP</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>mp</span> <span class=o>:=</span> <span class=nf>getg</span><span class=p>().</span><span class=nx>m</span>
</span></span><span class=line><span class=cl>    <span class=nx>pp</span> <span class=o>:=</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>ptr</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Check the global runnable queue once in a while to ensure fairness</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Otherwise two goroutines can completely occupy the local runqueue</span>
</span></span><span class=line><span class=cl>	<span class=c1>// by constantly respawning each other.</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>pp</span><span class=p>.</span><span class=nx>schedtick</span><span class=o>%</span><span class=mi>61</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=p>!</span><span class=nx>sched</span><span class=p>.</span><span class=nx>runq</span><span class=p>.</span><span class=nf>empty</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>gp</span> <span class=o>:=</span> <span class=nf>globrunqget</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>gp</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>gp</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// local runq</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>gp</span><span class=p>,</span> <span class=nx>inheritTime</span> <span class=o>:=</span> <span class=nf>runqget</span><span class=p>(</span><span class=nx>pp</span><span class=p>);</span> <span class=nx>gp</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>gp</span><span class=p>,</span> <span class=nx>inheritTime</span><span class=p>,</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=time-slice-based-preemption>Time slice based preemption<a hidden class=anchor aria-hidden=true href=#time-slice-based-preemption>#</a></h3><p>하나의 고루틴이 프로세서를 오래 점유하는 것을 막기 위해 기본 10ms의 time slice가 정의되어 시간을 넘겼을 때 실행 중이던 고루틴은 preempted되어 GRQ로 들어간다.</p><p>[<a href=https://go.dev/src/runtime/proc.go>runtime/proc.go</a>]</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>sysmon</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=o>...</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>sysmonlock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>now</span> <span class=p>=</span> <span class=nf>nanotime</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// retake P&#39;s blocked in syscalls</span>
</span></span><span class=line><span class=cl>		<span class=c1>// and preempt long running G&#39;s</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nf>retake</span><span class=p>(</span><span class=nx>now</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>idle</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>idle</span><span class=o>++</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=o>...</span>
</span></span><span class=line><span class=cl>		<span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>sysmonlock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=수천만건의-네트워크-io를-수행하는-작업이-있는-경우-어떻게-되는가>수천만건의 네트워크 I/O를 수행하는 작업이 있는 경우 어떻게 되는가?<a hidden class=anchor aria-hidden=true href=#수천만건의-네트워크-io를-수행하는-작업이-있는-경우-어떻게-되는가>#</a></h1><p>Go의 고루틴은 경량 컨텍스트 스위칭, 작은 메모리 점유, epoll 기반의 네트워크 폴링 구조 덕분에 대규모 네트워크 I/O 환경에서도 효율적으로 작동할 수 있다.</p><p>그러나 외부 API의 응답이 매우 느린 경우 (예: 10초), 그리고 초당 수천만 건의 요청이 쏟아지는 상황에서는 몇 가지 중요한 병목과 리스크가 발생할 수 있다.</p><h2 id=발생-가능-에러-케이스>발생 가능 에러 케이스<a hidden class=anchor aria-hidden=true href=#발생-가능-에러-케이스>#</a></h2><h3 id=1-고루틴-수의-폭발적-증가>1. 고루틴 수의 폭발적 증가<a hidden class=anchor aria-hidden=true href=#1-고루틴-수의-폭발적-증가>#</a></h3><ul><li>모든 요청이 외부 API 호출을 포함하고 있고, 이 API가 10초 이상 block 된다면, 10초 동안 고루틴이 대기 상태로 남음</li><li>초당 1,000만 건의 요청이 들어오고 10초 응답이라면, 최대 1억 개의 고루틴이 동시에 존재</li><li>고루틴 하나당 초기 스택이 2KB라고 가정해도, 1억 × 2KB ≒ 200GB 이상의 메모리를 소비</li><li>고루틴 수가 너무 많아지면 시스템 메모리가 고갈</li></ul><h3 id=2-file-descriptorfd-수-제한>2. file descriptor(fd) 수 제한<a hidden class=anchor aria-hidden=true href=#2-file-descriptorfd-수-제한>#</a></h3><ul><li>외부 API와 통신하는 각 요청은 TCP 연결을 맺기 때문에, OS는 각각의 fd를 유지</li><li>리눅스에서는 기본적으로 ulimit -n(open files 수)이 수천~수만 개로 제한됨</li><li>초당 수천만 건의 연결 요청은 결국 <code>fd exhaustion</code> 문제로 새로운 네트워크 요청이 실패하게 됨</li></ul><h4 id=참고---os-별-default-fd>참고 - OS 별 Default FD<a hidden class=anchor aria-hidden=true href=#참고---os-별-default-fd>#</a></h4><table><thead><tr><th>운영체제</th><th>기본 fd 제한 (soft limit)</th><th>하드 제한 (hard limit)</th><th>비고</th></tr></thead><tbody><tr><td><strong>Ubuntu (20.04~)</strong></td><td>1024</td><td>1048576</td><td><code>/etc/security/limits.conf</code> 에서 조정 가능</td></tr><tr><td><strong>Debian</strong></td><td>1024</td><td>4096</td><td>시스템별로 차이 있음</td></tr><tr><td><strong>CentOS 7</strong></td><td>1024</td><td>4096 또는 1024</td><td>systemd 또는 limits.conf에서 조정 가능</td></tr><tr><td><strong>macOS</strong></td><td>256</td><td>10240</td><td>Ventura 기준 soft=256, hard=10240 (터미널/앱 별 다름)</td></tr></tbody></table><hr><h2 id=고루틴-1억-개-돌려도-괜찮을까-테스트>고루틴 1억 개 돌려도 괜찮을까? 테스트<a hidden class=anchor aria-hidden=true href=#고루틴-1억-개-돌려도-괜찮을까-테스트>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>init</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>http</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/slow&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>10</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;slow API server start in :18080&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>http</span><span class=p>.</span><span class=nf>ListenAndServe</span><span class=p>(</span><span class=s>&#34;:18080&#34;</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// ===== trace start =====</span>
</span></span><span class=line><span class=cl>	<span class=nx>traceFile</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Create</span><span class=p>(</span><span class=s>&#34;trace.out&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;trace file creation failed: %v&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>trace</span><span class=p>.</span><span class=nf>Start</span><span class=p>(</span><span class=nx>traceFile</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;trace start failed: %v&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>trace</span><span class=p>.</span><span class=nf>Stop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nx>traceFile</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>	<span class=c1>// =====================</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>startProfiler</span><span class=p>()</span> <span class=c1>// start profiler</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>100000000</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>client</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>http</span><span class=p>.</span><span class=nx>Client</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=nx>resp</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>client</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=s>&#34;http://localhost:18080/slow&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;[%d] Error: %v\n&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=nx>io</span><span class=p>.</span><span class=nf>Copy</span><span class=p>(</span><span class=nx>io</span><span class=p>.</span><span class=nx>Discard</span><span class=p>,</span> <span class=nx>resp</span><span class=p>.</span><span class=nx>Body</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>resp</span><span class=p>.</span><span class=nx>Body</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=p>}(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>i</span><span class=o>%</span><span class=mi>100000</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span>
</span></span><span class=line><span class=cl>				<span class=s>&#34;Current Request Count: %d, Goroutine Count: %d\n&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				<span class=nx>i</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				<span class=nx>runtime</span><span class=p>.</span><span class=nf>NumGoroutine</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>			<span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>select</span> <span class=p>{}</span> <span class=c1>// wait forever (trace cancels from defer)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>fd 재사용을 막기 위해 <code>http.Client</code>를 매번 생성하여 HTTP 요청</li><li>API 서버에서는 10초의 delay가 있다고 가정</li><li>heap / cpu 프로파일링 활성화</li></ul><p><img loading=lazy src=/posts/gmp/image-5.png></p><hr><h3 id=heap-profile>heap profile<a hidden class=anchor aria-hidden=true href=#heap-profile>#</a></h3><p><img loading=lazy src=/posts/gmp/image-7.png>
<code>net/http.(*Transport).getConn</code></p><ul><li>내부적으로 HTTP connection pool을 관리하면서, 새로운 연결을 만들거나 재사용하는 함수</li><li>connection을 재사용하지 못함 → 계속 dial → new FD → getConn → heap 사용 증가</li></ul><p><code>runtime.malg</code></p><ul><li>Go 런타임이 고루틴을 생성할 때 사용하는 stack 및 G 구조체 메모리</li><li>서버 응답을 기다리는 Waiting 상태의 고루틴 증가 → GC는 사용 중인 goroutine stack을 해제할 수 없음 → runtime.malg 급증</li></ul><hr><h3 id=cpu-profile>cpu profile<a hidden class=anchor aria-hidden=true href=#cpu-profile>#</a></h3><p><img loading=lazy src=/posts/gmp/image-9.png>
<code>runtime.cgocall</code></p><ul><li>Go에서 C 코드 또는 시스템 호출 (syscall) 을 실행할 때 사용되는 내부 함수</li><li>수많은 고루틴이 동시에 <code>http.Client.Get()</code>을 호출 → 각 요청마다 새로운 연결을 시도 → 네트워크 syscall 폭주</li></ul><p><code>runtime.(*timers).adjust</code></p><ul><li>Go의 타이머 시스템은 내부적으로 min heap 기반으로 동작</li><li>테스트 코드 중, <code>time.Sleep</code>이 각 고루틴 별로 수행 → 수십만 개의 타이머가 힙에 삽입되어 힙 정렬 (adjust) 연산이 반복</li></ul><hr><p><img loading=lazy src=/posts/gmp/image-10.png></p><blockquote><p><strong>connection timeout의 이유</strong>
Default HTTP Client에서 MaxConnectionPool을 모두 소비한 이후에는 결국 새롭게 Connection을 생성하여 3-way-handshake를 거친다</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>클라이언트 요청         서버 측 처리
</span></span><span class=line><span class=cl>-------------        -------------------------
</span></span><span class=line><span class=cl>SYN  ───────────▶   [SYN queue에 대기]
</span></span><span class=line><span class=cl>                              (accept() 호출 전 상태)
</span></span><span class=line><span class=cl>                              accept() 호출 → 커넥션 수락
</span></span><span class=line><span class=cl>                                    ⇩
</span></span><span class=line><span class=cl>SYN-ACK ◀──────────   커넥션 수락됨
</span></span><span class=line><span class=cl>ACK     ───────────▶  커넥션 완료 (3-way handshake)
</span></span></code></pre></div><p>서버 측 syn queue가 full인 상태에서는 connection이 맺어지지 못하는 상태로 blocking 되다가 timeout 발생</p></blockquote><p>정리하자면, blocking 되는 처리를 대기하는 고루틴이 무한히 증가하면? → 종료되지 않은 고루틴의 Heap 점유 → OOM으로 Server Down</p><p>번외로 동일한 커넥션을 만들도록 설정하더라도&mldr;</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=o>...</span>
</span></span><span class=line><span class=cl>    <span class=nx>client</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>http</span><span class=p>.</span><span class=nx>Client</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>Transport</span><span class=p>:</span> <span class=o>&amp;</span><span class=nx>http</span><span class=p>.</span><span class=nx>Transport</span><span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>MaxIdleConns</span><span class=p>:</span>        <span class=mi>10000</span><span class=p>,</span> <span class=c1>// 전체 idle 연결 수</span>
</span></span><span class=line><span class=cl>			<span class=nx>MaxIdleConnsPerHost</span><span class=p>:</span> <span class=mi>10000</span><span class=p>,</span> <span class=c1>// 호스트당 idle 연결 수</span>
</span></span><span class=line><span class=cl>			<span class=nx>IdleConnTimeout</span><span class=p>:</span>     <span class=mi>90</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=nx>DisableKeepAlives</span><span class=p>:</span>   <span class=kc>false</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=p>},</span>
</span></span><span class=line><span class=cl>		<span class=nx>Timeout</span><span class=p>:</span> <span class=mi>30</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>100000000</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=o>...</span>
</span></span><span class=line><span class=cl>		<span class=p>}(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=o>...</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>select</span> <span class=p>{}</span> <span class=c1>// wait forever (trace cancels from defer)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>OOM으로 인해 Server Down된다
<img loading=lazy src=/posts/gmp/image-12.png>
<img loading=lazy src=/posts/gmp/image-13.png></p><ul><li>waiting 중인 goroutine의 heap 점유</li><li>connection pool을 초과하는 경우, new connection → getConn → heap 사용 증가</li><li>runnable 상태의 goroutine의 스케쥴링 과정에서 CPU 폭주</li></ul><h1 id=refs>REFS<a hidden class=anchor aria-hidden=true href=#refs>#</a></h1><ul><li><a href="https://www.youtube.com/watch?v=-K11rY57K7k">Dmitry Vtukov</a></li><li><a href=https://velog.io/@sunaookamisiroko/Goroutine-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81>GopherCon 2021: Madhav Jivrajani - Queues, Fairness, and The Go Scheduler</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://dingyu.dev/tags/go/>Go</a></li><li><a href=https://dingyu.dev/tags/async/>Async</a></li><li><a href=https://dingyu.dev/tags/channel/>Channel</a></li><li><a href=https://dingyu.dev/tags/gmp/>Gmp</a></li><li><a href=https://dingyu.dev/tags/thread/>Thread</a></li><li><a href=https://dingyu.dev/tags/goroutine/>Goroutine</a></li><li><a href=https://dingyu.dev/tags/pprof/>Pprof</a></li></ul><nav class=paginav><a class=prev href=https://dingyu.dev/posts/confluence-automation/><span class=title>« 이전 페이지</span><br><span>[DX] 컨플루언스 자동화로 반복 작업 취소화하기</span>
</a><a class=next href=https://dingyu.dev/posts/distributed-locking/><span class=title>다음 페이지 »</span><br><span>[DB] 분산 환경에서의 Redlock과 Lease</span></a></nav></footer><div id=giscus_thread><script src=https://giscus.app/client.js data-repo=dings-things/blog data-repo-id=R_kgDON9IuAw data-category=Announcements data-category-id=DIC_kwDON9IuA84CnTai data-mapping=og:title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=en data-loading=lazy crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://dingyu.dev/>Ding's Coding Forge</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="복사";function s(){t.innerHTML="복사 완료!",setTimeout(()=>{t.innerHTML="복사"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>
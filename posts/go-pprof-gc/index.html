<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[Go] pprof로 GC 튜닝하기 | Ding's Coding Forge</title>
<meta name=keywords content="go,pprof,profile,gc tuning"><meta name=description content="This post explores how to use pprof for profiling and optimizing Go applications, focusing on heap allocation, GC tuning, and performance bottleneck identification. It covers profiling setup with Gin, analyzing Flame Graphs and heap dumps, and optimizing memory allocations by addressing inefficient context usage and logging overhead. Additionally, it discusses GC tuning strategies (GOMEMLIMIT, GOGC) and best practices like pointer usage, slice capacity preallocation, and benchmarking techniques to improve application efficiency and reduce Stop-The-World (STW) latency."><meta name=author content="dingyu"><link rel=canonical href=https://dingyu.dev/posts/go-pprof-gc/><meta name=google-site-verification content="8XY1hI6NVxQIrN7bQbnX-9TG9HHFw5HOQmlb6vcsFdQ"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.ba0de23ad40e17ca82720b577f8ae6ec11a26fb07407316cff70888e344ad129.css integrity="sha256-ug3iOtQOF8qCcgtXf4rm7BGib7B0BzFs/3CIjjRK0Sk=" rel="preload stylesheet" as=style><link rel=icon href=https://dingyu.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dingyu.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dingyu.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://dingyu.dev/apple-touch-icon.png><link rel=mask-icon href=https://dingyu.dev/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://dingyu.dev/posts/go-pprof-gc/><link rel=alternate hreflang=en href=https://dingyu.dev/en/posts/go-pprof-gc/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-XH8830R9KK"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XH8830R9KK")}</script><meta property="og:url" content="https://dingyu.dev/posts/go-pprof-gc/"><meta property="og:site_name" content="Ding's Coding Forge"><meta property="og:title" content="[Go] pprof로 GC 튜닝하기"><meta property="og:description" content="This post explores how to use pprof for profiling and optimizing Go applications, focusing on heap allocation, GC tuning, and performance bottleneck identification. It covers profiling setup with Gin, analyzing Flame Graphs and heap dumps, and optimizing memory allocations by addressing inefficient context usage and logging overhead. Additionally, it discusses GC tuning strategies (GOMEMLIMIT, GOGC) and best practices like pointer usage, slice capacity preallocation, and benchmarking techniques to improve application efficiency and reduce Stop-The-World (STW) latency."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-13T00:00:00+00:00"><meta property="article:modified_time" content="2024-09-13T00:00:00+00:00"><meta property="article:tag" content="Go"><meta property="article:tag" content="Pprof"><meta property="article:tag" content="Profile"><meta property="article:tag" content="Gc Tuning"><meta property="og:image" content="https://dingyu.dev/posts/go-pprof-gc/img/go-thumbnail.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dingyu.dev/posts/go-pprof-gc/img/go-thumbnail.png"><meta name=twitter:title content="[Go] pprof로 GC 튜닝하기"><meta name=twitter:description content="This post explores how to use pprof for profiling and optimizing Go applications, focusing on heap allocation, GC tuning, and performance bottleneck identification. It covers profiling setup with Gin, analyzing Flame Graphs and heap dumps, and optimizing memory allocations by addressing inefficient context usage and logging overhead. Additionally, it discusses GC tuning strategies (GOMEMLIMIT, GOGC) and best practices like pointer usage, slice capacity preallocation, and benchmarking techniques to improve application efficiency and reduce Stop-The-World (STW) latency."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://dingyu.dev/posts/"},{"@type":"ListItem","position":2,"name":"[Go] pprof로 GC 튜닝하기","item":"https://dingyu.dev/posts/go-pprof-gc/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[Go] pprof로 GC 튜닝하기","name":"[Go] pprof로 GC 튜닝하기","description":"This post explores how to use pprof for profiling and optimizing Go applications, focusing on heap allocation, GC tuning, and performance bottleneck identification. It covers profiling setup with Gin, analyzing Flame Graphs and heap dumps, and optimizing memory allocations by addressing inefficient context usage and logging overhead. Additionally, it discusses GC tuning strategies (GOMEMLIMIT, GOGC) and best practices like pointer usage, slice capacity preallocation, and benchmarking techniques to improve application efficiency and reduce Stop-The-World (STW) latency.","keywords":["go","pprof","profile","gc tuning"],"articleBody":"pprof 적용 import \"github.com/gin-contrib/pprof\" // init server var ( router *gin.Engine ) { router = gin.New() // pprof 라우터 등록 pprof.Register(router, APIPrefix+\"/debug/pprof\") } Script echo \"User API v1.2.3\" # 프로파일링 curl https://{endpoint}/debug/pprof/trace\\?seconds\\=10 --output v1.2.3-trace.out \u0026 curl https://{endpoint}/debug/pprof/heap\\?seconds\\=10 --output v1.2.3-heap.prof \u0026 curl https://{endpoint}/debug/pprof/profile\\?seconds\\=10 --output v1.2.3-cpu.prof \u0026 # 부하를 준 상태에서 GET 요청 수행 bombardier -t 1s -l -c 30 -d 10s\\ -H \"Content-Type: application/json\" \\ -m GET https://{endpoint}/v1/users/51387659 wait # go tool 활성화 -\u003e port에서 각 프로파일 실행 go tool trace -http 127.0.0.1:9094 v1.2.3-trace.out \u0026 go tool pprof -http 127.0.0.1:9095 v1.2.3-heap.prof \u0026 go tool pprof -http 127.0.0.1:9096 v1.2.3-cpu.prof \u0026 bash의 \u0026는 비동기로 다른 작업이 수행됨 PPROF의 기본 프로파일링 방법\npprof 라우터가 등록된 애플리케이션을 실행시킨다 기존 부하가 없는 경우라면.. 테스트하고자 하는 API Endpoint의 부하테스트 진행 curl 요청을 통해 필요한 프로파일링을 시작 ※ LB의 Timeout이 있는 경우, 해당 Timeout보다 작게 산정하여야 프로파일 데이터를 받을 수 있습니다\nHEAP 프로파일링 inuse_objects: 현재 사용 중인 객체의 수 inuse_space: 현재 사용 중인 메모리 양 alloc_objects: 프로그램이 시작된 후 할당된 총 객체 수 alloc_space: 프로그램이 시작된 후 할당된 총 메모리 양 Inuse Alloc 지표 확인 시 주의사항 e.g. Inuse와 Alloc의 할당된 메모리가 같은 케이스 Inuse가 1GB / Alloc이 1GB인 객체는, 처음 한번 할당된 이후 계속 사용 되고 있다는 뜻 → GC 개입 없음을 의미 → CPU 효율적\ne.g. Inuse보다 Alloc이 많이 할당된 케이스 Inuse가 1GB / Alloc이 1TB인 객체는, Heap 메모리를 객체에 1024번 할당했다는 뜻 → GC 가 1024번 발생됨 → GC로 인한 CPU 사용 → GC가 동작하는 동안 프로그램이 동작을 멈추는 Stop the World 현상\n튜닝 포인트 찾기 Flame Graph 최적화가 가능한 영역 (e.g. 개발자가 작성한 코드)와 최적화가 불가능한 영역 (e.g. 프레임워크 내부적으로 처리되는 로직 ServeHTTP)를 구분하여 최적화가 가능한 영역을 확인한다 가로축의 길이가 길어지는 비중만큼, 해당 함수가 프로그램 동작 과정에서 GC개입이 필요한 객체들을 많이 생성하고 있는 것을 알 수 있음\n주요 병목 지점이라 생각했던 Redis는 7.9%인 방면 Context에 Value를 Set하는 함수(13.9%)가 보다 많은 Heap이 할당됨을 알 수 있음 Set은 Context에 지정된 Key가 없는 경우, 새롭게 make(map[string]any)로 할당함. capacity를 지정하지 않기 때문에.. map에 대한 메모리 할당이 진행됨\n하나의 Request 단위로 로그를 그룹화 하기 위한 키이자만 이에 드는 오버헤드가 크다면 사용하지 않는 방안도 있음\nGraph 그래프에서는 네모의 크기가 곧 할당된 메모리의 크기입니다. 주요 팁은 크기가 큰 네모를 찾고 할당 비율(%)가 높은 것을 우선순위로 확인하는 방법입니다. 단적인 예로 어째서 zerolog가 메모리를 이렇게 차지하게 되었는지 살펴봅니다\nzerolog는 main에서 할당된 Logger 객체를 사용하기에 Allocation은 당연히 Zero라고 생각했습니다. (zerolog의 모토 자체가 zero alloc이기에…)\n코드리뷰 과정에서 중복된 필드의 With 작성으로 가독성이 저해된다는 피드백을 받고.. 이를 해결하기 위해 Context Logger를 생성하여 사용하도록 수정한 히스토리가 있었습니다. 아래는 문제의 Func입니다\n// Handle : CheckerHandler의 핸들러 func (h *BlacklistHandler) Handle(ctx *gin.Context) { // validation check var ( requestParams BlockCashoutGetRequestParams snValue string ) { ... } var ( logEntry zerolog.Logger = h.logger.With(). Str(\"trace_id\", ctx.GetString(RequestIDContextKey)).Logger() // func 실행때 마다 New됨 ) // fetch blacklist \u0026 validate { ... if err != nil { // redis nil인 경우에만 false로 처리 if errors.Is(err, redis.Nil) { ctx.JSON(http.StatusOK, NewNotBlacklistResponse()) logEntry.Info().Msg(\"not found in blacklist\") return } ctx.JSON( http.StatusInternalServerError, NewInternalServerErrorResponse(ctx.GetString(RequestIDContextKey)), ) return } ... if err != nil { // 시간 포맷이 틀린 경우 에러 로깅 logEntry.Error(). Err(err). Msg(\"failed to parse blacklist expire time\") ctx.JSON(http.StatusOK, NewBlacklistResponse()) return } ... // response ctx.JSON(http.StatusOK, NewBlacklistResponse()) } return } 주입받은 Zerologger는 Inuse == Alloc이 같아 GC로 인한 부하가 없지만서도… 내부적으로 NewLogger()를 수행하는 것과 동일한 효과로 인해, 매번 메모리가 할당되고 있었던 것이죠\n이러한 문제를 최적화하기 위해서는 가독성에 대한 TradeOff를 감수하거나 다른 로거를 사용하는 것도 방법이 될 수 있습니다.\n다른 Logger의 With는 Interface를 인자로 받기때문에 메모리 Alloc이 더 심해질수도 있습니다\n이에 대한 벤치마킹을 충분히 진행하여야 할것임\nGC 튜닝 가장 핵심은 과도한 GC 실행으로 인해 애플리케이션이 동작을 멈추는 Stop The World 현상을 개선하는 것이겠죠 아래는 이에 대한 여러가지 튜닝 방안입니다\nGOMEMLIMIT 사용하기 GOGC는 현시점의 Heap 크기와 직전 시점의 Heap 크기에 대한 증가율을 바탕으로 GC를 수행할지를 결정합니다. GC가 동작하는 Default 비율 값은 100으로, 기존 대비 Heap이 100% 증가, 즉 2배가 되면 GC를 수행합니다. 이 값을 낮추면 GC가 더 자주 수행되고, 이 값을 높일수록 GC가 덜 수행되게 됩니다.\nGolang 프로그램에 따른 수행 기준 값 선정하기 GC 값이 작은 경우\nGC가 너무 빈번하게 수행될 수 있습니다. 특히 프로그램이 재시작되어 아직 메모리 소비량이 작은 경우, 약간의 Heap 메모리 할당에도 허겁지겁 GC가 수행됩니다. 예시로 1GB의 Heap 메모리 크기가 2GB가 되어도 100% 증가이지만, 기준 값이 10MB인 경우, 겨우 20MB가 되어도 이 역시 100% 증가이기 때문입니다.\nGC 값이 큰 경우 OutOfMemory(이하 OOM) 발생 가능성이 커집니다. 기존 Heap 사용량이 40GB이고 GOGC가 50이라면, 1.5배 상승한 60GB가 되어야 GC가 수행되기 때문입니다.\nGOMEMLIMIT은 프로그램이 사용할 수 있는 메모리 사용량 한계선을 정하는 설정입니다. 이 방식에서는 설정한 GOMEMLIMIT의 값만큼 메모리 사용량이 올라가는 경우에만 GC가 수행됩니다.\n따라서 프로그램이 사용할 수 있는 최대 메모리 한계선을 미리 산정한 후, 그 값보다 작은 값을 GOMEMLIMIT으로 설정하면 손쉽게 GC를 튜닝할 수 있습니다. 한계선보다 작은 값을 설정하는 이유는 GOMEMLIMIT은 SoftLimit으로 프로그램이 설정된 GOMEMLIMIT 보다 조금 더 많은 메모리를 사용할 수 있기 때문입니다. 이로써 GC가 항상 최대한 늦게 동작할 수 있는 환경이 갖추어지며, GC Cycle이 최대로 길어지게 되어 STW가 최소화됩니다.\n바람직한? 프로세스\n기본 GOGC를 적용한 뒤, 메모리 수치 확인 PEAK 기준의 80%정도로 산정 (경험적인 수치) 프로파일링 / 모니터링하여 GC Cycle 확인 Production 코드의 벤치마크 해보기 가장 쉬운 방법은 작업한 코드의 벤치마크를 통해 확인해보는 방법입니다 bench의 -benchmem 을 통해 메모리 Alloc을 확인하고 Production 환경에서의 영향도를 확인해봅니다\ngo test -bench=. -benchmem ex. StructuredLogger 벤치마크 중 StructuredLogger는 팀에서 규격화되지 않은 필드들이 Elasticsearch에 적재되므로서 동일한 데이터 필드임에도 불구하고 데이터 사일로가 발생되는 것을 막기 위해 별도로 개발한 코드입니다.\n[주요 목적]\n로거의 변경이 필요하더라도 로거의 타입만을 바꾸어도 코드 수정이 불필요하도록 Wrapper구현 일관되지 않은 필드로 인하여 애플리케이션 내부에서 동일 필드임에도 불구하고, type 및 필드 명의 불일치가 잦음 [관련 벤치마크 테스트]\ngo test -bench=. -benchmem BenchmarkStructuredZeroLoggerMessage-12 596910 1724 ns/op 1000 B/op 30 allocs/op BenchmarkStructuredZeroLoggerMessageWithFields-12 285715 3926 ns/op 1633 B/op 60 allocs/op BenchmarkStructuredZeroLoggerMessageWithFieldsWithContext-12 222223 5346 ns/op 3418 B/op 68 allocs/op BenchmarkStandardZeroLoggerMessage-12 11927823 90.17 ns/op 0 B/op 0 allocs/op BenchmarkStandardZeroLoggerMessageWithDeterminedFields-12 5649648 217.6 ns/op 0 B/op 0 allocs/op BenchmarkStandardZeroLoggerWithFields-12 300001 3894 ns/op 1553 B/op 59 allocs/op 동일한 ZeroLogger를 사용하더라도 WithFields로 마샬링하는 과정에서 반복된 Memory Allocation이 발생합니다\n유즈케이스를 살피고 포인터 변수를 사용하자 일반적으로 생각하는 상식 상, value를 넘기기 보다 pointer 메모리 주소만 넘기기 때문에 CPU에 효율적이라고 생각합니다. 하지만 Golang에서는 CallByPointer보다 CallByValue가 효율적인 경우가 자주 발생합니다!\n포인터로 선언되는 순간, 해당 오브젝트는 무조건 Heap 영역에 할당되기 때문\nREF : https://articles.wesionary.team/use-case-of-pointers-in-go-w-practical-example-heap-stack-pointer-receiver-60b8950473da\n그렇다면 언제 Pointer를 사용해야 하는가? 큰 구조체의 경우: 큰 구조체는 복사 비용이 크므로, 포인터로 전달하여 메모리 사용을 줄이는 것이 더 효율적입니다. 변경 가능성: 포인터로 전달하면 원본 데이터를 변경할 수 있습니다. 즉, 메서드에서 구조체의 값을 수정하고 싶다면 포인터를 사용해야 합니다. 일관성 유지: API에서 일관성을 유지하기 위해 포인터를 사용하는 것이 좋습니다. 한 메서드에서 포인터를 사용한다면 다른 메서드도 일관성을 위해 포인터를 사용하는 것이 바람직합니다. null 값을 다룰 때: 예를 들어, int와 같은 필드가 실제로 값이 없음을 나타내야 할 때는 포인터를 사용하여 “진정한 부재\"를 나타낼 수 있습니다. 기본 값이 0인 경우와 구분하기 위함입니다. Capacity를 상수로 지정하여 Slice 생성하기 Capacity가 지정되지 않은 Slice를 Dynamic Slice라고 칭해보겠습니다. Dynamic Slice의 경우, 값을 Append 할 때마다, 새로운 메모리를 할당받고 새로운 데이터를 적재 후, 기존 객체는 버리는 realloc이 발생합니다\nGolang에서는 Data Type을 고려해서 크기가 64KB이하인 객체의 경우 Stack 메모리에 선언하는 기능이 있기 때문에… Capacity를 지정한 Slice 또는 Map을 Stack 메모리에 저장하여 성능을 개선시킬 수 있죠!\n고 컴파일\nMaxStackVarSize: 명시적으로 선언된 변수(var x T 또는 x := ...)의 경우 최대 10MB까지 Stack에 할당될 수 있으며, 그 이상의 크기는 Heap에 할당됩니다. MaxImplicitStackVarSize: 암묵적으로 생성된 변수 (new(T), \u0026T{}, make([]T, n) 등)의 경우 최대 64KB까지 Stack에 할당됩니다. 이보다 큰 경우는 Heap에 할당됩니다. MaxSmallArraySize: 256바이트 이하의 작은 배열은 직접 Stack에 할당 및 초기화되며, 그 이상의 배열은 Heap에 할당된 후 복사됩니다. ","wordCount":"1210","inLanguage":"ko","image":"https://dingyu.dev/posts/go-pprof-gc/img/go-thumbnail.png","datePublished":"2024-09-13T00:00:00Z","dateModified":"2024-09-13T00:00:00Z","author":{"@type":"Person","name":"dingyu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://dingyu.dev/posts/go-pprof-gc/"},"publisher":{"@type":"Organization","name":"Ding's Coding Forge","logo":{"@type":"ImageObject","url":"https://dingyu.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dingyu.dev/ accesskey=h title="Ding's Coding Forge (Alt + H)"><img src=https://dingyu.dev/apple-touch-icon.png alt aria-label=logo height=35>Ding's Coding Forge</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://dingyu.dev/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://dingyu.dev/about/ title=About><span>About</span></a></li><li><a href=https://dingyu.dev/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://dingyu.dev/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://dingyu.dev/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://dingyu.dev/search/ title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://dingyu.dev/>홈</a>&nbsp;»&nbsp;<a href=https://dingyu.dev/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">[Go] pprof로 GC 튜닝하기</h1><div class=post-description>This post explores how to use pprof for profiling and optimizing Go applications, focusing on heap allocation, GC tuning, and performance bottleneck identification. It covers profiling setup with Gin, analyzing Flame Graphs and heap dumps, and optimizing memory allocations by addressing inefficient context usage and logging overhead. Additionally, it discusses GC tuning strategies (GOMEMLIMIT, GOGC) and best practices like pointer usage, slice capacity preallocation, and benchmarking techniques to improve application efficiency and reduce Stop-The-World (STW) latency.</div><div class=post-meta><span title='2024-09-13 00:00:00 +0000 UTC'>9월 13, 2024</span>&nbsp;·&nbsp;6 분&nbsp;·&nbsp;1210 단어&nbsp;·&nbsp;dingyu&nbsp;|&nbsp;번역:<ul class=i18n_list><li><a href=https://dingyu.dev/en/posts/go-pprof-gc/>En</a></li></ul>&nbsp;|&nbsp;<a href=https://github.com/dings-things/blog/tree/main/content/posts/go-pprof-gc/index.ko.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://dingyu.dev/img/go-thumbnail.png alt></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><ul><ul><li><a href=#pprof-%ec%a0%81%ec%9a%a9 aria-label="pprof 적용">pprof 적용</a></li><li><a href=#script aria-label=Script>Script</a></li></ul><li><a href=#heap-%ed%94%84%eb%a1%9c%ed%8c%8c%ec%9d%bc%eb%a7%81 aria-label="HEAP 프로파일링">HEAP 프로파일링</a><ul><li><a href=#inuse-alloc-%ec%a7%80%ed%91%9c-%ed%99%95%ec%9d%b8-%ec%8b%9c-%ec%a3%bc%ec%9d%98%ec%82%ac%ed%95%ad aria-label="Inuse Alloc 지표 확인 시 주의사항">Inuse Alloc 지표 확인 시 주의사항</a></li><li><a href=#%ed%8a%9c%eb%8b%9d-%ed%8f%ac%ec%9d%b8%ed%8a%b8-%ec%b0%be%ea%b8%b0 aria-label="튜닝 포인트 찾기">튜닝 포인트 찾기</a><ul><li><a href=#flame-graph aria-label="Flame Graph">Flame Graph</a></li><li><a href=#graph aria-label=Graph>Graph</a></li></ul></li><li><a href=#gc-%ed%8a%9c%eb%8b%9d aria-label="GC 튜닝">GC 튜닝</a><ul><li><a href=#gomemlimit-%ec%82%ac%ec%9a%a9%ed%95%98%ea%b8%b0 aria-label="GOMEMLIMIT 사용하기">GOMEMLIMIT 사용하기</a></li><li><a href=#golang-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8%ec%97%90-%eb%94%b0%eb%a5%b8-%ec%88%98%ed%96%89-%ea%b8%b0%ec%a4%80-%ea%b0%92-%ec%84%a0%ec%a0%95%ed%95%98%ea%b8%b0 aria-label="Golang 프로그램에 따른 수행 기준 값 선정하기">Golang 프로그램에 따른 수행 기준 값 선정하기</a></li><li><a href=#production-%ec%bd%94%eb%93%9c%ec%9d%98-%eb%b2%a4%ec%b9%98%eb%a7%88%ed%81%ac-%ed%95%b4%eb%b3%b4%ea%b8%b0 aria-label="Production 코드의 벤치마크 해보기">Production 코드의 벤치마크 해보기</a></li><li><a href=#%ec%9c%a0%ec%a6%88%ec%bc%80%ec%9d%b4%ec%8a%a4%eb%a5%bc-%ec%82%b4%ed%94%bc%ea%b3%a0-%ed%8f%ac%ec%9d%b8%ed%84%b0-%eb%b3%80%ec%88%98%eb%a5%bc-%ec%82%ac%ec%9a%a9%ed%95%98%ec%9e%90 aria-label="유즈케이스를 살피고 포인터 변수를 사용하자">유즈케이스를 살피고 포인터 변수를 사용하자</a><ul><li><a href=#%ea%b7%b8%eb%a0%87%eb%8b%a4%eb%a9%b4-%ec%96%b8%ec%a0%9c-pointer%eb%a5%bc-%ec%82%ac%ec%9a%a9%ed%95%b4%ec%95%bc-%ed%95%98%eb%8a%94%ea%b0%80 aria-label="그렇다면 언제 Pointer를 사용해야 하는가?">그렇다면 언제 Pointer를 사용해야 하는가?</a></li></ul></li><li><a href=#capacity%eb%a5%bc-%ec%83%81%ec%88%98%eb%a1%9c-%ec%a7%80%ec%a0%95%ed%95%98%ec%97%ac-slice-%ec%83%9d%ec%84%b1%ed%95%98%ea%b8%b0 aria-label="Capacity를 상수로 지정하여 Slice 생성하기">Capacity를 상수로 지정하여 Slice 생성하기</a></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=pprof-적용>pprof 적용<a hidden class=anchor aria-hidden=true href=#pprof-적용>#</a></h2><hr><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;github.com/gin-contrib/pprof&#34;</span>
</span></span><span class=line><span class=cl><span class=c1>// init server</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=nx>router</span> <span class=o>*</span><span class=nx>gin</span><span class=p>.</span><span class=nx>Engine</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>router</span> <span class=p>=</span> <span class=nx>gin</span><span class=p>.</span><span class=nf>New</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=c1>// pprof 라우터 등록</span>
</span></span><span class=line><span class=cl>	<span class=nx>pprof</span><span class=p>.</span><span class=nf>Register</span><span class=p>(</span><span class=nx>router</span><span class=p>,</span> <span class=nx>APIPrefix</span><span class=o>+</span><span class=s>&#34;/debug/pprof&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=script>Script<a hidden class=anchor aria-hidden=true href=#script>#</a></h2><hr><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;User API v1.2.3&#34;</span>
</span></span><span class=line><span class=cl><span class=c1># 프로파일링</span>
</span></span><span class=line><span class=cl>curl https://<span class=o>{</span>endpoint<span class=o>}</span>/debug/pprof/trace<span class=se>\?</span>seconds<span class=se>\=</span><span class=m>10</span> --output v1.2.3-trace.out <span class=p>&amp;</span>
</span></span><span class=line><span class=cl>curl https://<span class=o>{</span>endpoint<span class=o>}</span>/debug/pprof/heap<span class=se>\?</span>seconds<span class=se>\=</span><span class=m>10</span> --output v1.2.3-heap.prof <span class=p>&amp;</span>
</span></span><span class=line><span class=cl>curl https://<span class=o>{</span>endpoint<span class=o>}</span>/debug/pprof/profile<span class=se>\?</span>seconds<span class=se>\=</span><span class=m>10</span> --output v1.2.3-cpu.prof <span class=p>&amp;</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 부하를 준 상태에서 GET 요청 수행</span>
</span></span><span class=line><span class=cl>bombardier -t 1s -l -c <span class=m>30</span> -d 10s<span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    -H <span class=s2>&#34;Content-Type: application/json&#34;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    -m GET https://<span class=o>{</span>endpoint<span class=o>}</span>/v1/users/51387659
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=nb>wait</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># go tool 활성화 -&gt; port에서 각 프로파일 실행</span>
</span></span><span class=line><span class=cl>go tool trace -http 127.0.0.1:9094 v1.2.3-trace.out <span class=p>&amp;</span>
</span></span><span class=line><span class=cl>go tool pprof -http 127.0.0.1:9095 v1.2.3-heap.prof <span class=p>&amp;</span>
</span></span><span class=line><span class=cl>go tool pprof -http 127.0.0.1:9096 v1.2.3-cpu.prof <span class=p>&amp;</span>
</span></span></code></pre></div><p>bash의 &는 비동기로 다른 작업이 수행됨
PPROF의 기본 프로파일링 방법</p><ol><li>pprof 라우터가 등록된 애플리케이션을 실행시킨다</li><li>기존 부하가 없는 경우라면.. 테스트하고자 하는 API Endpoint의 부하테스트 진행</li><li>curl 요청을 통해 필요한 프로파일링을 시작</li></ol><p>※ LB의 Timeout이 있는 경우, 해당 Timeout보다 작게 산정하여야 프로파일 데이터를 받을 수 있습니다</p><h1 id=heap-프로파일링>HEAP 프로파일링<a hidden class=anchor aria-hidden=true href=#heap-프로파일링>#</a></h1><hr><ul><li><code>inuse_objects</code>: 현재 사용 중인 객체의 수</li><li><code>inuse_space</code>: 현재 사용 중인 메모리 양</li><li><code>alloc_objects</code>: 프로그램이 시작된 후 할당된 총 객체 수</li><li><code>alloc_space</code>: 프로그램이 시작된 후 할당된 총 메모리 양</li></ul><h2 id=inuse-alloc-지표-확인-시-주의사항>Inuse Alloc 지표 확인 시 주의사항<a hidden class=anchor aria-hidden=true href=#inuse-alloc-지표-확인-시-주의사항>#</a></h2><hr><p>e.g. Inuse와 Alloc의 할당된 메모리가 같은 케이스
Inuse가 1GB / Alloc이 1GB인 객체는, 처음 한번 할당된 이후 계속 사용 되고 있다는 뜻 → GC 개입 없음을 의미 → CPU 효율적</p><p>e.g. Inuse보다 Alloc이 많이 할당된 케이스
Inuse가 1GB / Alloc이 1TB인 객체는, Heap 메모리를 객체에 1024번 할당했다는 뜻 → GC 가 1024번 발생됨 → GC로 인한 CPU 사용 → GC가 동작하는 동안 프로그램이 동작을 멈추는 <strong>Stop the World</strong> 현상</p><p><img loading=lazy src=/posts/go-pprof-gc/image.png></p><h2 id=튜닝-포인트-찾기>튜닝 포인트 찾기<a hidden class=anchor aria-hidden=true href=#튜닝-포인트-찾기>#</a></h2><hr><h3 id=flame-graph>Flame Graph<a hidden class=anchor aria-hidden=true href=#flame-graph>#</a></h3><hr><p>최적화가 가능한 영역 (e.g. 개발자가 작성한 코드)와 최적화가 불가능한 영역 (e.g. 프레임워크 내부적으로 처리되는 로직 <code>ServeHTTP</code>)를 구분하여 최적화가 가능한 영역을 확인한다
가로축의 길이가 길어지는 비중만큼, 해당 함수가 프로그램 동작 과정에서 GC개입이 필요한 객체들을 많이 생성하고 있는 것을 알 수 있음</p><p>주요 병목 지점이라 생각했던 Redis는 7.9%인 방면
<img loading=lazy src=/posts/go-pprof-gc/image-1.png></p><p>Context에 Value를 Set하는 함수(13.9%)가 보다 많은 Heap이 할당됨을 알 수 있음
<img loading=lazy src=/posts/go-pprof-gc/image-2.png></p><p><img loading=lazy src=/posts/go-pprof-gc/image-3.png>
Set은 Context에 지정된 Key가 없는 경우, 새롭게 <code>make(map[string]any)</code>로 할당함. capacity를 지정하지 않기 때문에.. map에 대한 메모리 할당이 진행됨</p><blockquote><p>하나의 Request 단위로 로그를 그룹화 하기 위한 키이자만 이에 드는 오버헤드가 크다면 사용하지 않는 방안도 있음</p></blockquote><h3 id=graph>Graph<a hidden class=anchor aria-hidden=true href=#graph>#</a></h3><hr><p><img loading=lazy src=/posts/go-pprof-gc/image-4.png></p><p>그래프에서는 네모의 크기가 곧 할당된 메모리의 크기입니다.
주요 팁은 크기가 큰 네모를 찾고 할당 비율(%)가 높은 것을 우선순위로 확인하는 방법입니다.
단적인 예로 어째서 zerolog가 메모리를 이렇게 차지하게 되었는지 살펴봅니다</p><p><img loading=lazy src=/posts/go-pprof-gc/image-5.png></p><p>zerolog는 main에서 할당된 <code>Logger</code> 객체를 사용하기에 Allocation은 당연히 Zero라고 생각했습니다. (zerolog의 모토 자체가 zero alloc이기에&mldr;)</p><p>코드리뷰 과정에서 중복된 필드의 <code>With</code> 작성으로 가독성이 저해된다는 피드백을 받고.. 이를 해결하기 위해 <code>Context Logger</code>를 생성하여 사용하도록 수정한 히스토리가 있었습니다.
아래는 문제의 Func입니다</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Handle : CheckerHandler의 핸들러</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>h</span> <span class=o>*</span><span class=nx>BlacklistHandler</span><span class=p>)</span> <span class=nf>Handle</span><span class=p>(</span><span class=nx>ctx</span> <span class=o>*</span><span class=nx>gin</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// validation check</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>		<span class=nx>requestParams</span> <span class=nx>BlockCashoutGetRequestParams</span>
</span></span><span class=line><span class=cl>		<span class=nx>snValue</span>       <span class=kt>string</span>
</span></span><span class=line><span class=cl>	<span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=o>...</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>		<span class=nx>logEntry</span> <span class=nx>zerolog</span><span class=p>.</span><span class=nx>Logger</span> <span class=p>=</span> <span class=nx>h</span><span class=p>.</span><span class=nx>logger</span><span class=p>.</span><span class=nf>With</span><span class=p>().</span>
</span></span><span class=line><span class=cl>			<span class=nf>Str</span><span class=p>(</span><span class=s>&#34;trace_id&#34;</span><span class=p>,</span> <span class=nx>ctx</span><span class=p>.</span><span class=nf>GetString</span><span class=p>(</span><span class=nx>RequestIDContextKey</span><span class=p>)).</span><span class=nf>Logger</span><span class=p>()</span>  <span class=c1>// func 실행때 마다 New됨</span>
</span></span><span class=line><span class=cl>	<span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1>// fetch blacklist &amp; validate</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=o>...</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// redis nil인 경우에만 false로 처리</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>Is</span><span class=p>(</span><span class=nx>err</span><span class=p>,</span> <span class=nx>redis</span><span class=p>.</span><span class=nx>Nil</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>ctx</span><span class=p>.</span><span class=nf>JSON</span><span class=p>(</span><span class=nx>http</span><span class=p>.</span><span class=nx>StatusOK</span><span class=p>,</span> <span class=nf>NewNotBlacklistResponse</span><span class=p>())</span>
</span></span><span class=line><span class=cl>				<span class=nx>logEntry</span><span class=p>.</span><span class=nf>Info</span><span class=p>().</span><span class=nf>Msg</span><span class=p>(</span><span class=s>&#34;not found in blacklist&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=nx>ctx</span><span class=p>.</span><span class=nf>JSON</span><span class=p>(</span>
</span></span><span class=line><span class=cl>				<span class=nx>http</span><span class=p>.</span><span class=nx>StatusInternalServerError</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				<span class=nf>NewInternalServerErrorResponse</span><span class=p>(</span><span class=nx>ctx</span><span class=p>.</span><span class=nf>GetString</span><span class=p>(</span><span class=nx>RequestIDContextKey</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>			<span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=o>...</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// 시간 포맷이 틀린 경우 에러 로깅</span>
</span></span><span class=line><span class=cl>			<span class=nx>logEntry</span><span class=p>.</span><span class=nf>Error</span><span class=p>().</span>
</span></span><span class=line><span class=cl>				<span class=nf>Err</span><span class=p>(</span><span class=nx>err</span><span class=p>).</span>
</span></span><span class=line><span class=cl>				<span class=nf>Msg</span><span class=p>(</span><span class=s>&#34;failed to parse blacklist expire time&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>ctx</span><span class=p>.</span><span class=nf>JSON</span><span class=p>(</span><span class=nx>http</span><span class=p>.</span><span class=nx>StatusOK</span><span class=p>,</span> <span class=nf>NewBlacklistResponse</span><span class=p>())</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=o>...</span>
</span></span><span class=line><span class=cl>		<span class=c1>// response</span>
</span></span><span class=line><span class=cl>		<span class=nx>ctx</span><span class=p>.</span><span class=nf>JSON</span><span class=p>(</span><span class=nx>http</span><span class=p>.</span><span class=nx>StatusOK</span><span class=p>,</span> <span class=nf>NewBlacklistResponse</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>주입받은 <code>Zerologger</code>는 Inuse == Alloc이 같아 GC로 인한 부하가 없지만서도&mldr; 내부적으로 <code>NewLogger()</code>를 수행하는 것과 동일한 효과로 인해, 매번 메모리가 할당되고 있었던 것이죠</p><p>이러한 문제를 최적화하기 위해서는 가독성에 대한 TradeOff를 감수하거나 다른 로거를 사용하는 것도 방법이 될 수 있습니다.</p><blockquote><p>다른 Logger의 <code>With</code>는 <code>Interface</code>를 인자로 받기때문에 메모리 Alloc이 더 심해질수도 있습니다</p><p>이에 대한 벤치마킹을 충분히 진행하여야 할것임</p></blockquote><h2 id=gc-튜닝>GC 튜닝<a hidden class=anchor aria-hidden=true href=#gc-튜닝>#</a></h2><hr><p>가장 핵심은 과도한 GC 실행으로 인해 애플리케이션이 동작을 멈추는 <code>Stop The World</code> 현상을 개선하는 것이겠죠
아래는 이에 대한 여러가지 튜닝 방안입니다</p><h3 id=gomemlimit-사용하기>GOMEMLIMIT 사용하기<a hidden class=anchor aria-hidden=true href=#gomemlimit-사용하기>#</a></h3><hr><p>GOGC는 현시점의 Heap 크기와 직전 시점의 Heap 크기에 대한 증가율을 바탕으로 GC를 수행할지를 결정합니다.
GC가 동작하는 Default 비율 값은 100으로, 기존 대비 Heap이 100% 증가, 즉 2배가 되면 GC를 수행합니다.
이 값을 낮추면 GC가 더 자주 수행되고, 이 값을 높일수록 GC가 덜 수행되게 됩니다.</p><h3 id=golang-프로그램에-따른-수행-기준-값-선정하기>Golang 프로그램에 따른 수행 기준 값 선정하기<a hidden class=anchor aria-hidden=true href=#golang-프로그램에-따른-수행-기준-값-선정하기>#</a></h3><hr><p><strong>GC 값이 작은 경우</strong></p><p>GC가 너무 빈번하게 수행될 수 있습니다. 특히 프로그램이 재시작되어 아직 메모리 소비량이 작은 경우, 약간의 Heap 메모리 할당에도 허겁지겁 GC가 수행됩니다.
예시로 1GB의 Heap 메모리 크기가 2GB가 되어도 100% 증가이지만, 기준 값이 10MB인 경우, 겨우 20MB가 되어도 이 역시 100% 증가이기 때문입니다.</p><p><strong>GC 값이 큰 경우</strong>
OutOfMemory(이하 OOM) 발생 가능성이 커집니다. 기존 Heap 사용량이 40GB이고 GOGC가 50이라면, 1.5배 상승한 60GB가 되어야 GC가 수행되기 때문입니다.</p><p>GOMEMLIMIT은 프로그램이 사용할 수 있는 <strong>메모리 사용량 한계선</strong>을 정하는 설정입니다. 이 방식에서는 설정한 GOMEMLIMIT의 값만큼 메모리 사용량이 올라가는 경우에만 GC가 수행됩니다.</p><p>따라서 프로그램이 사용할 수 있는 최대 메모리 한계선을 미리 산정한 후, 그 값보다 <strong>작은 값</strong>을 GOMEMLIMIT으로 설정하면 손쉽게 GC를 튜닝할 수 있습니다.
한계선보다 작은 값을 설정하는 이유는 <strong>GOMEMLIMIT은 SoftLimit</strong>으로 프로그램이 설정된 GOMEMLIMIT 보다 조금 더 많은 메모리를 사용할 수 있기 때문입니다.
이로써 GC가 항상 최대한 늦게 동작할 수 있는 환경이 갖추어지며, GC Cycle이 최대로 길어지게 되어 STW가 최소화됩니다.</p><p><img loading=lazy src=/posts/go-pprof-gc/image-6.png></p><p>바람직한? 프로세스</p><ul><li>기본 GOGC를 적용한 뒤, 메모리 수치 확인</li><li>PEAK 기준의 80%정도로 산정 (경험적인 수치)</li><li>프로파일링 / 모니터링하여 GC Cycle 확인</li></ul><h3 id=production-코드의-벤치마크-해보기>Production 코드의 벤치마크 해보기<a hidden class=anchor aria-hidden=true href=#production-코드의-벤치마크-해보기>#</a></h3><hr><p>가장 쉬운 방법은 작업한 코드의 벤치마크를 통해 확인해보는 방법입니다
bench의 <code>-benchmem</code> 을 통해 메모리 Alloc을 확인하고 Production 환경에서의 영향도를 확인해봅니다</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>go <span class=nb>test</span> -bench<span class=o>=</span>. -benchmem
</span></span></code></pre></div><p>ex. <code>StructuredLogger</code> 벤치마크 중
<code>StructuredLogger</code>는 팀에서 규격화되지 않은 필드들이 Elasticsearch에 적재되므로서 동일한 데이터 필드임에도 불구하고 데이터 사일로가 발생되는 것을 막기 위해
별도로 개발한 코드입니다.</p><p>[주요 목적]</p><ul><li>로거의 변경이 필요하더라도 로거의 타입만을 바꾸어도 코드 수정이 불필요하도록 Wrapper구현</li><li>일관되지 않은 필드로 인하여 애플리케이션 내부에서 동일 필드임에도 불구하고, type 및 필드 명의 불일치가 잦음</li></ul><p>[관련 벤치마크 테스트]</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>go <span class=nb>test</span> -bench<span class=o>=</span>. -benchmem
</span></span><span class=line><span class=cl>BenchmarkStructuredZeroLoggerMessage-12                                   <span class=m>596910</span>              <span class=m>1724</span> ns/op            <span class=m>1000</span> B/op         <span class=m>30</span> allocs/op
</span></span><span class=line><span class=cl>BenchmarkStructuredZeroLoggerMessageWithFields-12                         <span class=m>285715</span>              <span class=m>3926</span> ns/op            <span class=m>1633</span> B/op         <span class=m>60</span> allocs/op
</span></span><span class=line><span class=cl>BenchmarkStructuredZeroLoggerMessageWithFieldsWithContext-12              <span class=m>222223</span>              <span class=m>5346</span> ns/op            <span class=m>3418</span> B/op         <span class=m>68</span> allocs/op
</span></span><span class=line><span class=cl>BenchmarkStandardZeroLoggerMessage-12                                   <span class=m>11927823</span>                90.17 ns/op            <span class=m>0</span> B/op          <span class=m>0</span> allocs/op
</span></span><span class=line><span class=cl>BenchmarkStandardZeroLoggerMessageWithDeterminedFields-12                <span class=m>5649648</span>               217.6 ns/op             <span class=m>0</span> B/op          <span class=m>0</span> allocs/op
</span></span><span class=line><span class=cl>BenchmarkStandardZeroLoggerWithFields-12                                  <span class=m>300001</span>              <span class=m>3894</span> ns/op            <span class=m>1553</span> B/op         <span class=m>59</span> allocs/op
</span></span></code></pre></div><p>동일한 ZeroLogger를 사용하더라도 <code>WithFields</code>로 마샬링하는 과정에서 반복된 Memory Allocation이 발생합니다</p><h3 id=유즈케이스를-살피고-포인터-변수를-사용하자>유즈케이스를 살피고 포인터 변수를 사용하자<a hidden class=anchor aria-hidden=true href=#유즈케이스를-살피고-포인터-변수를-사용하자>#</a></h3><hr><p>일반적으로 생각하는 상식 상, value를 넘기기 보다 pointer 메모리 주소만 넘기기 때문에 CPU에 효율적이라고 생각합니다.
하지만 Golang에서는 CallByPointer보다 CallByValue가 효율적인 경우가 자주 발생합니다!</p><blockquote><p><strong>포인터로 선언되는 순간, 해당 오브젝트는 무조건 Heap 영역에 할당되기 때문</strong></p></blockquote><p>REF : <a href=https://articles.wesionary.team/use-case-of-pointers-in-go-w-practical-example-heap-stack-pointer-receiver-60b8950473da>https://articles.wesionary.team/use-case-of-pointers-in-go-w-practical-example-heap-stack-pointer-receiver-60b8950473da</a></p><h4 id=그렇다면-언제-pointer를-사용해야-하는가>그렇다면 언제 Pointer를 사용해야 하는가?<a hidden class=anchor aria-hidden=true href=#그렇다면-언제-pointer를-사용해야-하는가>#</a></h4><ul><li><strong>큰 구조체의 경우</strong>: 큰 구조체는 복사 비용이 크므로, 포인터로 전달하여 메모리 사용을 줄이는 것이 더 효율적입니다.</li><li><strong>변경 가능성</strong>: 포인터로 전달하면 원본 데이터를 변경할 수 있습니다. 즉, 메서드에서 구조체의 값을 수정하고 싶다면 포인터를 사용해야 합니다.</li><li><strong>일관성 유지</strong>: API에서 일관성을 유지하기 위해 포인터를 사용하는 것이 좋습니다. 한 메서드에서 포인터를 사용한다면 다른 메서드도 일관성을 위해 포인터를 사용하는 것이 바람직합니다.</li><li><strong>null 값을 다룰 때</strong>: 예를 들어, <code>int</code>와 같은 필드가 실제로 값이 없음을 나타내야 할 때는 포인터를 사용하여 &ldquo;진정한 부재"를 나타낼 수 있습니다. 기본 값이 0인 경우와 구분하기 위함입니다.</li></ul><h3 id=capacity를-상수로-지정하여-slice-생성하기>Capacity를 상수로 지정하여 Slice 생성하기<a hidden class=anchor aria-hidden=true href=#capacity를-상수로-지정하여-slice-생성하기>#</a></h3><hr><p>Capacity가 지정되지 않은 Slice를 Dynamic Slice라고 칭해보겠습니다.
Dynamic Slice의 경우, 값을 Append 할 때마다, 새로운 메모리를 할당받고 새로운 데이터를 적재 후, 기존 객체는 버리는 realloc이 발생합니다</p><p>Golang에서는 Data Type을 고려해서 크기가 64KB이하인 객체의 경우 Stack 메모리에 선언하는 기능이 있기 때문에&mldr;
Capacity를 지정한 Slice 또는 Map을 Stack 메모리에 저장하여 성능을 개선시킬 수 있죠!</p><p><a href=https://go.dev/src/cmd/compile/internal/ir/cfg.go>고 컴파일</a></p><ul><li><strong>MaxStackVarSize</strong>: 명시적으로 선언된 변수(<code>var x T</code> 또는 <code>x := ...</code>)의 경우 최대 10MB까지 Stack에 할당될 수 있으며, 그 이상의 크기는 Heap에 할당됩니다.</li><li><strong>MaxImplicitStackVarSize</strong>: 암묵적으로 생성된 변수 (<code>new(T)</code>, <code>&amp;T{}</code>, <code>make([]T, n)</code> 등)의 경우 최대 64KB까지 Stack에 할당됩니다. 이보다 큰 경우는 Heap에 할당됩니다.</li><li><strong>MaxSmallArraySize</strong>: 256바이트 이하의 작은 배열은 직접 Stack에 할당 및 초기화되며, 그 이상의 배열은 Heap에 할당된 후 복사됩니다.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://dingyu.dev/tags/go/>Go</a></li><li><a href=https://dingyu.dev/tags/pprof/>Pprof</a></li><li><a href=https://dingyu.dev/tags/profile/>Profile</a></li><li><a href=https://dingyu.dev/tags/gc-tuning/>Gc Tuning</a></li></ul><nav class=paginav><a class=prev href=https://dingyu.dev/posts/coffee-pal/><span class=title>« 이전 페이지</span><br><span>[DX] 사내 커피 챗 슬랙 봇 개발기</span>
</a><a class=next href=https://dingyu.dev/posts/sentry/><span class=title>다음 페이지 »</span><br><span>[Third-Party] Sentry 연동</span></a></nav></footer><div id=giscus_thread><script src=https://giscus.app/client.js data-repo=dings-things/blog data-repo-id=R_kgDON9IuAw data-category=Announcements data-category-id=DIC_kwDON9IuA84CnTai data-mapping=og:title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=ko data-loading=lazy crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://dingyu.dev/>Ding's Coding Forge</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="복사";function s(){t.innerHTML="복사 완료!",setTimeout(()=>{t.innerHTML="복사"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>
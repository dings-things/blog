<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[Protocol] RPC... 그리고 GRPC 톺아보기 | Ding's Coding Forge</title>
<meta name=keywords content="grpc,rpc,protobuf,HTTP2.0"><meta name=description content="흔히들 (나만 그럴지도..?) rpc 통신을 한다 하면&mldr; HTTP/2 기반의 protocol Buffer를 사용하겠구나~ (grpc 구나) 라고 생각하기 마련이다. rpc는 무엇이고 grpc는 어째서 빠를까? 그리고 왜 사용할까?"><meta name=author content="dingyu"><link rel=canonical href=https://dingyu.dev/posts/grpc/><meta name=google-site-verification content="8XY1hI6NVxQIrN7bQbnX-9TG9HHFw5HOQmlb6vcsFdQ"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.e27650c63b614184e0a53cd99f9c1786874e85906dabc733988929727960aa8d.css integrity="sha256-4nZQxjthQYTgpTzZn5wXhodOhZBtq8czmIkpcnlgqo0=" rel="preload stylesheet" as=style><link rel=icon href=https://dingyu.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dingyu.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dingyu.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://dingyu.dev/apple-touch-icon.png><link rel=mask-icon href=https://dingyu.dev/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://dingyu.dev/posts/grpc/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-XH8830R9KK"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XH8830R9KK")}</script><meta property="og:url" content="https://dingyu.dev/posts/grpc/"><meta property="og:site_name" content="Ding's Coding Forge"><meta property="og:title" content="[Protocol] RPC... 그리고 GRPC 톺아보기"><meta property="og:description" content="흔히들 (나만 그럴지도..?) rpc 통신을 한다 하면… HTTP/2 기반의 protocol Buffer를 사용하겠구나~ (grpc 구나) 라고 생각하기 마련이다. rpc는 무엇이고 grpc는 어째서 빠를까? 그리고 왜 사용할까?"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-06T00:00:00+00:00"><meta property="article:modified_time" content="2025-02-06T00:00:00+00:00"><meta property="article:tag" content="Grpc"><meta property="article:tag" content="Rpc"><meta property="article:tag" content="Protobuf"><meta property="article:tag" content="HTTP2.0"><meta property="og:image" content="https://dingyu.dev/posts/grpc/img/grpc.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dingyu.dev/posts/grpc/img/grpc.png"><meta name=twitter:title content="[Protocol] RPC... 그리고 GRPC 톺아보기"><meta name=twitter:description content="흔히들 (나만 그럴지도..?) rpc 통신을 한다 하면&mldr; HTTP/2 기반의 protocol Buffer를 사용하겠구나~ (grpc 구나) 라고 생각하기 마련이다. rpc는 무엇이고 grpc는 어째서 빠를까? 그리고 왜 사용할까?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://dingyu.dev/posts/"},{"@type":"ListItem","position":2,"name":"[Protocol] RPC... 그리고 GRPC 톺아보기","item":"https://dingyu.dev/posts/grpc/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[Protocol] RPC... 그리고 GRPC 톺아보기","name":"[Protocol] RPC... 그리고 GRPC 톺아보기","description":"흔히들 (나만 그럴지도..?) rpc 통신을 한다 하면\u0026hellip; HTTP/2 기반의 protocol Buffer를 사용하겠구나~ (grpc 구나) 라고 생각하기 마련이다. rpc는 무엇이고 grpc는 어째서 빠를까? 그리고 왜 사용할까?","keywords":["grpc","rpc","protobuf","HTTP2.0"],"articleBody":"RPC? Remote Procedure Call의 약자로 별도의 원격 제어를 위한 코딩 없이 다른 주소 공간에서 함수나 프로시저를 실행할 수 있게하는 프로세스 간 통신 기술 입니다.\n→ 즉, 내부적인 커넥션 과정과 데이터가 전달되는 일련의 과정을 추상화하는 Method를 사용하여, 실제로는 외부 통신을 하지만 코드상으로는 함수를 호출하는 것과 동일한 효과\nHTTP API 와 더불어 Client ↔ Server, Server ↔ Server 간 데이터를 주고 받을 때 사용되는 범용적인 통신 방법! 원격 프로시저 호출을 이용하여 프로그래머는 함수가 로컬이나 원격 위치에 있든 동일한 코드를 작성하여 기능을 활용할 수 있습니다. MSA 구조의 서비스에서 다양한 언어와 프레임워크로 개발되는 경우 프로토콜에 맞춰 통신해야 하는 비용이 발생한다.\n그러한 분산 컴퓨팅 환경에서 프로세스(서비스) 간 상호 통신 및 컴퓨팅 자원의 효율적인 사용을 위해서 발전된 기술이다.\n→ 애플리케이션이 점차 쪼개짐에 따라… 기존 모노 레포에서 함수를 호출하면 그만이던 것이.. 외부 통신을 거쳐야만 데이터 조회가 가능한 형태로 변경됨… → Server Process Time « Network Latency : 애플리케이션 코드 내에서의 최적화는 수ns 정도는 줄일 수 있겠지만, 실질적인 병목 구간인 네트워크 통신 비용에 대한 해결책으로 gRPC가 화두가 되기 시작함\nRPC 동작 방식 IDL(Interface Definition Language) 을 사용하여 서버의 호출 규약을 정의한다. 함수명, 인자, 반환값에 대한 데이터 형이 저장된 IDL 파일을 rpcgen 컴파일러를 이용하여 stub 코드를 자동으로 생성한다 (1) 우선 IDL(Interface Definition Language)를 통해 호출에 대한 인터페이스를 정의합니다.\n(2) IDL에 의해 정의된 인터페이스는 client의 stub과 server의 skeleton 생성의 기반이 되며, rcpgen(유틸리티)를 통해 각각의 stub과 skeleton을 생성합니다.\n(3) 클라이언트는 리모트의 프로시저를 사용하기 위해 설계된 스텁의 프로시저를 호출하고, 프로시저 호출에 필요한 인자와 비지니스에 로직에 필요한 메소드를 호출합니다.\n(4) 스텁은 서버가 이해할 수 있는 형태로 데이터의 캐스팅 진행하고, 서버 측 RPC로 호출을 진행합니다.\n(5) 서버는 수신된 호출에 대한 데이터를 처리합니다.\n(6) 서버측 RPC 프로토콜은 처리된 데이터를 캐스팅하여 클라이언트로 응답합니다.\nStub이 뭔가요? Stub은 원격 프로시저 호출(RPC)에서 클라이언트와 서버 간의 통신을 추상화하고 단순화하는 데 사용되는 코드 조각\nGRPC? gRPC는 Protocol Buffer를 IDL (Interface Definition Language) 및 메시지 교환 방식으로 사용합니다. 구조화된 데이터의 직렬화(Serialization), 역직렬화(Deserialization) 에 사용 클라이언트 어플리케이션에서 로컬 객체(method) 인 것처럼 다른 머신(remote) 에 있는 서버 어플리케이션의 메서드를 직접 호출 할 수 있다. 흔히들 (나만 그럴지도..?) rpc 통신을 한다 하면… HTTP/2 기반의 protocol Buffer를 사용하겠구나~ (grpc 구나) 라고 생각하기 마련이다.\n그치만… 실제 Stub 내부적인 원격 프로시저 호출의 구현체가 어떠한 프로토콜을 사용하여 구현되어 있는지는 알 수 없다\n즉, rpc != grpc 이며 RPC와 gRPC는 포함관계이다\nHTTP/1.1과 HTTP/2.0 HTTP는 TCP 위에서 동작하며, “Connection Oriented\"를 목적으로 둔 TCP 답게 “연결\"을 맺어야 데이터 송수신을 하게된다.\n흔히 알고 있는 HTTP/1.1 통신 흐름은 다음과 같다. TCP 연결 (3 way handshake) 데이터 송수신 TCP 연결 종료 (4 way handshake) 여러번 데이터를 주고 받아야 하는 상황에서 TCP 연결 및 종료에 따른 오버헤드는 무시할 수 없다. (특히나 물리적인 거리가 먼 경우에는… 어휴 😂)\n다행히도 HTTP/1.1에서는 Keep-Alive가 활성화되어 있어, 하나의 TCP 연결을 여러 HTTP 요청/응답에 재사용할 수 있다.\n주로 REST를 사용하는 Production 애플리케이션에서는 이러한 TCP 연결에 따른 오버헤드를 줄이고자 HTTP Client를 재사용하곤 한다.\n재사용할 수 있으면 큰 문제가 없지 않느냐..?\nKeep-Alive는 여러 요청을 하나의 TCP 연결에서 처리할 수 있지만, HTTP/1.1은 기본적으로 한 번에 하나의 요청만 처리 가능(직렬 처리) 여러 개의 요청을 동시에 처리하려면 여러 개의 TCP 연결을 만들어야 함 → 이로 인해 네트워크 오버헤드 증가 HTTP/1.1의 문제와 HTTP/2.0에서의 개선사항 HTTP/1.1 - Proxy로 인한 Keep-Alive의 치명적 문제 클라이언트가 프록시를 통해 HTTP 요청(Keep-Alive 포함)을 서버로 보냄. 프록시는 서버에 같은 요청을 전달하고, 서버도 Keep-Alive를 유지함. 서버가 응답을 보낸 후, Keep-Alive 상태에서 연결을 유지함. 일정 시간이 지나면, 프록시가 타임아웃을 감지하고 서버와의 연결을 강제 종료함. 클라이언트는 아직 연결이 살아 있다고 생각하고 새로운 요청을 보냄. 하지만 프록시는 이미 서버와의 연결을 닫았으므로 연결 재사용이 불가능하고 “Connection Reset” 오류 발생. HTTP/2.0 - PING과 GOAWAY를 통한 문제 해결 클라이언트가 Proxy를 통해 서버에 HTTP/2 요청 (GET /resource) 전송 서버가 200 OK (Keep-Alive) 응답 → 연결 유지 서버가 연결 종료 예정 → Proxy에게 GOAWAY 프레임 전송 Proxy가 클라이언트에게 GOAWAY 전달 → 새로운 요청 시 새 연결 사용하도록 유도 Proxy가 서버와의 연결 상태 확인 (PING 프레임 전송) → PING ACK 응답 받으면 연결 유지 서버가 Keep-Alive Timeout으로 연결 종료 → Proxy가 감지 클라이언트가 GET /another-resource 요청 → Proxy는 새로운 서버 연결 맺음 새로운 연결을 통해 요청 전달 및 200 OK 응답 반환 → 정상 처리 완료 물론 해당 이슈는 서버측에서 비정상 종료 시, graceful shutdown 과정에서 GOAWAY를 전달해야 가능하다\nHTTP/1.1 - HOL(Head-of-Line) Blocking 문제 클라이언트가 첫 번째 요청 (/slow-resource)을 보냄. 서버에서 이 요청을 처리하는 데 오랜 시간이 걸림. 클라이언트가 두 번째 요청 (/fast-resource)을 보냄. 하지만 HTTP/1.1에서는 한 개의 TCP 연결에서 요청을 순차적으로 처리해야 함. 따라서 두 번째 요청(fast-resource)은 첫 번째 요청(slow-resource)이 끝날 때까지 대기해야 함. 첫 번째 요청이 완료된 후에야 두 번째 요청 처리 가능. 두 번째 요청은 빠르게 처리할 수 있지만, 첫 번째 요청의 처리 지연으로 인해 응답이 늦어지는 HOL Blocking 발생. HTTP/2.0 - PING과 GOAWAY를 통한 문제 해결 클라이언트가 두 개의 요청 (/slow-resource, /fast-resource)을 보냄. HTTP/2에서는 Multiplexing을 통해 단일 TCP 연결에서 두 개의 요청을 동시에 전송. 서버가 먼저 응답이 가능한 요청(/fast-resource)을 처리하고 즉시 응답을 보냄. /slow-resource 처리가 완료된 후 해당 요청에 대한 응답을 별도로 전송. 결과적으로 HOL Blocking 없이 빠른 요청이 지연되지 않고 독립적으로 처리됨. Pros \u0026 Cons 구분 장점 (Pros) 단점 (Cons) 성능 HTTP/2 기반으로 멀티플렉싱, 헤더 압축, 스트리밍 지원 → 높은 성능 HTTP/2를 지원하지 않는 클라이언트와의 통신이 어려움 IDL (Interface Definition Language) Protocol Buffers(ProtoBuf)를 사용하여 강력한 타입 안정성과 코드 자동 생성 가능 ProtoBuf는 JSON보다 가독성이 낮고 사람이 직접 읽기 어려움 다양한 통신 방식 지원 Unary, Server Streaming, Client Streaming, Bi-directional Streaming 지원 복잡한 스트리밍 방식은 디버깅이 어려울 수 있음 다양한 언어 지원 Go, Java, Python, C++, Node.js 등 여러 언어에서 사용 가능 일부 언어에서는 gRPC 지원이 완벽하지 않거나 라이브러리 성숙도가 낮음 자동 코드 생성 .proto 파일을 기반으로 클라이언트와 서버 코드 자동 생성 추가적인 빌드 과정 필요 (protoc 컴파일러 사용) 보안 TLS 기반의 강력한 보안 제공 TLS 설정이 복잡할 수 있음 로드 밸런싱 클라이언트 사이드 로드 밸런싱 지원 기본적으로 제공하는 기능이 제한적이며, Envoy 등과 함께 사용하는 것이 일반적 스트리밍 지원 실시간 데이터 처리를 위한 스트리밍 API 제공 스트리밍을 활용한 서비스 구현이 상대적으로 복잡 트랜스포트 방식 Binary 기반 직렬화로 메시지 크기가 작고, 전송 속도가 빠름 RESTful API처럼 사람이 직접 요청을 보내거나 디버깅하기 어려움 브라우저 호환성 gRPC-Web을 통해 브라우저 지원 가능 기존 gRPC는 브라우저에서 직접 사용 불가하여 gRPC-Web 프록시 필요 ","wordCount":"976","inLanguage":"en","image":"https://dingyu.dev/posts/grpc/img/grpc.png","datePublished":"2025-02-06T00:00:00Z","dateModified":"2025-02-06T00:00:00Z","author":{"@type":"Person","name":"dingyu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://dingyu.dev/posts/grpc/"},"publisher":{"@type":"Organization","name":"Ding's Coding Forge","logo":{"@type":"ImageObject","url":"https://dingyu.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dingyu.dev/ accesskey=h title="Ding's Coding Forge (Alt + H)"><img src=https://dingyu.dev/apple-touch-icon.png alt aria-label=logo height=35>Ding's Coding Forge</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://dingyu.dev/about/ title=About><span>About</span></a></li><li><a href=https://dingyu.dev/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://dingyu.dev/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://dingyu.dev/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://dingyu.dev/search/ title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://dingyu.dev/>Home</a>&nbsp;»&nbsp;<a href=https://dingyu.dev/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">[Protocol] RPC... 그리고 GRPC 톺아보기</h1><div class=post-meta><span title='2025-02-06 00:00:00 +0000 UTC'>February 6, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;976 words&nbsp;·&nbsp;dingyu&nbsp;|&nbsp;<a href=https://github.com/dings-things/blog/tree/main/content/posts/grpc/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://dingyu.dev/img/grpc.png alt></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#rpc aria-label=RPC?>RPC?</a><ul><li><a href=#rpc-%eb%8f%99%ec%9e%91-%eb%b0%a9%ec%8b%9d aria-label="RPC 동작 방식">RPC 동작 방식</a><ul><ul><li><a href=#stub%ec%9d%b4-%eb%ad%94%ea%b0%80%ec%9a%94 aria-label="Stub이 뭔가요?">Stub이 뭔가요?</a></li></ul></ul></li></ul></li><li><a href=#grpc aria-label=GRPC?>GRPC?</a><ul><li><a href=#http11%ea%b3%bc-http20 aria-label="HTTP/1.1과 HTTP/2.0">HTTP/1.1과 HTTP/2.0</a><ul><li><a href=#http11%ec%9d%98-%eb%ac%b8%ec%a0%9c%ec%99%80-http20%ec%97%90%ec%84%9c%ec%9d%98-%ea%b0%9c%ec%84%a0%ec%82%ac%ed%95%ad aria-label="HTTP/1.1의 문제와 HTTP/2.0에서의 개선사항">HTTP/1.1의 문제와 HTTP/2.0에서의 개선사항</a><ul><li><a href=#http11---proxy%eb%a1%9c-%ec%9d%b8%ed%95%9c-keep-alive%ec%9d%98-%ec%b9%98%eb%aa%85%ec%a0%81-%eb%ac%b8%ec%a0%9c aria-label="HTTP/1.1 - Proxy로 인한 Keep-Alive의 치명적 문제">HTTP/1.1 - Proxy로 인한 Keep-Alive의 치명적 문제</a></li><li><a href=#http20---ping%ea%b3%bc-goaway%eb%a5%bc-%ed%86%b5%ed%95%9c-%eb%ac%b8%ec%a0%9c-%ed%95%b4%ea%b2%b0 aria-label="HTTP/2.0 - PING과 GOAWAY를 통한 문제 해결">HTTP/2.0 - PING과 GOAWAY를 통한 문제 해결</a></li><li><a href=#http11---holhead-of-line-blocking-%eb%ac%b8%ec%a0%9c aria-label="HTTP/1.1 - HOL(Head-of-Line) Blocking 문제">HTTP/1.1 - HOL(Head-of-Line) Blocking 문제</a></li><li><a href=#http20---ping%ea%b3%bc-goaway%eb%a5%bc-%ed%86%b5%ed%95%9c-%eb%ac%b8%ec%a0%9c-%ed%95%b4%ea%b2%b0-1 aria-label="HTTP/2.0 - PING과 GOAWAY를 통한 문제 해결">HTTP/2.0 - PING과 GOAWAY를 통한 문제 해결</a></li></ul></li></ul></li><li><a href=#pros--cons aria-label="Pros & Cons">Pros & Cons</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=rpc>RPC?<a hidden class=anchor aria-hidden=true href=#rpc>#</a></h1><blockquote><p><code>Remote Procedure Call</code>의 약자로 별도의 원격 제어를 위한 코딩 없이 다른 주소 공간에서 함수나 프로시저를 실행할 수 있게하는 프로세스 간 통신 기술 입니다.</p></blockquote><p>→ 즉, 내부적인 커넥션 과정과 데이터가 전달되는 일련의 과정을 추상화하는 Method를 사용하여, 실제로는 외부 통신을 하지만 코드상으로는 함수를 호출하는 것과 동일한 효과</p><blockquote><p>HTTP API 와 더불어 <strong>Client ↔ Server, Server ↔ Server</strong> 간 데이터를 주고 받을 때 사용되는 범용적인 통신 방법!
원격 프로시저 호출을 이용하여 프로그래머는 함수가 로컬이나 원격 위치에 있든 동일한 코드를 작성하여 기능을 활용할 수 있습니다.
MSA 구조의 서비스에서 다양한 언어와 프레임워크로 개발되는 경우 프로토콜에 맞춰 통신해야 하는 비용이 발생한다.</p><p>그러한 분산 컴퓨팅 환경에서 프로세스(서비스) 간 상호 통신 및 컴퓨팅 자원의 효율적인 사용을 위해서 발전된 기술이다.</p></blockquote><p>→ 애플리케이션이 점차 쪼개짐에 따라&mldr; 기존 모노 레포에서 함수를 호출하면 그만이던 것이.. 외부 통신을 거쳐야만 데이터 조회가 가능한 형태로 변경됨&mldr;
<img loading=lazy src=/posts/grpc/network-io-latency.png>
→ <strong>Server Process Time &#171; Network Latency</strong> : 애플리케이션 코드 내에서의 최적화는 수ns 정도는 줄일 수 있겠지만, 실질적인 병목 구간인 네트워크 통신 비용에 대한 해결책으로 <code>gRPC</code>가 화두가 되기 시작함</p><h2 id=rpc-동작-방식>RPC 동작 방식<a hidden class=anchor aria-hidden=true href=#rpc-동작-방식>#</a></h2><p><img loading=lazy src=/posts/grpc/rpc.png></p><ul><li>IDL(Interface Definition Language) 을 사용하여 서버의 호출 규약을 정의한다.</li><li>함수명, 인자, 반환값에 대한 데이터 형이 저장된 IDL 파일을 rpcgen 컴파일러를 이용하여 stub 코드를 자동으로 생성한다</li></ul><hr><p>(1) 우선 IDL(Interface Definition Language)를 통해 호출에 대한 인터페이스를 정의합니다.</p><p>(2) IDL에 의해 정의된 인터페이스는 client의 stub과 server의 skeleton 생성의 기반이 되며, rcpgen(유틸리티)를 통해 각각의 stub과 skeleton을 생성합니다.</p><p>(3) 클라이언트는 리모트의 프로시저를 사용하기 위해 설계된 스텁의 프로시저를 호출하고, 프로시저 호출에 필요한 인자와 비지니스에 로직에 필요한 메소드를 호출합니다.</p><p>(4) 스텁은 서버가 이해할 수 있는 형태로 데이터의 캐스팅 진행하고, 서버 측 RPC로 호출을 진행합니다.</p><p>(5) 서버는 수신된 호출에 대한 데이터를 처리합니다.</p><p>(6) 서버측 RPC 프로토콜은 처리된 데이터를 캐스팅하여 클라이언트로 응답합니다.</p><hr><blockquote><h4 id=stub이-뭔가요>Stub이 뭔가요?<a hidden class=anchor aria-hidden=true href=#stub이-뭔가요>#</a></h4><p><code>Stub</code>은 원격 프로시저 호출(RPC)에서 클라이언트와 서버 간의 통신을 추상화하고 단순화하는 데 사용되는 코드 조각</p></blockquote><h1 id=grpc>GRPC?<a hidden class=anchor aria-hidden=true href=#grpc>#</a></h1><ul><li><code>gRPC</code>는 <code>Protocol Buffer</code>를 IDL (Interface Definition Language) 및 메시지 교환 방식으로 사용합니다.<ul><li>구조화된 데이터의 <strong>직렬화(Serialization), 역직렬화(Deserialization)</strong> 에 사용</li></ul></li><li>클라이언트 어플리케이션에서 로컬 객체(method) 인 것처럼 다른 머신(remote) 에 있는 서버 어플리케이션의 메서드를 직접 호출 할 수 있다.</li></ul><blockquote><p>흔히들 (나만 그럴지도..?) rpc 통신을 한다 하면&mldr; HTTP/2 기반의 protocol Buffer를 사용하겠구나~ (grpc 구나) 라고 생각하기 마련이다.</p><p>그치만&mldr; 실제 Stub 내부적인 원격 프로시저 호출의 구현체가 어떠한 프로토콜을 사용하여 구현되어 있는지는 알 수 없다</p><p>즉, <strong>rpc != grpc</strong> 이며 RPC와 gRPC는 포함관계이다</p></blockquote><h2 id=http11과-http20>HTTP/1.1과 HTTP/2.0<a hidden class=anchor aria-hidden=true href=#http11과-http20>#</a></h2><p><code>HTTP</code>는 <code>TCP</code> 위에서 동작하며, &ldquo;Connection Oriented"를 목적으로 둔 <code>TCP</code> 답게 &ldquo;연결"을 맺어야 데이터 송수신을 하게된다.</p><p>흔히 알고 있는 <code>HTTP/1.1</code> 통신 흐름은 다음과 같다.
<img loading=lazy src=/posts/grpc/image-3.png></p><ol><li>TCP 연결 (3 way handshake)</li><li>데이터 송수신</li><li>TCP 연결 종료 (4 way handshake)</li></ol><p>여러번 데이터를 주고 받아야 하는 상황에서 TCP 연결 및 종료에 따른 오버헤드는 무시할 수 없다. (특히나 물리적인 거리가 먼 경우에는&mldr; 어휴 😂)</p><p>다행히도 <code>HTTP/1.1</code>에서는 <code>Keep-Alive</code>가 활성화되어 있어, 하나의 TCP 연결을 여러 HTTP 요청/응답에 재사용할 수 있다.</p><blockquote><p>주로 REST를 사용하는 Production 애플리케이션에서는 이러한 TCP 연결에 따른 오버헤드를 줄이고자 <strong>HTTP Client를 재사용</strong>하곤 한다.</p></blockquote><p>재사용할 수 있으면 큰 문제가 없지 않느냐..?</p><blockquote><ul><li>Keep-Alive는 여러 요청을 하나의 TCP 연결에서 처리할 수 있지만, HTTP/1.1은 기본적으로 <strong>한 번에 하나의 요청만 처리 가능(직렬 처리)</strong></li><li>여러 개의 요청을 동시에 처리하려면 <strong>여러 개의 TCP 연결을 만들어야 함</strong> → 이로 인해 <strong>네트워크 오버헤드 증가</strong></li></ul></blockquote><h3 id=http11의-문제와-http20에서의-개선사항>HTTP/1.1의 문제와 HTTP/2.0에서의 개선사항<a hidden class=anchor aria-hidden=true href=#http11의-문제와-http20에서의-개선사항>#</a></h3><h4 id=http11---proxy로-인한-keep-alive의-치명적-문제>HTTP/1.1 - Proxy로 인한 Keep-Alive의 치명적 문제<a hidden class=anchor aria-hidden=true href=#http11---proxy로-인한-keep-alive의-치명적-문제>#</a></h4><p><img loading=lazy src=/posts/grpc/image-4.png></p><ol><li>클라이언트가 프록시를 통해 HTTP 요청(Keep-Alive 포함)을 서버로 보냄.</li><li>프록시는 서버에 같은 요청을 전달하고, <strong>서버도 Keep-Alive를 유지</strong>함.</li><li>서버가 응답을 보낸 후, <strong>Keep-Alive 상태에서 연결을 유지</strong>함.</li><li>일정 시간이 지나면, <strong>프록시가 타임아웃을 감지하고 서버와의 연결을 강제 종료</strong>함.</li><li>클라이언트는 아직 연결이 살아 있다고 생각하고 <strong>새로운 요청을 보냄</strong>.</li><li>하지만 프록시는 이미 서버와의 연결을 닫았으므로 <strong>연결 재사용이 불가능하고 &ldquo;Connection Reset&rdquo; 오류 발생</strong>.</li></ol><h4 id=http20---ping과-goaway를-통한-문제-해결>HTTP/2.0 - PING과 GOAWAY를 통한 문제 해결<a hidden class=anchor aria-hidden=true href=#http20---ping과-goaway를-통한-문제-해결>#</a></h4><p><img loading=lazy src=/posts/grpc/image-7.png></p><ul><li><strong>클라이언트가 Proxy를 통해 서버에 HTTP/2 요청 (<code>GET /resource</code>) 전송</strong></li><li><strong>서버가 <code>200 OK (Keep-Alive)</code> 응답 → 연결 유지</strong></li><li><strong>서버가 연결 종료 예정 → Proxy에게 <code>GOAWAY</code> 프레임 전송</strong></li><li><strong>Proxy가 클라이언트에게 <code>GOAWAY</code> 전달 → 새로운 요청 시 새 연결 사용하도록 유도</strong></li><li><strong>Proxy가 서버와의 연결 상태 확인 (<code>PING</code> 프레임 전송) → <code>PING ACK</code> 응답 받으면 연결 유지</strong></li><li><strong>서버가 Keep-Alive Timeout으로 연결 종료 → Proxy가 감지</strong></li><li><strong>클라이언트가 <code>GET /another-resource</code> 요청 → Proxy는 새로운 서버 연결 맺음</strong></li><li><strong>새로운 연결을 통해 요청 전달 및 <code>200 OK</code> 응답 반환 → 정상 처리 완료</strong></li></ul><blockquote><p>물론 해당 이슈는 서버측에서 비정상 종료 시, graceful shutdown 과정에서 <code>GOAWAY</code>를 전달해야 가능하다</p></blockquote><h4 id=http11---holhead-of-line-blocking-문제>HTTP/1.1 - HOL(Head-of-Line) Blocking 문제<a hidden class=anchor aria-hidden=true href=#http11---holhead-of-line-blocking-문제>#</a></h4><p><img loading=lazy src=/posts/grpc/image-5.png></p><ol><li><strong>클라이언트가 첫 번째 요청</strong> (<code>/slow-resource</code>)을 보냄.<ul><li>서버에서 이 요청을 처리하는 데 <strong>오랜 시간이 걸림</strong>.</li></ul></li><li><strong>클라이언트가 두 번째 요청</strong> (<code>/fast-resource</code>)을 보냄.<ul><li>하지만 <strong>HTTP/1.1에서는 한 개의 TCP 연결에서 요청을 순차적으로 처리해야 함</strong>.</li><li>따라서 두 번째 요청(<code>fast-resource</code>)은 첫 번째 요청(<code>slow-resource</code>)이 끝날 때까지 <strong>대기해야 함</strong>.</li></ul></li><li><strong>첫 번째 요청이 완료된 후에야 두 번째 요청 처리 가능</strong>.<ul><li>두 번째 요청은 빠르게 처리할 수 있지만, <strong>첫 번째 요청의 처리 지연으로 인해 응답이 늦어지는 HOL Blocking 발생</strong>.</li></ul></li></ol><h4 id=http20---ping과-goaway를-통한-문제-해결-1>HTTP/2.0 - PING과 GOAWAY를 통한 문제 해결<a hidden class=anchor aria-hidden=true href=#http20---ping과-goaway를-통한-문제-해결-1>#</a></h4><p><img loading=lazy src=/posts/grpc/image-8.png></p><ol><li><strong>클라이언트가 두 개의 요청 (<code>/slow-resource</code>, <code>/fast-resource</code>)을 보냄.</strong></li><li><strong>HTTP/2에서는 Multiplexing을 통해 단일 TCP 연결에서 두 개의 요청을 동시에 전송.</strong></li><li><strong>서버가 먼저 응답이 가능한 요청(<code>/fast-resource</code>)을 처리하고 즉시 응답을 보냄.</strong></li><li><strong><code>/slow-resource</code> 처리가 완료된 후 해당 요청에 대한 응답을 별도로 전송.</strong></li><li><strong>결과적으로 HOL Blocking 없이 빠른 요청이 지연되지 않고 독립적으로 처리됨.</strong></li></ol><h2 id=pros--cons>Pros & Cons<a hidden class=anchor aria-hidden=true href=#pros--cons>#</a></h2><table><thead><tr><th><strong>구분</strong></th><th><strong>장점 (Pros)</strong></th><th><strong>단점 (Cons)</strong></th></tr></thead><tbody><tr><td><strong>성능</strong></td><td>HTTP/2 기반으로 멀티플렉싱, 헤더 압축, 스트리밍 지원 → 높은 성능</td><td>HTTP/2를 지원하지 않는 클라이언트와의 통신이 어려움</td></tr><tr><td><strong>IDL (Interface Definition Language)</strong></td><td>Protocol Buffers(ProtoBuf)를 사용하여 강력한 타입 안정성과 코드 자동 생성 가능</td><td>ProtoBuf는 JSON보다 가독성이 낮고 사람이 직접 읽기 어려움</td></tr><tr><td><strong>다양한 통신 방식 지원</strong></td><td>Unary, Server Streaming, Client Streaming, Bi-directional Streaming 지원</td><td>복잡한 스트리밍 방식은 디버깅이 어려울 수 있음</td></tr><tr><td><strong>다양한 언어 지원</strong></td><td>Go, Java, Python, C++, Node.js 등 여러 언어에서 사용 가능</td><td>일부 언어에서는 gRPC 지원이 완벽하지 않거나 라이브러리 성숙도가 낮음</td></tr><tr><td><strong>자동 코드 생성</strong></td><td><code>.proto</code> 파일을 기반으로 클라이언트와 서버 코드 자동 생성</td><td>추가적인 빌드 과정 필요 (<code>protoc</code> 컴파일러 사용)</td></tr><tr><td><strong>보안</strong></td><td>TLS 기반의 강력한 보안 제공</td><td>TLS 설정이 복잡할 수 있음</td></tr><tr><td><strong>로드 밸런싱</strong></td><td>클라이언트 사이드 로드 밸런싱 지원</td><td>기본적으로 제공하는 기능이 제한적이며, Envoy 등과 함께 사용하는 것이 일반적</td></tr><tr><td><em><strong>스트리밍 지원</strong></em></td><td>실시간 데이터 처리를 위한 스트리밍 API 제공</td><td>스트리밍을 활용한 서비스 구현이 상대적으로 복잡</td></tr><tr><td><strong>트랜스포트 방식</strong></td><td>Binary 기반 직렬화로 메시지 크기가 작고, 전송 속도가 빠름</td><td>RESTful API처럼 사람이 직접 요청을 보내거나 디버깅하기 어려움</td></tr><tr><td><strong>브라우저 호환성</strong></td><td>gRPC-Web을 통해 브라우저 지원 가능</td><td>기존 gRPC는 브라우저에서 직접 사용 불가하여 gRPC-Web 프록시 필요</td></tr></tbody></table></div><footer class=post-footer><ul class=post-tags><li><a href=https://dingyu.dev/tags/grpc/>Grpc</a></li><li><a href=https://dingyu.dev/tags/rpc/>Rpc</a></li><li><a href=https://dingyu.dev/tags/protobuf/>Protobuf</a></li><li><a href=https://dingyu.dev/tags/http2.0/>HTTP2.0</a></li></ul><nav class=paginav><a class=prev href=https://dingyu.dev/posts/schema-registry/><span class=title>« Prev</span><br><span>[EDA] Schema Registry</span>
</a><a class=next href=https://dingyu.dev/posts/go-convention/><span class=title>Next »</span><br><span>[Go] Go Convention</span></a></nav></footer><div id=giscus_thread><script src=https://giscus.app/client.js data-repo=dings-things/blog data-repo-id=R_kgDON9IuAw data-category=Announcements data-category-id=DIC_kwDON9IuA84CnTai data-mapping=og:title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=ko data-loading=lazy crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://dingyu.dev/>Ding's Coding Forge</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>
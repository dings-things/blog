<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[Infra] 쿠버네틱스 무중단 배포 설정하기 | Ding's Coding Forge</title>
<meta name=keywords content="k8s,zero-downtime"><meta name=description content="During our migration from IDC to EKS, we encountered numerous challenges—including security configurations, network settings, databases, and ultimately, application deployments. After each deployment, we frequently faced 502 and 504 errors without a clear solution. Since minimizing downtime was critical, I’ll share how we overcame these 502 and 504 issues."><meta name=author content="dingyu"><link rel=canonical href=https://dingyu.dev/posts/k8s-zero-downtime/><meta name=google-site-verification content="8XY1hI6NVxQIrN7bQbnX-9TG9HHFw5HOQmlb6vcsFdQ"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.e27650c63b614184e0a53cd99f9c1786874e85906dabc733988929727960aa8d.css integrity="sha256-4nZQxjthQYTgpTzZn5wXhodOhZBtq8czmIkpcnlgqo0=" rel="preload stylesheet" as=style><link rel=icon href=https://dingyu.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dingyu.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dingyu.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://dingyu.dev/apple-touch-icon.png><link rel=mask-icon href=https://dingyu.dev/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://dingyu.dev/posts/k8s-zero-downtime/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-XH8830R9KK"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XH8830R9KK")}</script><meta property="og:url" content="https://dingyu.dev/posts/k8s-zero-downtime/"><meta property="og:site_name" content="Ding's Coding Forge"><meta property="og:title" content="[Infra] 쿠버네틱스 무중단 배포 설정하기"><meta property="og:description" content="During our migration from IDC to EKS, we encountered numerous challenges—including security configurations, network settings, databases, and ultimately, application deployments. After each deployment, we frequently faced 502 and 504 errors without a clear solution. Since minimizing downtime was critical, I’ll share how we overcame these 502 and 504 issues."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-08-16T00:00:00+00:00"><meta property="article:modified_time" content="2024-08-16T00:00:00+00:00"><meta property="article:tag" content="K8s"><meta property="article:tag" content="Zero-Downtime"><meta property="og:image" content="https://dingyu.dev/posts/k8s-zero-downtime/img/kubernetes.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dingyu.dev/posts/k8s-zero-downtime/img/kubernetes.png"><meta name=twitter:title content="[Infra] 쿠버네틱스 무중단 배포 설정하기"><meta name=twitter:description content="During our migration from IDC to EKS, we encountered numerous challenges—including security configurations, network settings, databases, and ultimately, application deployments. After each deployment, we frequently faced 502 and 504 errors without a clear solution. Since minimizing downtime was critical, I’ll share how we overcame these 502 and 504 issues."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://dingyu.dev/posts/"},{"@type":"ListItem","position":2,"name":"[Infra] 쿠버네틱스 무중단 배포 설정하기","item":"https://dingyu.dev/posts/k8s-zero-downtime/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[Infra] 쿠버네틱스 무중단 배포 설정하기","name":"[Infra] 쿠버네틱스 무중단 배포 설정하기","description":"During our migration from IDC to EKS, we encountered numerous challenges—including security configurations, network settings, databases, and ultimately, application deployments. After each deployment, we frequently faced 502 and 504 errors without a clear solution. Since minimizing downtime was critical, I’ll share how we overcame these 502 and 504 issues.","keywords":["k8s","zero-downtime"],"articleBody":"배경 k8s 환경 Deploy 후, 부하테스트 과정에서 간헐적으로 502 / 504 에러 발생 확인 Pod들이 교체 되면서 기존 요청에 대한 응답을 반환하지 못한 채 종료 됨 → 504 Gateway Timeout 신규 Pod이 올라가고 대체되는 Pod이 Terminate 됨 → 502 Bad Gateway 롤링업데이트가 진행되지만 Readiness Probe 설정 없이는 순단이 발생할 여지가 있음을 확인\n설정 부하테스트 툴 설치 bombardier : 쉽고 간편한 go cli 부하테스트 툴 vegeta : 스크립트 작성으로 보다 유연한 요청 가능, status code 를 상세히 응답하는 툴\n각 툴의 자세한 설치 과정은 생략 합니다.\nReadniess Probe Pod이 서비스 트래픽을 처리할 준비가 되었는지를 판단하는 데 사용되는 메커니즘\n특정 컨테이너가 시작된 후에도 일부 작업이 완료될 때까지 외부 트래픽을 처리할 준비가 되지 않았을 수 있기 때문에 이를 확인하는 역할을 함\n트래픽 라우팅 제어: Readiness Probe가 성공적으로 완료될 때까지 Kubernetes는 해당 Pod으로 트래픽을 라우팅하지 않습니다. 이는 Pod이 준비되지 않은 상태에서 요청을 처리하지 않도록 보장합니다. 준비가 완료된 후에만 트래픽이 Pod으로 라우팅되기 때문에, Pod이 올바르게 설정되고 필요한 리소스를 확보한 상태에서만 요청을 처리하게 됩니다. Pod의 상태 확인: Readiness Probe는 특정 조건이 충족될 때까지 Kubernetes에 Pod이 트래픽을 받을 준비가 되지 않았다고 알리며, 준비가 완료된 후에는 트래픽을 받을 준비가 되었음을 알립니다. Pod이 준비되지 않은 경우, Kubernetes는 Pod을 서비스의 엔드포인트에서 제거합니다. 502가 발생하는 원인 중 하나이다\nReadiness Probe를 지정하지 않은 경우, 컨테이너가 올라가는 시점에서 트래픽이 들어오게 된다.\n이때에, Pod 내부의 서버 초기화가 완전히 되지 않은 시점에서 요청이 온 경우 → 502 Bad Gateway를 응답한다\ndeployment.yml 수정 사항 ... readinessProbe: httpGet: port: 8080 path: /alive scheme: HTTP initialDelaySeconds: 30 periodSeconds: 30 ... Healthcheck 응답용 Endpoint를 생성해두고 응답 상태코드가 200으로 돌아오면 요청을 받는 형식으로 설정\n테스트 bombardier -c 200 -d 3m -l https://{endpoint} [================================================================================================================] 3m0s Done! Statistics Avg Stdev Max Reqs/sec 4205.76 1250.10 16927.12 Latency 47.81ms 10.16ms 2.07s Latency Distribution 50% 45.08ms 75% 49.77ms 90% 57.60ms 95% 64.29ms 99% 81.95ms HTTP codes: 1xx - 0, 2xx - 0, 3xx - 0, 4xx - 753060, 5xx - 12 others - 0 Throughput: 3.24MB/s 여전히 5XX 에러는 존재한다.\nlifecycle \u0026 preStop lifecycle 설정이란? 컨테이너의 생명주기 동안 특정 시점에 실행될 작업을 정의할 수 있는 Kubernetes의 구성 옵션 (AOP와 유사…하다는 생각)\npostStart: 컨테이너가 시작된 직후에 실행됩니다. 컨테이너가 시작된 후 추가적인 초기화 작업을 수행하는 데 사용 preStop: 컨테이너가 종료되기 직전에 실행됩니다. 종료 전에 필요한 작업을 수행하도록 설정 가능 preStop preStop 훅은 컨테이너가 종료될 때 실행되는 스크립트나 명령어를 지정. 이 훅은 컨테이너가 종료되기 전에 반드시 수행해야 하는 작업이 있을 때 매우 유용\n트래픽 분리: Pod이 종료되기 전에 해당 Pod을 서비스 트래픽에서 안전하게 분리하기 위해 사용됩니다. 정리 작업: 종료 전에 리소스 정리, 연결 종료, 파일 저장 등의 작업을 수행할 수 있습니다. 대기 시간 설정: 컨테이너가 실제로 종료되기 전에 일정 시간 동안 대기하도록 설정하여, 클라이언트와의 연결이 완전히 종료되도록 할 수 있습니다. 앞서 설정한 Readiness Probe 설정 이후에도, lifecycle 설정을 하지 않는다면 간헐적인 502 에러가 발생될 수 있다\n파드는 종료될 때 SIGTERM, SIGKILL 처리와 서비스 제외 처리가 비동기로 처리됨\n서비스가 분리되기 전에 Pod이 클라이언트 요청에 정상적으로 응답할 수 없을 수 있다.\n즉, 서비스 분리 → 잔류하는 요청 처리 → pod 종료 를 통해 Graceful Shutdown이 가능하도록 설정한다\ndeployment.yml 수정 사항 ... lifecycle: preStop: exec: command: - /bin/sh - -c - sleep 40 # 서비스 분리가 발생한 후 40초 동안 대기 ... 컨테이너 종료 요청: Kubernetes가 Pod을 종료하기로 결정하면, 컨테이너에 SIGTERM 신호 preStop 훅 실행: SIGTERM 신호가 전송된 후, sleep 40 실행, 컨테이너가 40초 동안 대기 유예 기간 시작 (terminationGracePeriodSeconds): preStop 훅이 실행되면서, 동시에 terminationGracePeriodSeconds에 정의된 유예 기간이 시작 이 기간 동안 Kubernetes는 컨테이너가 정상적으로 종료되기를 대기 컨테이너 종료: preStop 훅이 완료되고, 유예 기간이 끝나면 Kubernetes는 컨테이너를 종료 테스트 bombardier -c 200 -d 3m -l https://{endpoint} [================================================================================================================] 3m0s Done! Statistics Avg Stdev Max Reqs/sec 4205.05 1355.65 20756.97 Latency 47.92ms 8.71ms 2.07s Latency Distribution 50% 45.47ms 75% 49.26ms 90% 57.32ms 95% 64.39ms 99% 80.67ms HTTP codes: 1xx - 0, 2xx - 751239, 3xx - 0, 4xx - 0, 5xx - 3 others - 0 Throughput: 2.82MB/s 여전히 5XX 에러는 존재한다.\nterminationGracePeriodSeconds Pod 종료 시나리오:\nKubernetes가 Pod을 종료하기로 결정하면, 먼저 Pod 내의 컨테이너에 SIGTERM 신호를 보냄 SIGTERM 신호를 받은 애플리케이션은 현재 처리 중인 요청을 완료하고, 필요한 정리 작업을 수행 가능 유예 기간 설정:\nterminationGracePeriodSeconds는 이 유예 기간을 정의. 이 기간 동안 Kubernetes는 컨테이너가 정상적으로 종료될 시간을 대기 기본값은 30초입니다. 이 시간이 지나면 Kubernetes는 컨테이너가 여전히 실행 중인 경우 강제로 종료(SIGKILL) SIGKILL 신호:\nterminationGracePeriodSeconds 기간이 만료되었을 때도 컨테이너가 종료되지 않았다면, Kubernetes는 SIGKILL 신호를 줌, 애플리케이션이 강제 종료됨 일정 lifecycle.preStop 설정을 통해, 40초의 유예시간을 두어 애플리케이션에 잔류하는 요청을 응답할 시간을 주었음.\n하지만 terminationGracePeriodSeconds 는 기본 30초로 설정되기에 30초가 지나도록 Pod이 실행중인 경우 SIGKILL을 전송하여 파드를 강제 종료시킴\ndeployment.yml 수정 사항 ... terminationGracePeriodSeconds: 50 ... INGRESS와 연결된 ALB 속성을 꼭 확인하자! terminationGracePeriodSeconds가 ALB 타임아웃보다 긴 경우, 특정 시나리오에서 504 Gateway Timeout 오류가 발생할 수 있음\n예상 발생 시나리오 : 요청 중간에 종료 발생 → ALB 타임아웃 도달 → 응답 전 Pod 종료\n이를 예방하기 위해, lifecycle.preStop (40s) \u003c terminationGracePeriodSeconds (50s) \u003c ALB Timeout (60s) 로 지정\n테스트 bombardier -c 200 -d 3m -l https://{endpoint} [================================================================================================================] 3m0s Done! Statistics Avg Stdev Max Reqs/sec 4293.51 1286.80 12924.64 Latency 46.74ms 8.94ms 547.25ms Latency Distribution 50% 44.48ms 75% 46.87ms 90% 54.16ms 95% 66.82ms 99% 81.69ms HTTP codes: 1xx - 0, 2xx - 770240, 3xx - 0, 4xx - 0, 5xx - 0 others - 0 Throughput: 2.89MB/s REF 카카오 테크 k8s 무중단 배포 Pod 라이프사이클 ","wordCount":"855","inLanguage":"en","image":"https://dingyu.dev/posts/k8s-zero-downtime/img/kubernetes.png","datePublished":"2024-08-16T00:00:00Z","dateModified":"2024-08-16T00:00:00Z","author":{"@type":"Person","name":"dingyu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://dingyu.dev/posts/k8s-zero-downtime/"},"publisher":{"@type":"Organization","name":"Ding's Coding Forge","logo":{"@type":"ImageObject","url":"https://dingyu.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dingyu.dev/ accesskey=h title="Ding's Coding Forge (Alt + H)"><img src=https://dingyu.dev/apple-touch-icon.png alt aria-label=logo height=35>Ding's Coding Forge</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://dingyu.dev/about/ title=About><span>About</span></a></li><li><a href=https://dingyu.dev/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://dingyu.dev/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://dingyu.dev/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://dingyu.dev/search/ title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://dingyu.dev/>Home</a>&nbsp;»&nbsp;<a href=https://dingyu.dev/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">[Infra] 쿠버네틱스 무중단 배포 설정하기</h1><div class=post-description>During our migration from IDC to EKS, we encountered numerous challenges—including security configurations, network settings, databases, and ultimately, application deployments. After each deployment, we frequently faced 502 and 504 errors without a clear solution. Since minimizing downtime was critical, I’ll share how we overcame these 502 and 504 issues.</div><div class=post-meta><span title='2024-08-16 00:00:00 +0000 UTC'>August 16, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;855 words&nbsp;·&nbsp;dingyu&nbsp;|&nbsp;<a href=https://github.com/dings-things/blog/tree/main/content/posts/k8s-zero-downtime/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://dingyu.dev/img/kubernetes.png alt></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%eb%b0%b0%ea%b2%bd aria-label=배경>배경</a></li><li><a href=#%ec%84%a4%ec%a0%95 aria-label=설정>설정</a><ul><li><a href=#%eb%b6%80%ed%95%98%ed%85%8c%ec%8a%a4%ed%8a%b8-%ed%88%b4-%ec%84%a4%ec%b9%98 aria-label="부하테스트 툴 설치">부하테스트 툴 설치</a></li><li><a href=#readniess-probe aria-label="Readniess Probe">Readniess Probe</a><ul><ul><li><a href=#deploymentyml-%ec%88%98%ec%a0%95-%ec%82%ac%ed%95%ad aria-label="deployment.yml 수정 사항">deployment.yml 수정 사항</a></li><li><a href=#%ed%85%8c%ec%8a%a4%ed%8a%b8 aria-label=테스트>테스트</a></li></ul></ul></li><li><a href=#lifecycle--prestop aria-label="lifecycle & preStop">lifecycle & preStop</a><ul><ul><li><a href=#deploymentyml-%ec%88%98%ec%a0%95-%ec%82%ac%ed%95%ad-1 aria-label="deployment.yml 수정 사항">deployment.yml 수정 사항</a></li><li><a href=#%ed%85%8c%ec%8a%a4%ed%8a%b8-1 aria-label=테스트>테스트</a></li></ul></ul></li><li><a href=#terminationgraceperiodseconds aria-label=terminationGracePeriodSeconds>terminationGracePeriodSeconds</a><ul><ul><li><a href=#deploymentyml-%ec%88%98%ec%a0%95-%ec%82%ac%ed%95%ad-2 aria-label="deployment.yml 수정 사항">deployment.yml 수정 사항</a></li><li><a href=#%ed%85%8c%ec%8a%a4%ed%8a%b8-2 aria-label=테스트>테스트</a></li></ul><li><a href=#ref aria-label=REF>REF</a></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=배경>배경<a hidden class=anchor aria-hidden=true href=#배경>#</a></h1><hr><ul><li>k8s 환경 Deploy 후, 부하테스트 과정에서 간헐적으로 502 / 504 에러 발생 확인</li><li>Pod들이 교체 되면서 기존 요청에 대한 응답을 반환하지 못한 채 종료 됨 → 504 Gateway Timeout</li><li>신규 Pod이 올라가고 대체되는 Pod이 Terminate 됨 → 502 Bad Gateway</li></ul><p>롤링업데이트가 진행되지만 <strong>Readiness Probe 설정 없이는 순단이 발생</strong>할 여지가 있음을 확인</p><h1 id=설정>설정<a hidden class=anchor aria-hidden=true href=#설정>#</a></h1><hr><h2 id=부하테스트-툴-설치>부하테스트 툴 설치<a hidden class=anchor aria-hidden=true href=#부하테스트-툴-설치>#</a></h2><p><a href=https://github.com/codesenberg/bombardier>bombardier</a> : 쉽고 간편한 go cli 부하테스트 툴
<a href=https://github.com/tsenart/vegeta>vegeta</a> : 스크립트 작성으로 보다 유연한 요청 가능, status code 를 상세히 응답하는 툴</p><p>각 툴의 자세한 설치 과정은 생략 합니다.</p><hr><h2 id=readniess-probe>Readniess Probe<a hidden class=anchor aria-hidden=true href=#readniess-probe>#</a></h2><blockquote><p>Pod이 서비스 트래픽을 처리할 준비가 되었는지를 판단하는 데 사용되는 메커니즘</p><p>특정 컨테이너가 시작된 후에도 일부 작업이 완료될 때까지 외부 트래픽을 처리할 준비가 되지 않았을 수 있기 때문에 이를 확인하는 역할을 함</p></blockquote><ol><li>트래픽 라우팅 제어:<ul><li>Readiness Probe가 성공적으로 완료될 때까지 Kubernetes는 해당 Pod으로 트래픽을 라우팅하지 않습니다. 이는 Pod이 준비되지 않은 상태에서 요청을 처리하지 않도록 보장합니다.</li><li>준비가 완료된 후에만 트래픽이 Pod으로 라우팅되기 때문에, Pod이 올바르게 설정되고 필요한 리소스를 확보한 상태에서만 요청을 처리하게 됩니다.</li></ul></li></ol><blockquote></blockquote><ol start=2><li>Pod의 상태 확인:<ul><li>Readiness Probe는 특정 조건이 충족될 때까지 Kubernetes에 Pod이 트래픽을 받을 준비가 되지 않았다고 알리며, 준비가 완료된 후에는 트래픽을 받을 준비가 되었음을 알립니다.</li><li>Pod이 준비되지 않은 경우, Kubernetes는 Pod을 서비스의 엔드포인트에서 제거합니다.</li></ul></li></ol><p>502가 발생하는 원인 중 하나이다</p><p>Readiness Probe를 지정하지 않은 경우, 컨테이너가 올라가는 시점에서 트래픽이 들어오게 된다.</p><p>이때에, Pod 내부의 서버 초기화가 완전히 되지 않은 시점에서 요청이 온 경우 → 502 Bad Gateway를 응답한다</p><p><img loading=lazy src=/posts/k8s-zero-downtime/1.png></p><h4 id=deploymentyml-수정-사항>deployment.yml 수정 사항<a hidden class=anchor aria-hidden=true href=#deploymentyml-수정-사항>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nn>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>readinessProbe</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>httpGet</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=l>/alive</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>scheme</span><span class=p>:</span><span class=w> </span><span class=l>HTTP  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>initialDelaySeconds</span><span class=p>:</span><span class=w> </span><span class=m>30</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>periodSeconds</span><span class=p>:</span><span class=w> </span><span class=m>30</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nn>...</span><span class=w>
</span></span></span></code></pre></div><p>Healthcheck 응답용 Endpoint를 생성해두고 응답 상태코드가 200으로 돌아오면 요청을 받는 형식으로 설정</p><h4 id=테스트>테스트<a hidden class=anchor aria-hidden=true href=#테스트>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>bombardier -c <span class=m>200</span> -d 3m -l https://<span class=o>{</span>endpoint<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>[================================================================================================================]</span> 3m0s
</span></span><span class=line><span class=cl>Done!
</span></span><span class=line><span class=cl>Statistics        Avg      Stdev        Max
</span></span><span class=line><span class=cl>  Reqs/sec      4205.76    1250.10   16927.12
</span></span><span class=line><span class=cl>  Latency       47.81ms    10.16ms      2.07s
</span></span><span class=line><span class=cl>  Latency Distribution
</span></span><span class=line><span class=cl>     50%    45.08ms
</span></span><span class=line><span class=cl>     75%    49.77ms
</span></span><span class=line><span class=cl>     90%    57.60ms
</span></span><span class=line><span class=cl>     95%    64.29ms
</span></span><span class=line><span class=cl>     99%    81.95ms
</span></span><span class=line><span class=cl>  HTTP codes:
</span></span><span class=line><span class=cl>    1xx - 0, 2xx - 0, 3xx - 0, 4xx - 753060, 5xx - <span class=m>12</span>
</span></span><span class=line><span class=cl>    others - <span class=m>0</span>
</span></span><span class=line><span class=cl>  Throughput:     3.24MB/s
</span></span></code></pre></div><p>여전히 <strong>5XX</strong> 에러는 존재한다.</p><hr><h2 id=lifecycle--prestop>lifecycle & preStop<a hidden class=anchor aria-hidden=true href=#lifecycle--prestop>#</a></h2><blockquote><p>lifecycle 설정이란?
컨테이너의 생명주기 동안 특정 시점에 실행될 작업을 정의할 수 있는 Kubernetes의 구성 옵션 (AOP와 유사&mldr;하다는 생각)</p></blockquote><ul><li>postStart: 컨테이너가 시작된 직후에 실행됩니다. 컨테이너가 시작된 후 추가적인 초기화 작업을 수행하는 데 사용</li><li>preStop: 컨테이너가 종료되기 직전에 실행됩니다. 종료 전에 필요한 작업을 수행하도록 설정 가능</li></ul><blockquote></blockquote><p><strong>preStop</strong>
preStop 훅은 컨테이너가 종료될 때 실행되는 스크립트나 명령어를 지정. 이 훅은 컨테이너가 종료되기 전에 반드시 수행해야 하는 작업이 있을 때 매우 유용</p><ul><li>트래픽 분리: Pod이 종료되기 전에 해당 Pod을 서비스 트래픽에서 안전하게 분리하기 위해 사용됩니다.</li><li>정리 작업: 종료 전에 리소스 정리, 연결 종료, 파일 저장 등의 작업을 수행할 수 있습니다.</li><li>대기 시간 설정: 컨테이너가 실제로 종료되기 전에 일정 시간 동안 대기하도록 설정하여, 클라이언트와의 연결이 완전히 종료되도록 할 수 있습니다.</li></ul><p>앞서 설정한 Readiness Probe 설정 이후에도, lifecycle 설정을 하지 않는다면 간헐적인 502 에러가 발생될 수 있다</p><p>파드는 종료될 때 SIGTERM, SIGKILL 처리와 서비스 제외 처리가 비동기로 처리됨</p><p>서비스가 분리되기 전에 Pod이 클라이언트 요청에 정상적으로 응답할 수 없을 수 있다.</p><p>즉, 서비스 분리 → 잔류하는 요청 처리 → pod 종료 를 통해 Graceful Shutdown이 가능하도록 설정한다</p><p><img loading=lazy src=/posts/k8s-zero-downtime/2.png></p><h4 id=deploymentyml-수정-사항-1>deployment.yml 수정 사항<a hidden class=anchor aria-hidden=true href=#deploymentyml-수정-사항-1>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>lifecycle:
</span></span><span class=line><span class=cl>    preStop:
</span></span><span class=line><span class=cl>        exec:
</span></span><span class=line><span class=cl>        command:
</span></span><span class=line><span class=cl>        - /bin/sh
</span></span><span class=line><span class=cl>        - -c
</span></span><span class=line><span class=cl>        - sleep <span class=m>40</span>  <span class=c1># 서비스 분리가 발생한 후 40초 동안 대기</span>
</span></span><span class=line><span class=cl>...
</span></span></code></pre></div><ol><li>컨테이너 종료 요청: Kubernetes가 Pod을 종료하기로 결정하면, 컨테이너에 SIGTERM 신호</li><li>preStop 훅 실행: SIGTERM 신호가 전송된 후, sleep 40 실행, 컨테이너가 40초 동안 대기</li><li>유예 기간 시작 (terminationGracePeriodSeconds): preStop 훅이 실행되면서, 동시에 terminationGracePeriodSeconds에 정의된 유예 기간이 시작
이 기간 동안 Kubernetes는 컨테이너가 정상적으로 종료되기를 대기</li><li>컨테이너 종료: preStop 훅이 완료되고, 유예 기간이 끝나면 Kubernetes는 컨테이너를 종료</li></ol><h4 id=테스트-1>테스트<a hidden class=anchor aria-hidden=true href=#테스트-1>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>bombardier -c <span class=m>200</span> -d 3m -l https://<span class=o>{</span>endpoint<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>[================================================================================================================]</span> 3m0s
</span></span><span class=line><span class=cl>Done!
</span></span><span class=line><span class=cl>Statistics        Avg      Stdev        Max
</span></span><span class=line><span class=cl>  Reqs/sec      4205.05    1355.65   20756.97
</span></span><span class=line><span class=cl>  Latency       47.92ms     8.71ms      2.07s
</span></span><span class=line><span class=cl>  Latency Distribution
</span></span><span class=line><span class=cl>     50%    45.47ms
</span></span><span class=line><span class=cl>     75%    49.26ms
</span></span><span class=line><span class=cl>     90%    57.32ms
</span></span><span class=line><span class=cl>     95%    64.39ms
</span></span><span class=line><span class=cl>     99%    80.67ms
</span></span><span class=line><span class=cl>  HTTP codes:
</span></span><span class=line><span class=cl>    1xx - 0, 2xx - 751239, 3xx - 0, 4xx - 0, 5xx - <span class=m>3</span>
</span></span><span class=line><span class=cl>    others - <span class=m>0</span>
</span></span><span class=line><span class=cl>  Throughput:     2.82MB/s
</span></span></code></pre></div><p>여전히 <strong>5XX</strong> 에러는 존재한다.</p><hr><h2 id=terminationgraceperiodseconds>terminationGracePeriodSeconds<a hidden class=anchor aria-hidden=true href=#terminationgraceperiodseconds>#</a></h2><blockquote><p><strong>Pod 종료 시나리오:</strong></p></blockquote><ul><li>Kubernetes가 Pod을 종료하기로 결정하면, 먼저 Pod 내의 컨테이너에 SIGTERM 신호를 보냄</li><li>SIGTERM 신호를 받은 애플리케이션은 현재 처리 중인 요청을 완료하고, 필요한 정리 작업을 수행 가능</li></ul><blockquote><p><strong>유예 기간 설정:</strong></p></blockquote><ul><li>terminationGracePeriodSeconds는 이 유예 기간을 정의. 이 기간 동안 Kubernetes는 컨테이너가 정상적으로 종료될 시간을 대기</li><li>기본값은 30초입니다. 이 시간이 지나면 Kubernetes는 컨테이너가 여전히 실행 중인 경우 강제로 종료(SIGKILL)</li></ul><blockquote><p><strong>SIGKILL 신호:</strong></p></blockquote><ul><li>terminationGracePeriodSeconds 기간이 만료되었을 때도 컨테이너가 종료되지 않았다면, Kubernetes는 SIGKILL 신호를 줌, 애플리케이션이 강제 종료됨</li></ul><p>일정 lifecycle.preStop 설정을 통해, 40초의 유예시간을 두어 애플리케이션에 잔류하는 요청을 응답할 시간을 주었음.</p><p>하지만 terminationGracePeriodSeconds 는 기본 <strong>30초로 설정되기에 30초가 지나도록 Pod이 실행중인 경우 SIGKILL을 전송</strong>하여 파드를 강제 종료시킴</p><p><img loading=lazy src=/posts/k8s-zero-downtime/3.png></p><h4 id=deploymentyml-수정-사항-2>deployment.yml 수정 사항<a hidden class=anchor aria-hidden=true href=#deploymentyml-수정-사항-2>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nn>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>terminationGracePeriodSeconds</span><span class=p>:</span><span class=w> </span><span class=m>50</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nn>...</span><span class=w>
</span></span></span></code></pre></div><p>INGRESS와 연결된 ALB 속성을 꼭 확인하자!
<code>terminationGracePeriodSeconds</code>가 ALB 타임아웃보다 긴 경우, 특정 시나리오에서 <strong>504 Gateway Timeout 오류가 발생</strong>할 수 있음</p><p><strong>예상 발생 시나리오</strong> : 요청 중간에 종료 발생 → ALB 타임아웃 도달 → 응답 전 Pod 종료</p><p>이를 예방하기 위해, lifecycle.preStop (40s) &lt; terminationGracePeriodSeconds (50s) &lt; ALB Timeout (60s) 로 지정</p><h4 id=테스트-2>테스트<a hidden class=anchor aria-hidden=true href=#테스트-2>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>bombardier -c <span class=m>200</span> -d 3m -l https://<span class=o>{</span>endpoint<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>[================================================================================================================]</span> 3m0s
</span></span><span class=line><span class=cl>Done!
</span></span><span class=line><span class=cl>Statistics        Avg      Stdev        Max
</span></span><span class=line><span class=cl>  Reqs/sec      4293.51    1286.80   12924.64
</span></span><span class=line><span class=cl>  Latency       46.74ms     8.94ms   547.25ms
</span></span><span class=line><span class=cl>  Latency Distribution
</span></span><span class=line><span class=cl>     50%    44.48ms
</span></span><span class=line><span class=cl>     75%    46.87ms
</span></span><span class=line><span class=cl>     90%    54.16ms
</span></span><span class=line><span class=cl>     95%    66.82ms
</span></span><span class=line><span class=cl>     99%    81.69ms
</span></span><span class=line><span class=cl>  HTTP codes:
</span></span><span class=line><span class=cl>    1xx - 0, 2xx - 770240, 3xx - 0, 4xx - 0, 5xx - <span class=m>0</span>
</span></span><span class=line><span class=cl>    others - <span class=m>0</span>
</span></span><span class=line><span class=cl>  Throughput:     2.89MB/s
</span></span></code></pre></div><hr><h3 id=ref>REF<a hidden class=anchor aria-hidden=true href=#ref>#</a></h3><ul><li><a href=https://tech.kakao.com/posts/360>카카오 테크 k8s 무중단 배포</a></li><li><a href=https://kubernetes.io/ko/docs/concepts/workloads/pods/pod-lifecycle/>Pod 라이프사이클</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://dingyu.dev/tags/k8s/>K8s</a></li><li><a href=https://dingyu.dev/tags/zero-downtime/>Zero-Downtime</a></li></ul><nav class=paginav><a class=prev href=https://dingyu.dev/posts/sentry/><span class=title>« Prev</span><br><span>[Third-Party] Sentry 연동</span>
</a><a class=next href=https://dingyu.dev/posts/aws-well-architected/><span class=title>Next »</span><br><span>[Infra] AWS Well Architected</span></a></nav></footer><div id=giscus_thread><script src=https://giscus.app/client.js data-repo=dings-things/blog data-repo-id=R_kgDON9IuAw data-category=Announcements data-category-id=DIC_kwDON9IuA84CnTai data-mapping=og:title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=ko data-loading=lazy crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://dingyu.dev/>Ding's Coding Forge</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>
<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[EDA] Schema Registry | Ding's Coding Forge</title>
<meta name=keywords content="kafka,avro,protobuf,json,schema registry"><meta name=description content="People often underestimate the importance of documenting schemas before starting to code, especially when working with stream processing. In this post, I’ll explain why using a schema registry is essential and why designing schemas upfront is crucial before diving into coding."><meta name=author content="dingyu"><link rel=canonical href=https://dingyu.dev/posts/schema-registry/><meta name=google-site-verification content="8XY1hI6NVxQIrN7bQbnX-9TG9HHFw5HOQmlb6vcsFdQ"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.ba0de23ad40e17ca82720b577f8ae6ec11a26fb07407316cff70888e344ad129.css integrity="sha256-ug3iOtQOF8qCcgtXf4rm7BGib7B0BzFs/3CIjjRK0Sk=" rel="preload stylesheet" as=style><link rel=icon href=https://dingyu.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dingyu.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dingyu.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://dingyu.dev/apple-touch-icon.png><link rel=mask-icon href=https://dingyu.dev/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://dingyu.dev/posts/schema-registry/><link rel=alternate hreflang=en href=https://dingyu.dev/en/posts/schema-registry/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-XH8830R9KK"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XH8830R9KK")}</script><meta property="og:url" content="https://dingyu.dev/posts/schema-registry/"><meta property="og:site_name" content="Ding's Coding Forge"><meta property="og:title" content="[EDA] Schema Registry"><meta property="og:description" content="People often underestimate the importance of documenting schemas before starting to code, especially when working with stream processing. In this post, I’ll explain why using a schema registry is essential and why designing schemas upfront is crucial before diving into coding."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-24T00:00:00+00:00"><meta property="article:modified_time" content="2025-02-24T00:00:00+00:00"><meta property="article:tag" content="Kafka"><meta property="article:tag" content="Avro"><meta property="article:tag" content="Protobuf"><meta property="article:tag" content="Json"><meta property="article:tag" content="Schema Registry"><meta property="og:image" content="https://dingyu.dev/posts/schema-registry/img/kafka.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dingyu.dev/posts/schema-registry/img/kafka.png"><meta name=twitter:title content="[EDA] Schema Registry"><meta name=twitter:description content="People often underestimate the importance of documenting schemas before starting to code, especially when working with stream processing. In this post, I’ll explain why using a schema registry is essential and why designing schemas upfront is crucial before diving into coding."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://dingyu.dev/posts/"},{"@type":"ListItem","position":2,"name":"[EDA] Schema Registry","item":"https://dingyu.dev/posts/schema-registry/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[EDA] Schema Registry","name":"[EDA] Schema Registry","description":"People often underestimate the importance of documenting schemas before starting to code, especially when working with stream processing. In this post, I’ll explain why using a schema registry is essential and why designing schemas upfront is crucial before diving into coding.","keywords":["kafka","avro","protobuf","json","schema registry"],"articleBody":"들어가기에 앞서… 느슨한 결합을 유지하면서 높은 확장성을 보장하는 EDA에서 역설적이지만 Producer Consumer 간의 강한 결합을 갖게하는 이벤트 스키마 왜 사용하고 어떤 이유로 Schema Registry를 사용할까? 이벤트 스키마의 목적 데이터의 구조를 정의하고, 메시지 형식을 표준화하며, Producer와 Consumer 간의 데이터 일관성을 유지 Producer와 Consumer 간의 호환성 유지 데이터에 대한 검증 백엔드라면 익숙한 REST API를 예시로 들어보자! 각 서비스가 서로 통신하기 위해서는 사전에 정의된 인터페이스로 Client와 Server 간의 일종의 “약속\"을 맺게 된다\n서로 일관된 형태로 통신하기 위하여 OpenAPI 혹은 문서를 통해서 사용자는 어떤 값을 입력해야 하는지, 그리고 어떤 값을 반환 받게 되는지에 대한 협의를 하게 되는데…\nAPI가 아닌 이벤트 스트림에서도 동일하다\nProducer가 사전 정의된 이벤트에 대하여 발행하면, Consumer는 사전 정의된 이벤트를 읽어와 비즈니스 로직을 수행한다.\n[예시-1] Producer와 Consumer가 사전에 협의를 통해 스키마를 정의하였다고 가정해보자.\n{ \"user_id\" : number, \"user_action\" : \"string\" } Producer와 Consumer는 사전에 이벤트 스키마를 통해 협의를 했음에도 불구하고 Producer는 action string이 아닌 action code로 이벤트를 발행하였다.\n(효과는 대단했다! Consumer의 분노 게이지가 Max다 🤢)\nERD를 만들지도 않고 DB에 삽입하는 일이 없듯이… 이벤트 드리븐 아키텍처에서 개발함에 있어 스키마 설계는 선택사항이 아닌 강제사항이라 생각된다.\nEvent Schema 이벤트 스키마가 어째서 필요한지는 어느정도 설명이 되었다 생각된다.\n스키마는 당연히 설정해야 겠지만 포맷에 결정 고민이 된다면 아래 표를 참고해보자!\n형식 장점 단점 JSON (JavaScript Object Notation) 사람이 읽기 쉬운 텍스트 기반 포맷 / 대부분의 프로그래밍 언어에서 널리 지원됨 텍스트 포맷으로 인해 크기가 큼 / 스키마 강제가 없어서 데이터 무결성 문제 발생 가능 Protobuf (Protocol Buffers) Google에서 개발한 빠르고 효율적인 바이너리 포맷 / 스키마 기반으로 데이터 구조를 강제할 수 있음 / JSON보다 빠른 파싱 속도 및 작은 메시지 크기 사람이 읽을 수 없는 바이너리 포맷 / 사전 스키마 정의가 필요함 / JSON에 비해 생태계가 상대적으로 작음 Avro 스키마 기반으로 데이터 구조를 관리할 수 있음 / 작은 메시지 크기 (Compact Binary Format) / 배포된 프로그램을 깨뜨리지 않고 스키마 진화(Schema Evolution) 지원 JSON이나 Protobuf보다 덜 널리 사용됨 / 일부 환경에서는 도구 및 라이브러리 지원이 부족할 수 있음 스트림 또한 네트워크 통신을 거치기 때문에, 결국 중요한 것은 데이터의 사이즈일 것이다.\nAPI 명세를 자주 작성하는 엔지니어라면 단순하게 쉽고 편한 JSON을 사용할 것이다. 다만… 이 경우 명확하게 JSON을 사용해야 할 필요성이 있는가? 를 고려해보시길 바란다.\n얼죽JSON을 위한 체크리스트 아래 여건을 모두 만족한다면 JSON을 선택하였더라도 매우 합리적인 선택일 것이다!\n데이터의 크기가 작은가? 역/직렬화에 드는 비용을 감수할 것인가? 강타입 유효성 검증이 필요하지 않은가? Schema Registry 사용할 생각이 없는가? 데이터가 점진적으로 더 많이 유입될 여지가 없는가? 디버깅 용이성을 위해서 눈으로 확인이 가능한 모델이 필요한가? Avro / Protobuf의 장점 강타입 유효성 검증을 통해 보다 일관된 데이터를 받을 수 있다 ex. ENUM, float 등과 같이 지정된 타입이 아닐 경우 직렬화 자체가 실패함 역/직렬화에 드는 비용을 최소화 할 수 있다 본래 역/직렬화 성능은 압축률에 반비례한다 (JSON은 압축되지 않음). 단 추가적인 파싱 문제로 JSON은 매우 비효율적임 JSON은 텍스트 기반이므로 추가적인 Parsing이 필요함 Avro/protobuf는 바이너리 기반으로 Parsing이 필요없음 상위/하위 호환성을 지원한다 필드가 추가될 때, 해당 필드에 대한 모델이 반영되어 있지 않더라도 무시하고 정상 동작함 실제 벤치마크 결과에서 JSON 비록 작은 데이터사이즈임에도 불구하고 직렬화와 역직렬화 성능이 2배 이상의 차이를 보였다.\n놀라운 점은 데이터 크기가 커질수록 이 격차는 보다 확연해진다는 점이다.\n데이터 사이즈와 성능의 상관 관계 JSON은 BINARY가 아닌 TEXT의 형태로 저장되기에 Avro나 Protobuf에 비하여 보다 큰 공간을 차지한다.\nKafka Volume의 증가 : JSON 이벤트 사용을 위해 물리적으로 보다 큰 용량을 사용해야 함 Broker에서 이벤트 생산/소비의 성능 저하 : 본질적으로 네트워크 통신에 있어 이동되는 데이터의 크기가 커질수록 성능이 저하될 수 밖에 없음 Produce 단계에서 In Sync Replication에 보다 큰 비용이 발생 Consume 단계에서 이벤트를 가져오는 데에 보다 큰 비용이 발생 Schema Registry 이벤트 스키마를 정리하자면 주요하게 아래 3개를 보장한다\n일관성 성능 향상 호환성 Schema Registry는… Kafka 메시지의 데이터 구조(스키마)를 중앙에서 관리하고 검증하여 생산자와 소비자가 데이터 호환성을 유지하도록 돕는 서비스이다\n스키마 진화와 호환성 [예시-2] API에서 v1 API를 v2 API로 전환한다 생각해보자. 기존 하위 호환성을 지키되 v1 API 사용자에게 v2로 전환을 부탁하고 … 몇개월이 지나 v1 API의 유입이 없음을 확인한 뒤에야 v2로 완전 전환이 가능할 것이다.\n이벤트 스트림에서는 어떨까?\nv2 스키마로 업데이트 이후에, 해당 이벤트를 구독중인 Consumer들에게 어떠한 필드가 추가되었는지 알리고.. Consumer는 필요에 따라 추가 구현을 진행하게 될 것이다.\n그럼 Producer가 먼저 업데이트되어야 하는가? Consumer가 먼저 업데이트 되어야 하는가? 닭이 먼저냐 계란이 먼저냐??\n다행히도 스키마 레지스트리를 사용하면 이러한 문제는 해결된다!\n스키마 레지스트리에 스키마를 등록하면, URL은 유지한 채로 Consumer는 최신 스키마 버전을 가져오게 된다. Producer 에서 새로운 스키마 버전으로 이벤트가 발행됨 (v2) Consumer 는 기존 캐싱된 스키마 버전과 다름을 인지하고 새로운 스키마 버전을 조회 새로운 스키마 버전으로 비즈니스 로직 수행 이처럼 하위호환성을 유지하면서 스키마 변경이 자유로워진다\n효율적인 이벤트 관리 무조건 Schema Registry가 좋으냐..? Event Schema는 필수인가..?\n기술선택에 Must는 없다. 상황에 따라 최선의 선택을 하는것은 엔지니어의 역량에 달려있다 생각한다.\nKafka Stream에서의 Schema Event 이해 Schemaless인 JSON과는 달리, Avro와 Protobuf의 경우 Schema를 포함하여 Event와 함께 Produce 된다\nAvro와 Protobuf의 경우 바이너리 포맷이며 스키마 없이 해석할 수 없기 때문에, 데이터를 어떻게 해석해야 하는지 스키마 정보가 요구됨 이벤트 데이터 사이즈 비교 스키마 이벤트의 장점으로 설명하였던 압축된 작은 바이너리 데이터는 스키마 정보를 포함하는 순간 퇴색된다. 이처럼 스키마 정보를 포함하는 순간 압축률이 높다 하더라도 보다 큰 데이터일 수 밖에 없다.\n이러한 단점을 극복하는데 있어 스키마 ID는 이벤트 사이즈를 최소화할 수 있으며 호환성 보장이 가능하다.\n사실 Producer와 Consumer에서 동일한 스키마 파일이 있다면 굳이 스키마 정보를 포함하여 이벤트로 발행하지 않아도 가능하다. 단, Submodule의 단점은 다음과 같다\nProducer와 Consumer가 같은 .proto를 사용해야 하는 전제 조건이 강함 스키마 변경이 동적으로 반영되지 않음 스키마 변경이 있을 경우, Producer와 Consumer를 모두 재배포해야 함 AWS Glue 와 Schema Registry 차이 MSK를 사용하는 경우, 별도 AWS Glue를 사용하여야 스키마 레지스트리를 사용할 수 있다. 이에 대한 차이는 다음과 같다.\n기능 AWS Glue Schema Registry Confluent Schema Registry 스키마 업데이트 방식 새로운 버전으로 추가됨 새로운 버전으로 추가됨 스키마 URL 유지 여부 ✅ 유지됨 (ARN 기반) ✅ 유지됨 (REST API 기반) 자동 최신 버전 사용 ❌ 기본적으로 자동 X (Consumer 설정 필요) ✅ 기본적으로 자동 사용 Kafka 호환성 ✅ AWS MSK와 연동 가능 ✅ Confluent Kafka와 기본 연동 왜 Schema Registry를 사용하냐고 물으신다면? Producer와 Consumer 간 데이터 일관성 유지\nProducer가 보내는 데이터와 Consumer가 기대하는 데이터 형식을 검증 데이터 불일치로 인한 비즈니스 로직 오류 방지 Schema Evolution(스키마 진화) 지원 → 하위/상위 호환성 보장\n새로운 필드 추가 시 기존 Consumer가 깨지지 않도록 유지 가능 기존 필드 삭제나 변경 시에도 안전한 데이터 처리가 가능 스키마 관리의 중앙화 → 변경 및 배포 프로세스 단순화\n스키마를 중앙에서 관리하여 모든 서비스가 동일한 기준을 따름 개별 서비스에서 .proto 파일을 관리하지 않아도 자동으로 최신 버전 적용 가능 Kafka 메시지 크기 최소화 (스키마 ID 활용)\n스키마 정보를 메시지에 직접 포함하지 않고, Schema Registry에서 스키마 ID만 전송 네트워크 비용 절감 + Kafka 저장 공간 절약 Schema Validation(데이터 유효성 검증) 기능 제공\nProducer가 잘못된 데이터(예: 필드 누락, 타입 불일치)를 보내면 Schema Registry에서 즉시 차단 Consumer가 유효한 데이터만 수신하여 안정적인 서비스 운영 가능 실시간 스키마 변경 감지 및 자동 업데이트 가능\nConsumer가 Schema Registry에서 최신 스키마를 조회하여 동적으로 변경된 필드를 활용 가능 서비스 재배포 없이 데이터 구조 변경 가능 Schema Compatibility Mode 설정 가능\n하위 호환성(Backward Compatibility), 상위 호환성(Forward Compatibility) 등의 정책을 설정하여 스키마 변경으로 인한 장애 방지 스키마 조회 및 버전 관리 용이\nREST API 혹은 UI를 통해 기존 스키마 및 변경 이력을 조회할 수 있어 유지보수 편리 특정 시점의 스키마 버전으로 롤백 가능 REFS Confluent Oliveyoung Exploring Data Serialization in Apache Kafka ","wordCount":"1149","inLanguage":"ko","image":"https://dingyu.dev/posts/schema-registry/img/kafka.png","datePublished":"2025-02-24T00:00:00Z","dateModified":"2025-02-24T00:00:00Z","author":{"@type":"Person","name":"dingyu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://dingyu.dev/posts/schema-registry/"},"publisher":{"@type":"Organization","name":"Ding's Coding Forge","logo":{"@type":"ImageObject","url":"https://dingyu.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dingyu.dev/ accesskey=h title="Ding's Coding Forge (Alt + H)"><img src=https://dingyu.dev/apple-touch-icon.png alt aria-label=logo height=35>Ding's Coding Forge</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://dingyu.dev/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://dingyu.dev/about/ title=About><span>About</span></a></li><li><a href=https://dingyu.dev/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://dingyu.dev/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://dingyu.dev/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://dingyu.dev/search/ title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://dingyu.dev/>홈</a>&nbsp;»&nbsp;<a href=https://dingyu.dev/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">[EDA] Schema Registry</h1><div class=post-description>People often underestimate the importance of documenting schemas before starting to code, especially when working with stream processing. In this post, I’ll explain why using a schema registry is essential and why designing schemas upfront is crucial before diving into coding.</div><div class=post-meta><span title='2025-02-24 00:00:00 +0000 UTC'>2월 24, 2025</span>&nbsp;·&nbsp;6 분&nbsp;·&nbsp;1149 단어&nbsp;·&nbsp;dingyu&nbsp;|&nbsp;번역:<ul class=i18n_list><li><a href=https://dingyu.dev/en/posts/schema-registry/>En</a></li></ul>&nbsp;|&nbsp;<a href=https://github.com/dings-things/blog/tree/main/content/posts/schema-registry/index.ko.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://dingyu.dev/img/kafka.png alt></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><ul><li><a href=#%eb%93%a4%ec%96%b4%ea%b0%80%ea%b8%b0%ec%97%90-%ec%95%9e%ec%84%9c aria-label="들어가기에 앞서&mldr;">들어가기에 앞서&mldr;</a><ul><li><a href=#%ec%9d%b4%eb%b2%a4%ed%8a%b8-%ec%8a%a4%ed%82%a4%eb%a7%88%ec%9d%98-%eb%aa%a9%ec%a0%81 aria-label="이벤트 스키마의 목적">이벤트 스키마의 목적</a></li><li><a href=#event-schema aria-label="Event Schema">Event Schema</a><ul><li><a href=#%ec%96%bc%ec%a3%bdjson%ec%9d%84-%ec%9c%84%ed%95%9c-%ec%b2%b4%ed%81%ac%eb%a6%ac%ec%8a%a4%ed%8a%b8 aria-label="얼죽JSON을 위한 체크리스트">얼죽JSON을 위한 체크리스트</a></li><li><a href=#avro--protobuf%ec%9d%98-%ec%9e%a5%ec%a0%90 aria-label="Avro / Protobuf의 장점">Avro / Protobuf의 장점</a></li><li><a href=#%eb%8d%b0%ec%9d%b4%ed%84%b0-%ec%82%ac%ec%9d%b4%ec%a6%88%ec%99%80-%ec%84%b1%eb%8a%a5%ec%9d%98-%ec%83%81%ea%b4%80-%ea%b4%80%ea%b3%84 aria-label="데이터 사이즈와 성능의 상관 관계">데이터 사이즈와 성능의 상관 관계</a></li></ul></li><li><a href=#schema-registry aria-label="Schema Registry">Schema Registry</a><ul><li><a href=#%ec%8a%a4%ed%82%a4%eb%a7%88-%ec%a7%84%ed%99%94%ec%99%80-%ed%98%b8%ed%99%98%ec%84%b1 aria-label="스키마 진화와 호환성">스키마 진화와 호환성</a></li><li><a href=#%ed%9a%a8%ec%9c%a8%ec%a0%81%ec%9d%b8-%ec%9d%b4%eb%b2%a4%ed%8a%b8-%ea%b4%80%eb%a6%ac aria-label="효율적인 이벤트 관리">효율적인 이벤트 관리</a><ul><li><a href=#kafka-stream%ec%97%90%ec%84%9c%ec%9d%98-schema-event-%ec%9d%b4%ed%95%b4 aria-label="Kafka Stream에서의 Schema Event 이해">Kafka Stream에서의 Schema Event 이해</a></li><li><a href=#%ec%9d%b4%eb%b2%a4%ed%8a%b8-%eb%8d%b0%ec%9d%b4%ed%84%b0-%ec%82%ac%ec%9d%b4%ec%a6%88-%eb%b9%84%ea%b5%90 aria-label="이벤트 데이터 사이즈 비교">이벤트 데이터 사이즈 비교</a></li></ul></li><li><a href=#aws-glue-%ec%99%80-schema-registry-%ec%b0%a8%ec%9d%b4 aria-label="AWS Glue 와 Schema Registry 차이">AWS Glue 와 Schema Registry 차이</a></li></ul></li><li><a href=#%ec%99%9c-schema-registry%eb%a5%bc-%ec%82%ac%ec%9a%a9%ed%95%98%eb%83%90%ea%b3%a0-%eb%ac%bc%ec%9c%bc%ec%8b%a0%eb%8b%a4%eb%a9%b4 aria-label="왜 Schema Registry를 사용하냐고 물으신다면?">왜 Schema Registry를 사용하냐고 물으신다면?</a></li><li><a href=#refs aria-label=REFS>REFS</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=들어가기에-앞서>들어가기에 앞서&mldr;<a hidden class=anchor aria-hidden=true href=#들어가기에-앞서>#</a></h1><ul><li>느슨한 결합을 유지하면서 높은 확장성을 보장하는 EDA에서 역설적이지만 <code>Producer</code> <code>Consumer</code> 간의 강한 결합을 갖게하는 <strong>이벤트 스키마</strong></li><li>왜 사용하고 어떤 이유로 <code>Schema Registry</code>를 사용할까?</li></ul><h2 id=이벤트-스키마의-목적>이벤트 스키마의 목적<a hidden class=anchor aria-hidden=true href=#이벤트-스키마의-목적>#</a></h2><ul><li>데이터의 구조를 정의하고, 메시지 형식을 표준화하며, <code>Producer</code>와 <code>Consumer</code> 간의 <strong>데이터 일관성을 유지</strong></li><li><code>Producer</code>와 <code>Consumer</code> 간의 <strong>호환성 유지</strong></li><li>데이터에 대한 검증</li></ul><p>백엔드라면 익숙한 REST API를 예시로 들어보자!
<img loading=lazy src=/posts/schema-registry/image.png></p><p>각 서비스가 서로 통신하기 위해서는 사전에 정의된 인터페이스로 Client와 Server 간의 일종의 &ldquo;약속"을 맺게 된다</p><p>서로 일관된 형태로 통신하기 위하여 OpenAPI 혹은 문서를 통해서 사용자는 어떤 값을 입력해야 하는지, 그리고 어떤 값을 반환 받게 되는지에 대한 협의를 하게 되는데&mldr;</p><p>API가 아닌 이벤트 스트림에서도 동일하다</p><p><code>Producer</code>가 사전 정의된 이벤트에 대하여 발행하면, <code>Consumer</code>는 사전 정의된 이벤트를 읽어와 비즈니스 로직을 수행한다.</p><p>[예시-1] <code>Producer</code>와 <code>Consumer</code>가 사전에 협의를 통해 스키마를 정의하였다고 가정해보자.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;user_id&#34;</span> <span class=p>:</span> <span class=err>number</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;user_action&#34;</span> <span class=p>:</span> <span class=s2>&#34;string&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>Producer</code>와 <code>Consumer</code>는 사전에 이벤트 스키마를 통해 협의를 했음에도 불구하고 <code>Producer</code>는 action string이 아닌 action code로 이벤트를 발행하였다.</p><p><img loading=lazy src=/posts/schema-registry/kafka-event-mismatch.png>
(효과는 대단했다! Consumer의 분노 게이지가 Max다 🤢)</p><p><code>ERD</code>를 만들지도 않고 DB에 삽입하는 일이 없듯이&mldr; 이벤트 드리븐 아키텍처에서 개발함에 있어 스키마 설계는 선택사항이 아닌 강제사항이라 생각된다.</p><h2 id=event-schema>Event Schema<a hidden class=anchor aria-hidden=true href=#event-schema>#</a></h2><p>이벤트 스키마가 어째서 필요한지는 어느정도 설명이 되었다 생각된다.</p><p>스키마는 당연히 설정해야 겠지만 포맷에 결정 고민이 된다면 아래 표를 참고해보자!</p><table><thead><tr><th>형식</th><th>장점</th><th>단점</th></tr></thead><tbody><tr><td><strong>JSON</strong> (JavaScript Object Notation)</td><td>사람이 읽기 쉬운 텍스트 기반 포맷 / 대부분의 프로그래밍 언어에서 널리 지원됨</td><td>텍스트 포맷으로 인해 크기가 큼 / 스키마 강제가 없어서 데이터 무결성 문제 발생 가능</td></tr><tr><td><strong>Protobuf</strong> (Protocol Buffers)</td><td>Google에서 개발한 빠르고 효율적인 바이너리 포맷 / 스키마 기반으로 데이터 구조를 강제할 수 있음 / JSON보다 빠른 파싱 속도 및 작은 메시지 크기</td><td>사람이 읽을 수 없는 바이너리 포맷 / 사전 스키마 정의가 필요함 / JSON에 비해 생태계가 상대적으로 작음</td></tr><tr><td><strong>Avro</strong></td><td>스키마 기반으로 데이터 구조를 관리할 수 있음 / 작은 메시지 크기 (Compact Binary Format) / 배포된 프로그램을 깨뜨리지 않고 스키마 진화(Schema Evolution) 지원</td><td>JSON이나 Protobuf보다 덜 널리 사용됨 / 일부 환경에서는 도구 및 라이브러리 지원이 부족할 수 있음</td></tr></tbody></table><p>스트림 또한 네트워크 통신을 거치기 때문에, 결국 중요한 것은 데이터의 사이즈일 것이다.</p><p>API 명세를 자주 작성하는 엔지니어라면 단순하게 쉽고 편한 <code>JSON</code>을 사용할 것이다. 다만&mldr; 이 경우 명확하게 <code>JSON</code>을 사용해야 할 필요성이 있는가? 를 고려해보시길 바란다.</p><h3 id=얼죽json을-위한-체크리스트>얼죽JSON을 위한 체크리스트<a hidden class=anchor aria-hidden=true href=#얼죽json을-위한-체크리스트>#</a></h3><p>아래 여건을 모두 만족한다면 JSON을 선택하였더라도 매우 합리적인 선택일 것이다!</p><ul><li><input checked disabled type=checkbox> 데이터의 크기가 작은가?</li><li><input checked disabled type=checkbox> 역/직렬화에 드는 비용을 감수할 것인가?</li><li><input checked disabled type=checkbox> 강타입 유효성 검증이 필요하지 않은가?</li><li><input checked disabled type=checkbox> Schema Registry 사용할 생각이 없는가?</li><li><input checked disabled type=checkbox> 데이터가 점진적으로 더 많이 유입될 여지가 없는가?</li><li><input checked disabled type=checkbox> 디버깅 용이성을 위해서 눈으로 확인이 가능한 모델이 필요한가?</li></ul><h3 id=avro--protobuf의-장점>Avro / Protobuf의 장점<a hidden class=anchor aria-hidden=true href=#avro--protobuf의-장점>#</a></h3><ul><li>강타입 유효성 검증을 통해 보다 일관된 데이터를 받을 수 있다<ul><li>ex. ENUM, float 등과 같이 지정된 타입이 아닐 경우 직렬화 자체가 실패함</li></ul></li><li>역/직렬화에 드는 비용을 최소화 할 수 있다<ul><li>본래 역/직렬화 성능은 압축률에 반비례한다 (<code>JSON</code>은 압축되지 않음). 단 추가적인 파싱 문제로 <code>JSON</code>은 매우 비효율적임</li><li><code>JSON</code>은 텍스트 기반이므로 추가적인 <code>Parsing</code>이 필요함</li><li><code>Avro</code>/<code>protobuf</code>는 바이너리 기반으로 <code>Parsing</code>이 필요없음</li></ul></li><li>상위/하위 호환성을 지원한다<ul><li>필드가 추가될 때, 해당 필드에 대한 모델이 반영되어 있지 않더라도 무시하고 정상 동작함</li></ul></li></ul><p><img loading=lazy src=/posts/schema-registry/image-1.png></p><p>실제 벤치마크 결과에서 JSON 비록 작은 데이터사이즈임에도 불구하고 직렬화와 역직렬화 성능이 2배 이상의 차이를 보였다.</p><p>놀라운 점은 데이터 크기가 커질수록 이 격차는 보다 확연해진다는 점이다.</p><h3 id=데이터-사이즈와-성능의-상관-관계>데이터 사이즈와 성능의 상관 관계<a hidden class=anchor aria-hidden=true href=#데이터-사이즈와-성능의-상관-관계>#</a></h3><p><code>JSON</code>은 BINARY가 아닌 TEXT의 형태로 저장되기에 <code>Avro</code>나 <code>Protobuf</code>에 비하여 보다 큰 공간을 차지한다.</p><ul><li><code>Kafka Volume</code>의 증가 : JSON 이벤트 사용을 위해 물리적으로 보다 큰 용량을 사용해야 함</li><li><code>Broker</code>에서 이벤트 생산/소비의 성능 저하 : 본질적으로 네트워크 통신에 있어 이동되는 데이터의 크기가 커질수록 성능이 저하될 수 밖에 없음<ul><li><code>Produce</code> 단계에서 <code>In Sync Replication</code>에 보다 큰 비용이 발생</li><li><code>Consume</code> 단계에서 이벤트를 가져오는 데에 보다 큰 비용이 발생</li></ul></li></ul><h2 id=schema-registry>Schema Registry<a hidden class=anchor aria-hidden=true href=#schema-registry>#</a></h2><p>이벤트 스키마를 정리하자면 주요하게 아래 3개를 보장한다</p><ul><li>일관성</li><li>성능 향상</li><li>호환성</li></ul><p><code>Schema Registry</code>는&mldr; Kafka 메시지의 데이터 구조(스키마)를 중앙에서 관리하고 검증하여 생산자와 소비자가 데이터 호환성을 유지하도록 돕는 서비스이다</p><h3 id=스키마-진화와-호환성>스키마 진화와 호환성<a hidden class=anchor aria-hidden=true href=#스키마-진화와-호환성>#</a></h3><p>[예시-2] API에서 v1 API를 v2 API로 전환한다 생각해보자. 기존 하위 호환성을 지키되 v1 API 사용자에게 v2로 전환을 부탁하고 &mldr; 몇개월이 지나 v1 API의 유입이 없음을 확인한 뒤에야 v2로 완전 전환이 가능할 것이다.</p><p>이벤트 스트림에서는 어떨까?</p><p>v2 스키마로 업데이트 이후에, 해당 이벤트를 구독중인 <code>Consumer</code>들에게 어떠한 필드가 추가되었는지 알리고.. <code>Consumer</code>는 필요에 따라 추가 구현을 진행하게 될 것이다.</p><p>그럼 <code>Producer</code>가 먼저 업데이트되어야 하는가? <code>Consumer</code>가 먼저 업데이트 되어야 하는가? 닭이 먼저냐 계란이 먼저냐??</p><p>다행히도 스키마 레지스트리를 사용하면 이러한 문제는 해결된다!</p><p><img loading=lazy src=/posts/schema-registry/image-2.png></p><p>스키마 레지스트리에 스키마를 등록하면, URL은 유지한 채로 <code>Consumer</code>는 최신 스키마 버전을 가져오게 된다.
<img alt="alt text" loading=lazy src=/posts/schema-registry/image-5.png></p><ol><li>Producer 에서 새로운 스키마 버전으로 이벤트가 발행됨 (v2)</li><li>Consumer 는 기존 캐싱된 스키마 버전과 다름을 인지하고 새로운 스키마 버전을 조회</li><li>새로운 스키마 버전으로 비즈니스 로직 수행</li></ol><p>이처럼 하위호환성을 유지하면서 스키마 변경이 자유로워진다</p><h3 id=효율적인-이벤트-관리>효율적인 이벤트 관리<a hidden class=anchor aria-hidden=true href=#효율적인-이벤트-관리>#</a></h3><p>무조건 <code>Schema Registry</code>가 좋으냐..? <code>Event Schema</code>는 필수인가..?</p><p>기술선택에 <strong>Must</strong>는 없다. 상황에 따라 최선의 선택을 하는것은 엔지니어의 역량에 달려있다 생각한다.</p><h4 id=kafka-stream에서의-schema-event-이해>Kafka Stream에서의 Schema Event 이해<a hidden class=anchor aria-hidden=true href=#kafka-stream에서의-schema-event-이해>#</a></h4><p>Schemaless인 <code>JSON</code>과는 달리, <code>Avro</code>와 <code>Protobuf</code>의 경우 Schema를 포함하여 Event와 함께 <code>Produce</code> 된다</p><blockquote><p><code>Avro</code>와 <code>Protobuf</code>의 경우 바이너리 포맷이며 스키마 없이 해석할 수 없기 때문에, 데이터를 어떻게 해석해야 하는지 스키마 정보가 요구됨
<img alt="alt text" loading=lazy src=/posts/schema-registry/image-3.png></p></blockquote><h4 id=이벤트-데이터-사이즈-비교>이벤트 데이터 사이즈 비교<a hidden class=anchor aria-hidden=true href=#이벤트-데이터-사이즈-비교>#</a></h4><p>스키마 이벤트의 장점으로 설명하였던 압축된 작은 바이너리 데이터는 스키마 정보를 포함하는 순간 퇴색된다.
<img alt="alt text" loading=lazy src=/posts/schema-registry/image-4.png>
이처럼 스키마 정보를 포함하는 순간 압축률이 높다 하더라도 보다 큰 데이터일 수 밖에 없다.</p><p>이러한 단점을 극복하는데 있어 스키마 ID는 이벤트 사이즈를 최소화할 수 있으며 호환성 보장이 가능하다.</p><blockquote><p>사실 <code>Producer</code>와 <code>Consumer</code>에서 동일한 스키마 파일이 있다면 굳이 스키마 정보를 포함하여 이벤트로 발행하지 않아도 가능하다.
단, <code>Submodule</code>의 단점은 다음과 같다</p><ul><li><code>Producer</code>와 <code>Consumer</code>가 같은 <code>.proto</code>를 사용해야 하는 전제 조건이 강함</li><li>스키마 변경이 동적으로 반영되지 않음</li><li>스키마 변경이 있을 경우, <code>Producer</code>와 <code>Consumer</code>를 모두 재배포해야 함</li></ul></blockquote><h3 id=aws-glue-와-schema-registry-차이>AWS Glue 와 Schema Registry 차이<a hidden class=anchor aria-hidden=true href=#aws-glue-와-schema-registry-차이>#</a></h3><p>MSK를 사용하는 경우, 별도 AWS Glue를 사용하여야 스키마 레지스트리를 사용할 수 있다.
이에 대한 차이는 다음과 같다.</p><table><thead><tr><th><strong>기능</strong></th><th><strong>AWS Glue Schema Registry</strong></th><th><strong>Confluent Schema Registry</strong></th></tr></thead><tbody><tr><td><strong>스키마 업데이트 방식</strong></td><td>새로운 버전으로 추가됨</td><td>새로운 버전으로 추가됨</td></tr><tr><td><strong>스키마 URL 유지 여부</strong></td><td>✅ 유지됨 (ARN 기반)</td><td>✅ 유지됨 (REST API 기반)</td></tr><tr><td><strong>자동 최신 버전 사용</strong></td><td>❌ 기본적으로 자동 X (Consumer 설정 필요)</td><td>✅ 기본적으로 자동 사용</td></tr><tr><td><strong>Kafka 호환성</strong></td><td>✅ AWS MSK와 연동 가능</td><td>✅ Confluent Kafka와 기본 연동</td></tr></tbody></table><h2 id=왜-schema-registry를-사용하냐고-물으신다면>왜 Schema Registry를 사용하냐고 물으신다면?<a hidden class=anchor aria-hidden=true href=#왜-schema-registry를-사용하냐고-물으신다면>#</a></h2><ol><li><p><code>Producer</code>와 <code>Consumer</code> 간 데이터 일관성 유지</p><ul><li><code>Producer</code>가 보내는 데이터와 <code>Consumer</code>가 기대하는 데이터 형식을 검증</li><li>데이터 불일치로 인한 <strong>비즈니스 로직 오류 방지</strong></li></ul></li><li><p>Schema Evolution(스키마 진화) 지원 → 하위/상위 호환성 보장</p><ul><li>새로운 필드 추가 시 기존 <code>Consumer</code>가 깨지지 않도록 유지 가능</li><li>기존 필드 삭제나 변경 시에도 안전한 데이터 처리가 가능</li></ul></li><li><p>스키마 관리의 중앙화 → 변경 및 배포 프로세스 단순화</p><ul><li>스키마를 중앙에서 관리하여 모든 서비스가 동일한 기준을 따름</li><li>개별 서비스에서 <strong>.proto 파일을 관리하지 않아도 자동으로 최신 버전 적용 가능</strong></li></ul></li><li><p>Kafka 메시지 크기 최소화 (스키마 ID 활용)</p><ul><li><strong>스키마 정보를 메시지에 직접 포함하지 않고</strong>, Schema Registry에서 스키마 ID만 전송</li><li><strong>네트워크 비용 절감 + Kafka 저장 공간 절약</strong></li></ul></li><li><p>Schema Validation(데이터 유효성 검증) 기능 제공</p><ul><li><code>Producer</code>가 잘못된 데이터(예: 필드 누락, 타입 불일치)를 보내면 <strong>Schema Registry에서 즉시 차단</strong></li><li><code>Consumer</code>가 유효한 데이터만 수신하여 안정적인 서비스 운영 가능</li></ul></li><li><p>실시간 스키마 변경 감지 및 자동 업데이트 가능</p><ul><li><code>Consumer</code>가 Schema Registry에서 최신 스키마를 조회하여 <strong>동적으로 변경된 필드를 활용 가능</strong></li><li>서비스 재배포 없이 데이터 구조 변경 가능</li></ul></li><li><p>Schema Compatibility Mode 설정 가능</p><ul><li>하위 호환성(Backward Compatibility), 상위 호환성(Forward Compatibility) 등의 정책을 설정하여 <strong>스키마 변경으로 인한 장애 방지</strong></li></ul></li><li><p>스키마 조회 및 버전 관리 용이</p><ul><li>REST API 혹은 UI를 통해 기존 스키마 및 변경 이력을 조회할 수 있어 유지보수 편리</li><li>특정 시점의 스키마 버전으로 롤백 가능</li></ul></li></ol><h2 id=refs>REFS<a hidden class=anchor aria-hidden=true href=#refs>#</a></h2><ul><li><a href=https://www.confluent.io/blog/schemas-contracts-compatibility/>Confluent</a></li><li><a href=https://oliveyoung.tech/2023-10-04/oliveyoung-b2b-msk-connect-introduction/>Oliveyoung</a></li><li><a href=https://www.linkedin.com/pulse/exploring-data-serialization-apache-kafka-json-protobuf-joe-z-tb2fc/>Exploring Data Serialization in Apache Kafka</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://dingyu.dev/tags/kafka/>Kafka</a></li><li><a href=https://dingyu.dev/tags/avro/>Avro</a></li><li><a href=https://dingyu.dev/tags/protobuf/>Protobuf</a></li><li><a href=https://dingyu.dev/tags/json/>Json</a></li><li><a href=https://dingyu.dev/tags/schema-registry/>Schema Registry</a></li></ul><nav class=paginav><a class=prev href=https://dingyu.dev/posts/dance-with-burrow/><span class=title>« 이전 페이지</span><br><span>[EDA] Kafka (MSK) Monitoring with Burrow Prometheus And Thanos</span>
</a><a class=next href=https://dingyu.dev/posts/grpc/><span class=title>다음 페이지 »</span><br><span>[Protocol] RPC... 그리고 GRPC 톺아보기</span></a></nav></footer><div id=giscus_thread><script src=https://giscus.app/client.js data-repo=dings-things/blog data-repo-id=R_kgDON9IuAw data-category=Announcements data-category-id=DIC_kwDON9IuA84CnTai data-mapping=og:title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=ko data-loading=lazy crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://dingyu.dev/>Ding's Coding Forge</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="복사";function s(){t.innerHTML="복사 완료!",setTimeout(()=>{t.innerHTML="복사"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>